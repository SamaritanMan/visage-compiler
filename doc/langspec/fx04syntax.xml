<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="syntax">
  <title>Operators and Expressions</title>

  <sect1 id="keywords">
    <title>Keywords</title>

    <para>This placeholder section holds a temporary keywords table. This list will change as the JavaFX™ Script programming language continues to develop.</para> 

       <table cellpadding="3" cellspacing="3" >
	
	<caption>Keywords Table </caption>
	
          <tbody>
	  
            <tr>
              <td><code>abstract</code></td>

              <td><code>assert</code></td>

              <td><code>attribute</code></td>

              <td><code>bind</code></td>

              <td><code>break</code></td>
            </tr>

            <tr>
              <td><code>class</code></td>

              <td><code>continue</code></td>
	      
	      <td><code>delete</code></td>

              <td><code>false</code></td>

              <td><code>for</code></td>
	      
	      
            </tr>

            <tr>
              <td><code>function</code></td>

              <td><code>if</code></td>

              <td><code>import</code></td>

              <td><code>init</code></td>

              <td><code>insert</code></td>
            </tr>

            <tr>
              <td><code>let</code></td>

              <td><code>new</code></td>

              <td><code>not</code></td>

              <td><code>null</code></td>

              <td><code>package</code></td>
            </tr>

            <tr>
              <td><code>private</code></td>

              <td><code>protected</code></td>

              <td><code>public</code></td>

              <td><code>readonly</code></td>

              <td><code>return</code></td>
            </tr>

            <tr>
              <td><code>super</code></td>

              <td><code>sizeof</code></td>

              <td><code>static</code></td>

              <td><code>this</code></td>

              <td><code>throw</code></td>
            </tr>

            <tr>
              <td><code>try</code></td>

              <td><code>true</code></td>

              <td><code>var</code></td>

              <td><code>while</code></td>

              <td><code>after</code></td>
            </tr>

            <tr>
              <td><code>and</code></td>

              <td><code>as</code></td>

              <td><code>before</code></td>

              <td><code>by</code></td>

              <td><code>catch</code></td>
            </tr>

            <tr>
              <td><code>do</code></td>

              <td><code>&nbsp;</code></td>

              <td><code>else</code></td>

              <td><code>exclusive</code></td>

              <td><code>extends</code></td>
            </tr>

            <tr>
              <td><code>finally</code></td>

              <td><code>first</code></td>

              <td><code>from</code></td>

              <td><code>in</code></td>

              <td><code>&nbsp;</code></td>
            </tr>

            <tr>
              <td><code>indexof</code></td>

              <td><code>into</code></td>

              <td><code>inverse</code></td>

              <td><code>lazy</code></td>
	      
	      <td><code>last</code></td>
            </tr>

            <tr>
              <td><code>on</code></td>

              <td><code>or</code></td>

              <td><code>replace</code></td>

              <td><code>step</code></td>

              <td><code>typeof</code></td>
            </tr>

            <tr>
              <td><code>with</code></td>

              <td><code>where</code></td>

              <td>&nbsp;</td>

              <td>&nbsp;</td>

              <td>&nbsp;</td>
            </tr>
	    
          </tbody>
        </table>
</sect1>



  <sect1 id="operators">
    <title>Operators</title>

    <!--  
    <para>An operator specifies a computational activity involving one or more operands. Operands can be data values, variables, objects or other program elements.</para>

    <para>Operators are usually associated with the data type of the operands being evaluated (see <emphasis>Types</emphasis>) but some operators can be overloaded to handle closely related types. For example; addition and multiplication operate only on data of type <code>integer</code> or <code>number</code>, but not <code>boolean</code> or <code>string</code>.</para>

    <para>In the JavaFX™ Script programming language, an operator can also be a keyword that defines a computation, a relationship between two data elements, or a reference to an object.</para>
    -->

   <!-- ****** new oper table goes here ******  -->
   
 
<para>The Operator Precedence Table associates JavaFX operators to their Java equivalents from from highest to lowest priority.</para>

<table class="oper" border="0">

<caption style="margin-bottom: 9pt;">Operator Precedence Table </caption>

<tbody>

    <tr style="padding-top: 9pt; padding-bottom: 9pt;">

      <th width="50" valign="top" >Priority</th>
      <th width="105" valign="top" >JavaFX Operator</th>
      <th width="98" valign="top" >Operation</th>
      <th width="100" valign="top" >Java Operator</th>
      <th width="107" valign="top" >Order of Evaluation</th>
    </tr>
	
	
	<tr style="border-top:thin solid black;">

      <td valign="top">1</td>
      <td><code class="style1">=</code></td>
      <td>assign operator</td>
      <td>=</td>
      <td rowspan="7" valign="top" >Right to Left </td>
    </tr>
	
	<tr style="border-top:thin solid black;">

      <td rowspan="6" valign="top">2</td>
      <td><code class="style1">+=</code></td>
      <td>add and assign </td>
      <td>+=</td>
	  
	  
    </tr>
	
	<tr>

      <td><code class="style1">-=</code></td>
      <td>subtract and assign </td>
      <td><code class="style1">-+</code></td>
    </tr>
	
	<tr>

      <td><code class="style1">*=</code></td>
      <td>multiply and assign </td>
      <td><code class="style1">*=</code></td>
    </tr>
	
	<tr>

      <td><code class="style1">/=</code></td>
      <td>divide and assign </td>
      <td><code class="style1">/=</code></td>
    </tr>
	
		<tr>

      <td><code class="style1">%=</code></td>
      <td>remainder and assign </td>
      <td><code class="style1">%=</code></td>
    </tr>
	
	
	<tr>

      <td><code class="style1">/=</code></td>
      <td>divide and assign </td>
      <td><code class="style1">/=</code></td>
    </tr>
	
	
	
		<tr style="border-top:thin solid black;">
<td valign="top">3</td>
<td><code class="style1">and</code></td>
      <td>logical and </td>
      <td><code class="style1">&amp;&amp;</code></td>
      <td valign="top">Right to Left </td>
    </tr>
	
	
	<tr style="border-top:thin solid black;">
<td valign="top">4</td>
<td><code class="style1">or</code></td>
      <td>logical or </td>
      <td><code class="style1">||</code></td>
      <td valign="top">Right to Left </td>
    </tr>
	
	<tr style="border-top:thin solid black;">
      <td rowspan="7" valign="top">5</td>
      <td><code class="style1">instanceof</code></td>
      <td>inheritance operator </td>
      <td><code class="style1">instanceof</code></td>
      <td rowspan="7" valign="top">Right to Left </td>
    </tr>
	
	
    <tr>
      
      <td><code class="style1">as</code></td>
      <td>cast operator </td>
      <td><code class="style1">n/a</code></td>
    </tr>
    <tr>
	<td><code class="style1">sizeof</code></td>
	<td>array length </td>
	<td><code class="style1">n/a</code></td>
  </tr>
	<tr>
	<td><code class="style1">indexof</code></td>
	<td>ordinal position </td>
	 <td><code class="style1">n/a</code></td>
  </tr>
	<tr>
	<td><code class="style1">new</code></td>
        <td>instantiation</td>
					  <td><code class="style1">new</code></td>
  </tr>
					<tr>
					  <td><code class="style1">op()</code></td>
					  <td>function call </td>
					  <td><code class="style1">n/a</code></td>
  </tr>
					<tr>
					  <td><code class="style1">x.op()</code></td>
					  <td>member function  call </td>
					  <td><code class="style1"></code></td>
  </tr>
	
	
	
	
<tr style="border-top:thin solid black;">
      <td rowspan="5" valign="top">6</td>
      <td><code class="style1">= =</code></td>
      <td>equality</td>
      <td><code class="style1">= = </code></td>
      <td rowspan="5" valign="top">Left to Right </td>
    </tr>
	
	
						<tr>
     
      <td><code class="style1">&lt; &gt; </code></td>
      <td>inequality</td>
      <td><code class="style1">!=</code></td>
    </tr>
	
	
						<tr>
      
      <td><code class="style1"> &lt;=</code></td>
      <td>less than or equal </td>
      <td><code class="style1">&lt;=</code></td>
    </tr>
	
	
	
						<tr>
      
      <td><code class="style1">&lt;-</code></td>
      <td>&nbsp;</td>
      <td><code class="style1"></code></td>
    </tr>
	
	
	
						<tr>
      
      <td><code class="style1">&lt; &gt;</code></td>
      <td>less than / greater than </td>
      <td><code class="style1">&lt; &gt; </code></td>
    </tr>
	
	
	
	
						<tr style="border-top:thin solid black;">
      <td rowspan="2" valign="top">7</td>
      <td><code class="style1">+</code></td>
      <td>addition</td>
      <td><code class="style1">+</code></td>
      <td rowspan="2" valign="top">Right to Left </td>
    </tr>
	
	
<tr>
      
      <td><code class="style1">-</code></td>
      <td>subtraction; uniary negation </td>
      <td><code class="style1">-</code></td>
    </tr>
	



	
	<tr style="border-top:thin solid black;">
      <td rowspan="3" valign="top">8</td>
      <td><code class="style1">*</code></td>
      <td>multiplication</td>
      <td><code class="style1">*</code></td>
      <td rowspan="3" valign="top">Right to Left </td>
    </tr>
	
	
		<tr>
      
      <td><code class="style1">/</code></td>
      <td>division</td>
      <td><code class="style1">/</code></td>
    </tr>
		<tr>
      
      <td><code class="style1">%</code></td>
      <td>remainder</td>
      <td><code class="style1"></code></td>
    </tr>
	
	
  <tr style="border-top:thin solid black;">
      <td rowspan="2" valign="top">9</td>
      <td><code class="style1">++ (prefixed)</code></td>
      <td>assign</td>
      <td><code class="style1">++</code></td>
      <td rowspan="2" valign="top">Right to Left </td>
    </tr>	
	
	<tr >
      
      <td><code class="style1">-- (prefixed)</code></td>
      <td>assign</td>
      <td><code class="style1">--</code></td>
	  
	      </tr>
	
	
	
			<tr style="border-top: thin solid black;">
			
      <td rowspan="2" valign="top">10</td>
      <td><code class="style1">++ (suffixed)</code></td>
      <td>assign</td>
      <td><code class="style1">++</code></td>
      <td rowspan="2" valign="top">Right to Left </td>
    </tr>	
	
	<tr>
      
      <td><code class="style1">-- (suffixed)</code></td>
      <td>assign</td>
      <td><code class="style1">--</code></td>
    </tr>
	
	
	</tbody>
	</table>
   
   
   
   
   
   
   <!-- ****** new oper table goes here ******  -->

    <para><emphasis role="bold">Operator Examples:</emphasis></para>

    <programlisting>import java.lang.System;
import java.lang.Math;

var x = 2;
var y = 4;
var a = true;
var b = false;
System.out.println(x == y);  // prints false
System.out.println(x &lt;&gt; y);  // prints false
System.out.println(x &lt; y);   // prints true
System.out.println(x &gt; y);   // prints true
System.out.println(x &gt;= y);  // prints false
System.out.println(x &lt;= y);  // prints true
System.out.println(x + y);   // prints  6
System.out.println(x - y);   // prints  -2
System.out.println(x * y);   // prints  8
System.out.println(x / y);   // prints  0 
System.out.println(x % y);   // prints  2
System.out.println(a and b); // prints  false
System.out.println(a or b);  // prints  true
System.out.println(not a);   // prints  false
System.out.println(sizeof [x,y]);   // prints  2
System.out.println([x,y][e | indexof e == 0]);   // prints  2
System.out.println(if (a) x else y); // prints 2
System.out.println(for(q in [x, y] where q &lt; 3) q); // prints 2
System.out.println(Math.max(x, y)); // prints 4
System.out.println("abc".toUpperCase()); // prints ABC
<!-- System.out.println(x instanceof Number); // prints true x = 10; -->
System.out.println(x); // prints 10
</programlisting>

<para style="padding-top:8pt">&nbsp;</para>



    <sect2 id="for"><title>Querying Sequences with<code> for</code> </title>


    <para>JavaFX Script programming language supports sequence comprehensions with a familiar
    syntax that should be easily understood by those familiar with the Java
    programming language, namely the <code>for</code> operator.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <programlisting>class Album {
     attribute title: String;
     attribute artist: String;
     attribute tracks: String*;
}

var albums =
     [Album {
          title: "A Hard Day's Night"
          artist: "The Beatles"
          tracks:
               ["A Hard Day's Night",
                "I Should Have Known Better",
                "If I Fell",
                "I'm Happy Just To Dance With You",
                "And I Love Her",
                "Tell Me Why",
                "Can't Buy Me Love",
                "Any Time At All",
                "I'll Cry Instead",
                "Things We Said Today",
                "When I Get Home",
                "You Can't Do That"]
     },
     Album {
          title: "Circle Of Love"
          artist: "Steve Miller Band"
          tracks:
               ["Heart Like A Wheel",
                "Get On Home",
                "Baby Wanna Dance",
                "Circle Of Love",
                "Macho City"]
     }];


for (album in albums) {
     for(track in album.tracks) {
          if(album.title == track) {
               java.lang.System.out.println("TITLE TRACK = {track}");
          } else {
               java.lang.System.out.println("Track = {track}");
          }
     }
}


Output:

TITLE TRACK = A Hard Day's Night
Track = I Should Have Known Better
Track = If I Fell
Track = I'm Happy Just To Dance With You
Track = And I Love Her
Track = Tell Me Why
Track = Can't Buy Me Love
Track = Any Time At All
Track = I'll Cry Instead
Track = Things We Said Today
Track = When I Get Home
Track = You Can't Do That
Track = Heart Like A Wheel
Track = Get On Home
Track = Baby Wanna Dance
TITLE TRACK = Circle Of Love
Track = Macho City 
</programlisting>
                                                          
    <para>A sequence comprehension consists of one or more input sequences, an
    optional filter, and an expression. Each input sequence is associated with
    a variable. The result of the sequence comprehension is a new sequence
    which is the result of applying the expression to the subset of the
    cartesian product of the source sequences' elements that satisfy the
    filter.</para>

    <para>Sequence comprehensions provide a concise syntax for a rather general
    class of iterations over sequences.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <programlisting>for (n in [1..100]) n * n</programlisting>

    <para>This is a sequence containing (in order) the squares of all the
    numbers from 1 to 100. Note that <emphasis>n</emphasis> is a local variable of the above
    expression.</para>

    <para>The use of a filter is shown by the following definition of a
    function which takes a number and returns a list of all its
    factors:</para>

    <para><emphasis></emphasis><programlisting>function factors(n:Number) {
     return for (i in [1 .. n/2] where n % i == 0) i;
}
</programlisting></para>

</sect2>

    <sect2 id="insert"><title>Modifying Sequences with  <code>insert</code> and
    <code>delete</code></title>

    <para>In addition to the assignment operator <code>=</code>, the  JavaFX script programming language 
    provides the list comprehension specifiers, <code>insert</code> and
    <code>delete</code>.</para>

    
</sect2>
    
    
<sect2 id="insop"><title><code>insert</code></title>

    <para><code>insert</code> can take any of the following
    forms:</para>

    <programlisting>insert Expression1 [as first | as last] into Expression2
insert Expression1 before Expression2
insert Expression1 after Expression2
</programlisting>

    <para><code>insert</code> inserts the items returned by
    evaluating <emphasis>Expression1</emphasis> into the location indicated by remainder of the
    statement as follows:</para>
    
    </sect2>
    
    
<sect2 id="into">
        <title><code>into</code></title>

    <para><emphasis>Expression2</emphasis> must refer to an attribute or variable. If <emphasis>Expression2</emphasis>
    refers to a single valued attribute then the effect of the insert is the
    same as if the assignment operator were used.</para>

    <para>If <code>as first</code> is specified, the insertion location is
    before the first element of the list indicated by <emphasis>Expression2.</emphasis> If <code>as
    last</code> is specified, the insertion location is after the last element
    of the list indicated by <emphasis>Expression2.</emphasis> If neither <code>as first</code> nor
    <code>as last</code> is specified explicitly, then <code>as last</code> is
    used as the default.</para>

    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var x = [1,2,3];
insert 12 into x; // yields [1,2,3,12]
insert 10 as first into x; // yields [10,1,2,3,12]
insert [99,100] as last into x; // yields [10,1,2,3,12,99,100]
</programlisting>

</sect2>

<sect2 id="before">
        <title>The <code>before</code> and <code>after</code> Specifiers</title>

    <para><emphasis>Expression2</emphasis> must be a selection expression over an
    attribute or variable. If <code>before</code> is specified, the insertion
    location is before the selected elements. If <code>after</code> is
    specified the insertion location is after the selected elements.</para>

    
    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var xs = [1,2,3];
insert 10 after xs[x | x == 10]; // yields [1,2,3,10]
insert 12 before xs[1]; // yields [1,12,2,3,10]
insert 13 after xs[x | x == 2]; // yields [1, 12, 2, 13, 3, 10];
</programlisting>

</sect2>

 <sect2 id="del">
        <title><code>delete</code></title>

    <para><code>delete</code> takes one of the following
    forms:</para>

    <programlisting>delete variable
delete Expression.attribute
delete variable[predicate]
delete Expression.attribute[predicate]
</programlisting>

    <para>The first two forms remove all elements from a variable or attribute
    - which is equivalent to assigning <code>[]</code> or <code>null</code> to
    the variable or attribute. The latter two forms remove only those elements
    that match the predicate.</para>

    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var xs = [1,2,3];
insert 10 into xs; // yields [1,2,3,10]
insert 12 before xs[1]; // yields [1,12,2,3,10]
delete xs[x | x == 12]; // yields [1,2,3,10]
delete xs[x | x &gt;= 3]; // yields [1,2]
insert 5 after xs[ x | x == 1]; // yields [1,5,2];
insert 13 as first into xs; // yields [13, 1, 5, 2];
delete xs; // yields []
</programlisting>

  </sect2>

</sect1>


  <sect1 id="expressions">
    <title>Expressions</title>

    <para>Unlike the Java programming language, the JavaFX Script programming language is an expression
    language. All executable statements are expressions which consist of zero
    or more inputs and a single output. This includes conditionals, loops, and
    even blocks.</para>

    <para>
      <emphasis role="bold">Example:</emphasis>
    </para>

    <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String = null;
if (rand % 2 == 0) {
     s = "rand is even";
} else {
     s = "rand is odd";
}
System.out.println(s);
</programlisting>

    <para>In the above example the then and else clauses of the conditional
    "if" are expressions in their own right, namely block expressions
    <!-- <emphasis role="bold">[to-do, link to block expressions section
    below]</emphasis>  --></para>

    <sect2 id="logical">
      <title>Logical Expressions</title>

      <para>This section lists and defines the logical expressions available
      in JavaFX™ Script.</para> 
      

<sect3 id="if">
<title><code>if</code> Expression</title>

        <para>The <code>if</code> expression is like the expression in the
        Java™ programming language, except that curly braces are always
        required around the <code>then</code> and <code>else</code> clauses,
        unless the the <code>else</code> clause is another <code>if</code>
        expression.</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       if (condition1) {
           System.out.println("Condition 1");
       } else if (condition2) {
           System.out.println("Condition2");
       } else {
           System.out.println("not Condition 1 or Condition 2");
       }
</programlisting>

</sect3>

      <sect3 id="while">
        <title><code>While</code> Statement</title>

        <para>The JavaFX Script programming language<code>while</code> statement is like the
        statement in the Java Programming language, except that curly braces
        are always required around the body.</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       var i = 0;
       while (i &lt; 10) {
           if (i &gt; 5) {
              break;
           }
           System.out.println("i = {i}");
           i += 1;
       }
</programlisting>
</sect3>

<sect3 id="try">
   <title><code>try</code> Statement</title>

        <para>The JavaFX Script programming language <code>try</code> statement is like the
        statement in the Java Programming language, but with JavaFX Script
        variable declaration syntax.</para>

        <note>In the JavaFX Script programming language, objects extending <code>java.lang.Throwable</code> can be thrown and caught.</note>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       try {
          throw "Hello";
       } catch (s:String) {
          System.out.println("caught a String: {s}");
       } catch (any) {
          System.out.println("caught something not a String: {any}");
       } finally {
          System.out.println("finally...");
       }
   </programlisting>
</sect3>

<sect3 id="for">
     <title><code>for</code> Expression</title>

<!--
        <para>
          <emphasis role="bold">QUESTION: We need a new intro to go with the
          <code>for</code> statement.</emphasis>
        </para>
 -->
 
        <para>The header of the JavaFX Script programming language<code>for</code> statement uses
        the same syntax as the <code>for</code> list comprehension
        operator.
	
	<!-- This needs to be linked to the list comprehension discussion in the Arrays chapter -->
	
	
        However; in this case the body of the statement is executed for each
        element generated by the list comprehension.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

        <programlisting>        for (i in [0..10]) {
             System.out.println("i = {i}");
        }

        // print only the even numbers using a filter
        for (i in [0..10] where i % 2 == 0) {
             System.out.println("i = {i}");
        }

        // print only the odd numbers using a range expression
        for (i in [1..10 step 2]) {
             System.out.println("i = {i}");
        }

        // print the cartesian product
        for (i in [0..10], j in [0..10]) {
             System.out.println(i);
             System.out.println(j);
        }

</programlisting>
</sect3>

<sect3 id="return">
   <title><code>return</code> Statement</title>

        <para>The JavaFX Script programming language<code>return</code> statement is like the
        statement in the Java Programming language:</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       function add(x, y) {
           return x + y;
       }
</programlisting>
</sect3>

<sect3 id="throw">
    <title><code>throw</code> Statement</title>

        <para>The JavaFX Script programming language<code>throw</code> statement is like the
        statement in the Java Programming language.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

<programlisting>       import java.lang.Exception;

       function foo() {
           throw new Exception("this is a java exception");
       }

       function bar() {
           throw "just a string";
       }
</programlisting>
      </sect3>

      <sect3 id="break">
        <title><code>break</code> and <code>continue</code> Statements</title>

        <para>The JavaFX Script programming language<code>break</code> and <code>continue</code>
        statements are like the statement in the Java Programming language;
        however labels are not supported. As in Java, <code>break</code> and
        <code>continue</code> must appear inside the body of a
        <code>while</code> or <code>for</code> statement.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

        <programlisting>       function foo() {
          for (i in [0..10]) {
              if (i &gt; 5) {
                  break;
              }
              if (i % 2 == 0) {
                  continue;
              }
              System.out.println(i);
          }
       }

 ! function bar() {
             var i = 0;
             while (i &lt; 10) {
                 if (i &gt; 5) {
                     break;
                 }
                 if (i % 2 == 0) {
                     continue;
                 }
                 System.out.println(i);
- i += 1;
             }
         }
</programlisting>
</sect3>

<!--  ********* comment out the do and the do later 
      ********* sections for now 
            
          <sect2 id="do">
            <title><code>do</code> Statement</title>

            <para>The JavaFX Script <code>do</code> statement allows you to execute a
            block of JavaFX Script code in a background thread while allowing the AWT
            Event Dispatch Thread to continue processing events. This prevents the UI from appearing to hang. </para>
	    
	    <para> Currently, this is
            implemented by using <code>java.awt.EventQueue</code> to handle
            events while the background thread is executing. Normally, all
            JavaFX Script code executes in the AWT Event Dispatch Thread. Only code
            contained in the body of a <code>do</code> statement is allowed to
            execute in another thread. <CODE>do</CODE> statement code must only access Java language objects
            (and those objects must handle their own thread synchronization,
            if necessary).</para>

            <para><emphasis role="bold">Example:</emphasis></para>

            <programlisting>        import java.net.URL;
        import java.lang.StringBuffer;
        import java.lang.System;
        import java.io.InputStreamReader;
        import java.io.BufferedReader;



        // in the AWT EDT
        var result = new StringBuffer();

        do {
             // now in a background thread
             var url = new URL("http://www.foo.com/abc.xml");
             var is = url.openStream();
             var reader = new BufferedReader(new InputStreamReader(is));
             var line;
             while (true) {
                  line = reader.readLine();
                  if (line == null) {
                       break;
                  }
                  result.append(line);
                  result.append("\n");
             }
        } 

        // now back in the EDT
        System.out.println("result = {result}"); 
</programlisting>

 <para>In the above example, the code which is executing in
 the EDT appears to be blocked during the execution of the body of
the <code>do</code> statement. However, the system creates a new event
dispatch loop on the stack while waiting for the background thread to complete. As a result, GUI events continue to be processed while the <code>do</code> statement executes.</para>
	    
<note>This isn't a perfect solution. It can cause many event dispatch loops to be placed on the stack, and this can cause a stack overflow exception.</note>
	    
	    
</sect2>

<sect2 id="dolater">
  <title><code>do later</code> Statement</title>

<para>The <code>do</code> statement has a second form (<code>do
later</code>) that allows for asynchronous execution of its body
in the EDT rather than synchronous execution in a background
thread. This mimics the functionality of
 <code>java.awt.EventQueue.invokeLater</code>) </para>
	    
<para><emphasis role="bold">Example:</emphasis></para>

 <programlisting>        import java.lang.System;
        var saying1 = "Hello World!";
        var saying2 = "Goodbye Cruel World!";
        do later {
             System.out.println(saying1);
        }
        System.out.println(saying2);
</programlisting>

            <para>Running this code produces the following output:</para>

            <programlisting>        Goodbye Cruel World!
        Hello World!
</programlisting>
          </sect2>

-->

      <sect3 id="block">
        <title>Block Expressions</title>

        <para>A block expression consists of a list of statements (which can
        be declarations or expressions) surrounded by curly braces and
        separated by semicolons. If the last statement is an expression, then
        the value of a block expression is the value of the last expression;
        otherwise the block expression has <code>void</code> type.
</para>

        <para>So, the above example from the top of this section could also be
        written as follows:</para>

        <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String =
if (rand % 2 == 0) {
     "rand is even";
} else {
     "rand is odd";
};
System.out.println(s);
</programlisting>

        <para>Alternately the braces can be omitted:</para>

        <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String = if (rand % 2 == 0) "rand is even" else "rand is odd";
System.out.println(s);
</programlisting>

        <para>The Java programming language contains both an <code>if</code> statement,
        and a conditional expression: <code>a &lt; b ? a :
        b</code>.</para>

        <para>Thanks to block expressions, the JavaFX Script programming language <code><emphasis>if</emphasis></code>  expression takes
        the place of both.</para>
	
	
 </sect3>

      <sect3 id="range">
        <title>Range Expressions</title>

        <para>As mentioned in chapter two  <!-- <emphasis role="bold">[TO-DO:
        confirm that location and provide link]</emphasis> --> it is possible to
        define a sequence of numeric values forming an arithmetic series using
        the following syntax:</para>

        <programlisting>[number1..number2]
</programlisting>

        <para>Such an expression defines an sequence whose elements consist of
        the integers from <emphasis>number1</emphasis> to
        <emphasis>number2</emphasis> (inclusive).</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>var nums = [0..3];
System.out.println(nums == [0,1,2,3]); // prints true
</programlisting>

        <para>By default the interval between the values is 1 but it is also possible to specify a different interval by including the next number in the sequence after number1 separated by a comma. For example, the following expression defines an sequence consisting of the odd numbers between 1 and 10:</para>

        <programlisting>[1,3..10]</programlisting>

        <para>... and syntax for descending sequences
"If <emphasis>number1</emphasis> is greater than <emphasis>number2</emphasis> a descending series is created:</para>

        <programlisting>var nums = [3..0 step -1];
System.out.println(nums == [3,2,1,0]); // prints true
</programlisting>

<para>Note that these declarations:</para>
<programlisting>var nums1 = [3..0 ]; 
var nums2 = [3..0 step 1]; </programlisting>

<para>actually declare empty sequences.</para>

</sect3>
</sect2>


<!-- *********** new binding section ***************** -->


<sect2 id="binding2"><title>Binding</title>

<para>The <emphasis>bind</emphasis> keyword associates the value of a target variable to the value of a remote variable.  </para>

<programlisting>let x = bind someExpression; </programlisting>

<para>This binds the outcome of <emphasis><code>someExpression</code></emphasis> to the variable <code>x</code>. When <emphasis><code>someExpression</code></emphasis> changes, JavaFX Script updates the value of <code> x </code>. </para>

<para>In JavaFX Script, the remote variable can be a simple value of some basic type, the outcome of an expression, the outcome of a block of expressions or a bound function. </para>


<sect3 id="recalc"><title>Update Recalculations</title>

<para>In some cases you need to know exactly how the update occurs, or what is meant by <code><emphasis>someExpression</emphasis></code> changing.</para>

<para>When a remote value changes, JavaFX Script performs a minimal recalculation. This only matters in limited circumstances; for example, when a binding requires an object creation is done in a bind and if, because of object identity, it matters whether or not a new object was created. </para>

<para><emphasis role="bold">Example: </emphasis></para>

<programlisting>    let sum = bind expr1 + expr2;</programlisting>

<para>if <emphasis><code>expr2</code></emphasis> changes then JavaFX Script recalculates sum, but does not recalculate <emphasis><code>expr1</code></emphasis>. The value for <emphasis><code>expr1</code></emphasis> was previously stored and it is simply re-fetched. </para>

<para><emphasis role="bold">Example: </emphasis></para>

<programlisting>    var y = 3;
    function ten() : Integer { 10 }
    let sum = bind ten() + y;
    println(sum);
    y = 7;
    println(sum);</programlisting>

<para>This prints:</para>

<programlisting>    13
    17</programlisting>

<para><emphasis role="bold">Note:</emphasis> Assume a <code>println</code> function equivalent to <code>System.out.println.</code></para>

<para>When <code>y</code> is set to <emphasis>7</emphasis>, the function <code>ten()</code> is not called again (since it didn't change), its value has been remembered and reused.</para>

<para>Using the <code>let</code> keyword introduces a variable which cannot be assigned to.  </para>
</sect3>



<sect3 id="conditional"><title>Conditional Expressions</title>


<para>Consider the following expression: </para>

<programlisting>    let x = bind if (condExpr) expr1 else expr2;</programlisting>

<para>A change to <emphasis><code>condExpr </code></emphasis> changes which branch of the <code>if</code> statement will be evaluated. A change to <emphasis><code>expr1</code></emphasis> or <emphasis><code>expr2</code></emphasis> does not cause either of the other expressions to be recalculated.</para>

</sect3>



<sect3 id="fexpr"><title>for Expressions</title>

<para>Consider the following expression:</para>

<programlisting>    let newSeq = bind for (elem in seq) expr;</programlisting>

<para>If <code>seq</code> changes, the elements in <code>newSeq</code> which corresponded to elements still in seq are not recalculated.  In other words; if an element is inserted into <code>seq</code>, the results of applying <code>expr</code> to that element are inserted into <code>newSeq</code> at the corresponding positions and the other elements are not recalculated.  </para>

<para>Exception:  if <code>expr</code> uses <code>indexof elem</code> then those elements whose index changed will need to be updated, but corresponding to the minimal update rules.  </para>

<para><emphasis role="bold">Example: </emphasis></para>

<programlisting>    var min = 0;
    var max = 3;
    function square(x : Integer) : Integer { x*x }
    let values = bind for (x in [min..max]) square(x);
    println(values);
    max = 5;
    println(values);
    min = 1;
    println(values);
    min = 0;
    println(values);</programlisting>

<para>Output:</para>

<programlisting>    [ 0, 1, 4, 9 ]
    [ 0, 1, 4, 9, 16, 25 ]
    [ 1, 4, 9, 16, 25 ]
    [ 0, 1, 4, 9, 16, 25 ]</programlisting>

<para>JavaFX Script performs the following recalculations: </para>

<itemizedlist>
<listitem>Calculate the squares of 0 through 3.  The squares of 4 and 5 (0 through 3 are not recalculated when the max changes).  </listitem>

<listitem>Delete the square of zero without recalculating any values</listitem>

<listitem>Add back the square of zero. This requires it to be recalculated.  This behavior is the same if insert and delete are used instead.</listitem>
</itemizedlist>
</sect3>

<sect3 id="blocks"><title>Block Expressions</title>


<para>A block-expression is an optional sequence of statements followed by an expression enclosed in curly braces:</para>

    { statement; statement; statement; expression }

<para>The value of a block-expression is the value of the terminating expression.  Within a <code>bind</code>, the only statements which can occur in a block-expression are variable declarations.  Note that assignment (including increment and decrement) are prohibited within <code>bind</code>.  Thus a bound block-expression has the form:</para>

<programlisting>    bind { var a = expr; var b = expr; var c = expr; expr }</programlisting>

<para>Because any changes to the bound expression cause an update, and because that update is minimal, it is easy to see that the variables are effectively bound.  Note also that <code>while, insert</code> and <code>delete</code> are statements and therefore can not occur within a <code>bind</code>.</para>
</sect3>


<sect3 id="functioncalls"><title>Function and Method Calls</title>


<programlisting>    let val = bind foo(a, b);</programlisting>

<para>A non-bound function is one that is not preceded with the <code>bound</code> keyword.  For calls to Java methods or non-bound JavaFX Script functions, JavaFX Script re-invokes the function if any of the arguments change, but the body of a function is a black-box. Dependencies it might have beyond its input parameters do not cause a recalculation.  </para>

<para><emphasis role="bold">Example: </emphasis></para>

<programlisting>    class Point {
      attribute x : Number;
      attribute y : Number;
    }

    var scale = 1.0;
    function makePoint(x0 : Number, y0 : Number) : Point {
      Point {
        x: x0 * scale
        y: y0 * scale
      }
    }

    var myX = 3.0;
    var myY = 3.0;
    let pt = bind makePoint(myX, myY);
    println(pt.x);
    myX = 10.0;
    println(pt.x);
    scale = 2.0;
    println(pt.x);</programlisting>

<para>Will print:</para>

<programlisting>    3.0
    10.0
    10.0</programlisting>

<para>Changing the argument <code>myX</code> causes <code>makePoint</code> to be called again.  But, the function <code>makePoint</code> is a black-box.  Changing the value assigned to scale will not cause an update, as it probably should.  That's where a <code>bound</code> function is intended to work -- a <code>bound</code> function causes the update that you would expect.</para>
</sect3>



<sect3 id="boundfunctions"><title>Bound Functions</title>

<para>Bound functions have as their body a block-expression which is bound (it thus has the above restrictions on bound block-expressions).  When binding to a bound function, changes besides the arguments causes an update, and the function sees changes to its arguments. So, if the above function <code>makePoint</code> were made a bound function:</para>

<programlisting>    bound function makePoint(x0 : Number, y0 : Number) : Point {</programlisting>

<para>The change to the value assigned to <code>scale</code> now causes an update (20.0).  Note that if <code>myX</code> changes, only <code> x0 * scale</code> would be recalculated, not<code> y0 * scale </code>.</para>

<para>Calling a <code>bound</code> function from outside a <code>bind</code> is just like calling a non-bound function.

</para></sect3>


<sect3 id="objliterals"><title>Object Liberals and Binding</title>


<para>Object literals behave like operators and non-bound functions.  If one of the arguments to the object literal changes then it is re-executed (a new instance is created).</para>

    <programlisting>let pt = bind Point { x: myX  y: myY  }</programlisting>

<para>If <code>myX</code> changes, JavaFX Script builds a new Point object -- the expected behavior for immutable objects.  </para>

<para>If you want the value of <code> x </code> to track the value of <code>myX </code> without creating a new Point, then you bind it:</para>

    <programlisting>let pt = bind Point { x: bind myX  y: myY  }</programlisting>

<para>Now if <code> myX </code> changes, the <code> x </code> attribute of point will be updated, but arguments to the object literal have not changed (x is still, and will always be, bound to <code> myX </code>).  Changes to <code> myY </code> will still cause a new Point to be created.  </para>

<para>For this example, you would probably want to bind y as well:</para>

    <programlisting>let pt = bind Point { x: bind myX  y: bind myY  }</programlisting>

<para>where <code> pt </code> would always remain the same Point instance. It would be the same without the initial bind:</para>

<programlisting>    let pt = Point { x: bind myX  y: bind myY  }</programlisting>

</sect3>
</sect2>
</sect1>

</chapter>



