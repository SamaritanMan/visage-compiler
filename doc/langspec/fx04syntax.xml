<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Operators and Expressions</title>

  <sect1 id="keywords">
    <title>Key Words</title>

    <para>This placeholder section holds a temporary key words table. This
    list will change as JavaFX™ Script continues to develop.</para>

        <table cellpadding="3" cellspacing="3" style="border-top: 1px solid black; border-bottom: 1px solid black;  margin-left:24pt;">
	
	<caption>Keywords Table </caption>
          <tbody>
            <tr>
              <td><code>abstract</code></td>

              <td><code>assert</code></td>

              <td><code>attribute</code></td>

              <td><code>bind</code></td>

              <td><code>break</code></td>
            </tr>

            <tr>
              <td><code>class</code></td>

              <td><code>continue</code></td>
	      
	      <td><code>delete</code></td>

              <td><code>false</code></td>

              <td><code>for</code></td>
	      
	      
            </tr>

            <tr>
              <td><code>function</code></td>

              <td><code>if</code></td>

              <td><code>import</code></td>

              <td><code>init</code></td>

              <td><code>insert</code></td>
            </tr>

            <tr>
              <td><code>let</code></td>

              <td><code>new</code></td>

              <td><code>not</code></td>

              <td><code>null</code></td>

              <td><code>package</code></td>
            </tr>

            <tr>
              <td><code>private</code></td>

              <td><code>protected</code></td>

              <td><code>public</code></td>

              <td><code>readonly</code></td>

              <td><code>return</code></td>
            </tr>

            <tr>
              <td><code>super</code></td>

              <td><code>sizeof</code></td>

              <td><code>static</code></td>

              <td><code>this</code></td>

              <td><code>throw</code></td>
            </tr>

            <tr>
              <td><code>try</code></td>

              <td><code>true</code></td>

              <td><code>var</code></td>

              <td><code>while</code></td>

              <td><code>after</code></td>
            </tr>

            <tr>
              <td><code>and</code></td>

              <td><code>as</code></td>

              <td><code>before</code></td>

              <td><code>by</code></td>

              <td><code>catch</code></td>
            </tr>

            <tr>
              <td><code>do</code></td>

              <td><code>dur</code></td>

              <td><code>else</code></td>

              <td><code>exclusive</code></td>

              <td><code>extends</code></td>
            </tr>

            <tr>
              <td><code>finally</code></td>

              <td><code>first</code></td>

              <td><code>from</code></td>

              <td><code>in</code></td>

              <td><code>indexof</code></td>
            </tr>

            <tr>
              <td><code>indexof</code></td>

              <td><code>into</code></td>

              <td><code>inverse</code></td>

              <td><code>lazy</code></td>
	      
	      <td><code>last</code></td>
            </tr>

            <tr>
              <td><code>on</code></td>

              <td><code>or</code></td>

              <td><code>replace</code></td>

              <td><code>step</code></td>

              <td><code>typeof</code></td>
            </tr>

            <tr>
              <td><code>with</code></td>

              <td><code>where</code></td>

              <td> </td>

              <td> </td>

              <td> </td>
            </tr>
          </tbody>
        </table>
</sect1>



  <sect1>
    <title>Operators</title>

    <para>An operator specifies a computational activity involving one or more
    operands. Operands can be data values, variables, objects or other program
    elements.</para>

    <para>Operators are usually associated with the data type of the operands
    being evaluated (see <emphasis>Types</emphasis>) but some operators can be
    overloaded to handle closely related types. For example; addition and
    multiplication operate only on data of type <code>integer</code> or
    <code>number</code>, but not <code>boolean</code> or
    <code>string</code>.</para>

    <para>In JavaFX™ Script, an operator can also be a keyword that defines a
    computation, a relationship between two data elements, or a reference to
    an object.</para>

    <para>JavaFX Script supports the following operators, grouped according to
    function and data type:</para>

    <table cellpadding="5" cellspacing="5" style="border-top: 1px solid black; border-bottom: 1px solid black; ">
    
    <caption><title>Operator Table</title></caption>
    
      <tbody>
        <tr>
          <th style="text-decoration: underline;">Operator</th>

          <th style="text-decoration: underline;">Meaning</th>

          <th style="text-decoration: underline;">Java™ Equivalent</th>
        </tr>

        <tr>
          <th />
        </tr>

        <tr>
          <td colspan="2">
            <emphasis>Relational Operators</emphasis>
          </td>
        </tr>

        <tr>
          <td>
            <code>==</code>
          </td>

          <td>equality</td>

          <td>
            <code>==</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>&lt;&gt;</code>
          </td>

          <td>inequality</td>

          <td>
            <code>!=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>&lt;</code>
          </td>

          <td>less than</td>

          <td>
            <code>&lt;</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>&gt;</code>
          </td>

          <td>greater than</td>

          <td>
            <code>&gt;</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>&lt;=</code>
          </td>

          <td>less than or equal</td>

          <td>
            <code>&lt;=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>&gt;=</code>
          </td>

          <td>greater than or equal</td>

          <td>
            <code>&gt;=</code>
          </td>
        </tr>

        <tr>
          <th />
        </tr>

        <tr>
          <td colspan="2">
            <emphasis>Boolean Operators</emphasis>
          </td>

          <td />
        </tr>

        <tr>
          <td>
            <code>and</code>
          </td>

          <td>logical and</td>

          <td>
            <code>&amp;&amp;</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>or</code>
          </td>

          <td>logical or</td>

          <td>
            <code>||</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>not</code>
          </td>

          <td>logical negation</td>

          <td>
            <code>!</code>
          </td>
        </tr>

        <tr>
          <th />
        </tr>

        <tr>
          <td colspan="2">
            <emphasis>Arithmetic Operators</emphasis>
          </td>
        </tr>

        <tr>
          <td>
            <code>+</code>
          </td>

          <td>addition</td>

          <td>
            <code>+</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>-</code>
          </td>

          <td>subtraction; unary negation</td>

          <td>
            <code>-</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>*</code>
          </td>

          <td>multiplication</td>

          <td>
            <code>*</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>/</code>
          </td>

          <td>division</td>

          <td>
            <code>/</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>%</code>
          </td>

          <td>remainder</td>

          <td>
            <code>%</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>+=</code>
          </td>

          <td>add and assign</td>

          <td>
            <code>+=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>-=</code>
          </td>

          <td>subtract and assign</td>

          <td>
            <code>-=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>*=</code>
          </td>

          <td>multiply and assign</td>

          <td>
            <code>*=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>/=</code>
          </td>

          <td>divide and assign</td>

          <td>
            <code>/=</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>++</code>
          </td>

          <td>assign</td>

          <td>
            <code>++</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>--</code>
          </td>

          <td>assign</td>

          <td>
            <code>--</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>%=</code>
          </td>

          <td>remainder and assign</td>

          <td>
            <code>%=</code>
          </td>
        </tr>

        <tr>
          <th />
        </tr>

        <tr>
          <td colspan="2">
            <emphasis>Other Operators</emphasis>
          </td>
        </tr>

        <tr>
          <td>
            <code>=</code>
          </td>

          <td>assign operator</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>sizeof</code>
          </td>

          <td>array length</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>indexof</code>
          </td>

          <td>ordinal position</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>if <emphasis>e1</emphasis> then <emphasis>e2</emphasis> else
            <emphasis>e3</emphasis></code>
          </td>

          <td>conditional expression</td>

          <td>
            <code>if <emphasis>e1</emphasis> e2 <emphasis>[else
            e3]</emphasis></code>
          </td>
        </tr>

        <!--     <tr>
          <td>
            <code>select</code>
          </td>

          <td>list comprehension</td>

          <td>
            <code>n/a</code>
          </td>
        </tr> 

        <tr>
          <td>
            <code>foreach</code>
          </td>

          <td>list comprehension</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>  -->

        <tr>
          <td>
            <code>new</code>
          </td>

          <td>allocation</td>

          <td>
            <code>new</code>
          </td>
        </tr>

        <tr>
          <td>
            <code><emphasis>op</emphasis>()</code>
          </td>

          <td>function call</td>

          <td>
            <code>
              <emphasis>n/a</emphasis>
            </code>
          </td>
        </tr>

        <tr>
          <td>
            <code><emphasis>x</emphasis>.<emphasis>op</emphasis>()</code>
          </td>

          <td>member function/operation call</td>

          <td>
            <code><emphasis>x</emphasis>.<emphasis>op</emphasis>()</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>instanceof</code>
          </td>

          <td>type check</td>

          <td>
            <code>instanceof</code>
          </td>
        </tr>

        <!-- 
        <tr>
          <td>
            <code>this</code>
          </td>

          <td>self access</td>

          <td>
            <code>this</code>
          </td>
        </tr>
-->

        <tr>
          <td>
            <code>.</code>
          </td>

          <td>attribute access, context access</td>

          <td>
            <code>., n/a</code>
          </td>
        </tr>

        <!--
        <tr>
          <td>
            <code>bind [lazy]</code>
          </td>

          <td>incremental [lazy] evaluation</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>
 -->

        <tr>
          <td>
            <code>:</code>
          </td>

          <td>eager initialization</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>[]</code>
          </td>

          <td>array selection</td>

          <td>
            <code>[]</code>
          </td>
        </tr>

        <!--
        <tr>
          <td>
            <code>format as</code>
          </td>

          <td>String formatting</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>
-->

        <!--
        <tr>
          <td>
            <code>&lt;&lt;&gt;&gt;</code>
          </td>

          <td>Identifier quotes</td>

          <td>
            <code>n/a</code>
          </td>
        </tr> 
	-->

        <!-- 
        <tr>
          <td>
            <code>{}</code>
          </td>

          <td>String expression</td>

          <td>
            <code>n/a</code>
          </td>
        </tr> 
	
	-->

        <tr>
          <td>
            <code>(<emphasis>expr</emphasis>)</code>
          </td>

          <td>grouping</td>

          <td>
            <code>(<emphasis>expr</emphasis>)</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>reverse</code>
          </td>

          <td>reverses a list</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>

        <tr>
          <td>
            <code>[<emphasis>number1</emphasis>,<emphasis>next</emphasis>..<emphasis>number2</emphasis>]</code>
          </td>

          <td>numeric range</td>

          <td>
            <code>n/a</code>
          </td>
        </tr>
      </tbody>
    </table>

    <para><emphasis role="bold">Operator Examples:</emphasis></para>

    <programlisting>import java.lang.System;
import java.lang.Math;

var x = 2;
var y = 4;
var a = true;
var b = false;
System.out.println(x == y);  // prints false
System.out.println(x &lt;&gt; y);  // prints false
System.out.println(x &lt; y);   // prints true
System.out.println(x &gt; y);   // prints true
System.out.println(x &gt;= y);  // prints false
System.out.println(x &lt;= y);  // prints true
System.out.println(x + y);   // prints  6
System.out.println(x - y);   // prints  -2
System.out.println(x * y);   // prints  8
System.out.println(x / y);   // prints  0 
System.out.println(x % y);   // prints  2
System.out.println(a and b); // prints  false
System.out.println(a or b);  // prints  true
System.out.println(not a);   // prints  false
System.out.println(sizeof [x,y]);   // prints  2
System.out.println([x,y][e | indexof e == 0]);   // prints  2
System.out.println(if (a) x else y); // prints 2
System.out.println(for(q in [x, y] where q &lt; 3) q); // prints 2
System.out.println(Math.max(x, y)); // prints 4
System.out.println("abc".toUpperCase()); // prints ABC
<!-- System.out.println(x instanceof Number); // prints true x = 10; -->
System.out.println(x); // prints 10
</programlisting>

<para style="padding-top:8pt">&nbsp;</para>

    <sect2 id="bind"><title>The <code>bind</code> Operator </title>

    

    <para>JavaFX script supports dependency-based evaluation of expressions
    with the bind keyword.</para>

    

    <para><emphasis role="bold">TO-DO: This section may move to its own
    chapter (JFXC-448.) Is bind an operator or just a
    keyword?</emphasis></para>

    
    <para>Example:</para>

    
    <programlisting>var x = 100;
var y = bind x + 100;
x = 50;
y == 150; // true
</programlisting>

    <para>Whenever the inputs to a bound expression are updated, the result is
    recalculated and automatically updated. In the above example whenever
    <code>x</code> is updated, <code>y</code> is correspondingly updated
    according to the expression given.</para>

    <para>Binding is one of JavaFX script's main distinguishing features that
    makes it possible to express complex dynamic data relationships.</para>

    <para>Any expression of any complexity may be bound - including
    conditionals, loops, blocks, function calls, and even calls to methods and
    constructors written in the Java programming language.</para>

    <para>Example:</para>

    <programlisting>import java.lang.Math;

var a = 0;
var x = bind Math.cos(Math.toRadians(a));
println(x); // prints 1.0
a = 180;
println(x); // prints -1.0;
</programlisting>

    <para></para>
    
    </sect2>

    <sect2 id="for"><title>Querying Sequences with the<code> for</code> Operator</title>


    <para>JavaFX script supports sequence comprehensions with a familiar
    syntax that should be easily understood by those familiar with the Java
    programming language, namely the <code>for</code> operator.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <programlisting>class Album {
     attribute title: String;
     attribute artist: String;
     attribute tracks: String[];
}

var albums =
     [Album {
          title: "A Hard Day's Night"
          artist: "The Beatles"
          tracks:
               ["A Hard Day's Night",
                "I Should Have Known Better",
                "If I Fell",
                "I'm Happy Just To Dance With You",
                "And I Love Her",
                "Tell Me Why",
                "Can't Buy Me Love",
                "Any Time At All",
                "I'll Cry Instead",
                "Things We Said Today",
                "When I Get Home",
                "You Can't Do That"]
     },
     Album {
          title: "Circle Of Love"
          artist: "Steve Miller Band"
          tracks:
               ["Heart Like A Wheel",
                "Get On Home",
                "Baby Wanna Dance",
                "Circle Of Love",
                "Macho City"]
     }];


for (album in albums) {
     for(track in album.tracks) {
          if(album.title == track) {
               java.lang.System.out.println("TITLE TRACK = {track}");
          } else {
               java.lang.System.out.println("Track = {track}");
          }
     }
}


Output:

TITLE TRACK = A Hard Day's Night
Track = I Should Have Known Better
Track = If I Fell
Track = I'm Happy Just To Dance With You
Track = And I Love Her
Track = Tell Me Why
Track = Can't Buy Me Love
Track = Any Time At All
Track = I'll Cry Instead
Track = Things We Said Today
Track = When I Get Home
Track = You Can't Do That
Track = Heart Like A Wheel
Track = Get On Home
Track = Baby Wanna Dance
TITLE TRACK = Circle Of Love
Track = Macho City 
</programlisting>

    <para>A sequence comprehension consists of one or more input sequences, an
    optional filter, and an expression. Each input sequence is associated with
    a variable. The result of the sequence comprehension is a new sequence
    which is the result of applying the expression to the subset of the
    cartesian product of the source sequences' elements that satisfy the
    filter.</para>

    <para>Sequence comprehensions give a concise syntax for a rather general
    class of iterations over sequences.</para>

    <para><emphasis role="bold">Example:</emphasis></para>

    <programlisting>for (n in [1..100]) n * n</programlisting>

    <para>This is a sequence containing (in order) the squares of all the
    numbers from 1 to 100. Note that <emphasis>n</emphasis> is a local variable of the above
    expression.</para>

    <para>The use of a filter is shown by the following definition of a
    function which takes a number and returns a list of all its
    factors:</para>

    <para><emphasis></emphasis><programlisting>function factors(n:Number) {
     return for (i in [1 .. n/2] where n % i == 0) i;
}
</programlisting></para>

</sect2>

    <sect2 id="insert"><title>Modifying Sequences with the <code>insert</code> and
    <code>delete</code> Operators</title>

    <para>In addition to the assignment operator <code>=</code>, JavaFX script
    provides data modification operators, <code>insert</code> and
    <code>delete</code>.</para>

    
</sect2>
    
    
<sect2 id="insop"><title>The <code>insert</code> Operator</title>

    <para>The <code>insert</code> operator can take any of the following
    forms:</para>

    <programlisting>insert Expression1 [as first | as last] into Expression2
insert Expression1 before Expression2
insert Expression1 after Expression2
</programlisting>

    <para>The <code>insert</code> operator inserts the items returned by
    evaluating Expression1 into the location indicated by remainder of the
    statement as follows:</para>
    
    </sect2>
    
    
<sect2 id="into">
        <title>The <code>into</code> Operator</title>

    <para><emphasis>Expression2</emphasis> must refer to an attribute or variable. If <emphasis>Expression2</emphasis>
    refers to a single valued attribute then the effect of the insert is the
    same as if the assignment operator were used.</para>

    <para>If <code>as first</code> is specified, the insertion location is
    before the first element of the list indicated by <emphasis>Expression2.</emphasis> If <code>as
    last</code> is specified, the insertion location is after the last element
    of the list indicated by <emphasis>Expression2.</emphasis> If neither <code>as first</code> nor
    <code>as last</code> is specified explicitly, then <code>as last</code> is
    used as the default.</para>

    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var x = [1,2,3];
insert 12 into x; // yields [1,2,3,12]
insert 10 as first into x; // yields [10,1,2,3,12]
insert [99,100] as last into x; // yields [10,1,2,3,12,99,100]
</programlisting>

</sect2>

<sect2 id="before">
        <title>The <code>before</code> and <code>after</code> Operators</title>

    <para><emphasis>Expression2</emphasis> must be a selection expression over an
    attribute or variable. If <code>before</code> is specified, the insertion
    location is before the selected elements. If <code>after</code> is
    specified the insertion location is after the selected elements.</para>

    
    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var xs = [1,2,3];
insert 10 after xs[x | x == 10]; // yields [1,2,3,10]
insert 12 before xs[1]; // yields [1,12,2,3,10]
insert 13 after xs[x | x == 2]; // yields [1, 12, 2, 13, 3, 10];
</programlisting>

</sect2>

 <sect2 id="del">
        <title>The <code>delete</code> Operator</title>

    <para>The <code>delete</code> operator takes one of the following
    forms:</para>

    <programlisting>delete variable
delete Expression.attribute
delete variable[predicate]
delete Expression.attribute[predicate]
</programlisting>

    <para>The first two forms remove all elements from a variable or attribute
    - which is equivalent to assigning <code>[]</code> or <code>null</code> to
    the variable or attribute. The latter two forms remove only those elements
    that match the predicate.</para>

    <para><emphasis role="bold">Examples:</emphasis></para>

    <programlisting>var xs = [1,2,3];
insert 10 into xs; // yields [1,2,3,10]
insert 12 before xs[1]; // yields [1,12,2,3,10]
delete xs[x | x == 12]; // yields [1,2,3,10]
delete xs[x | x &gt;= 3]; // yields [1,2]
insert 5 after xs[ x | x == 1]; // yields [1,5,2];
insert 13 as first into xs; // yields [13, 1, 5, 2];
delete xs; // yields []
</programlisting>

  </sect2>

</sect1>


  <sect1 id="expressions">
    <title>Expressions</title>

    <para>Unlike the Java programming language, JavaFX script is an expression
    language. All executable statements are expressions which consist of zero
    or more inputs and a single output. This includes conditionals, loops, and
    even blocks.</para>

    <para>
      <emphasis role="bold">Example:</emphasis>
    </para>

    <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String = null;
if (rand % 2 == 0) {
     s = "rand is even";
} else {
     s = "rand is odd";
}
System.out.println(s);
</programlisting>

    <para>In the above example the then and else clauses of the conditional
    "if" are expressions in their own right, namely block expressions
    <emphasis role="bold">[to-do, link to block expressions section
    below]</emphasis></para>

    <sect2 id="logical">
      <title>Logical Expressions</title>

      <para>This section lists and defines the logical expressions available
      in JavaFX™ Script.</para> 
      

<sect3 id="if">
<title><code>if</code> Expression</title>

        <para>The <code>if</code> expression is like the expression in the
        Java™ programming language, except that curly braces are always
        required around the <code>then</code> and <code>else</code> clauses,
        unless the the <code>else</code> clause is another <code>if</code>
        expression.</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       if (condition1) {
           System.out.println("Condition 1");
       } else if (condition2) {
           System.out.println("Condition2");
       } else {
           System.out.println("not Condition 1 or Condition 2");
       }
</programlisting>

</sect3>

      <sect3 id="while">
        <title><code>While</code> Statement</title>

        <para>The JavaFX Script <code>while</code> statement is like the
        statement in the Java Programming language, except that curly braces
        are always required around the body.</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       var i = 0;
       while (i &lt; 10) {
           if (i &gt; 5) {
              break;
           }
           System.out.println("i = {i}");
           i += 1;
       }
</programlisting>
</sect3>

<sect3 id="try">
   <title><code>try</code> Statement</title>

        <para>The JavaFX Script <code>try</code> statement is like the
        statement in the Java Programming language, but with JavaFX Script
        variable declaration syntax.</para>

        <note>In JavaFX Script any object can be thrown and caught, not just
        those that extend <code>java.lang.Throwable</code>.</note>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       try {
          throw "Hello";
       } catch (s:String) {
          System.out.println("caught a String: {s}");
       } catch (any) {
          System.out.println("caught something not a String: {any}");
       } finally {
          System.out.println("finally...");
       }
   </programlisting>
</sect3>

<sect3 id="for">
     <title><code>for</code> Statement</title>

        <para>
          <emphasis role="bold">QUESTION: We need a new intro to go with the
          'for' statement.</emphasis>
        </para>

        <para>The header of the JavaFX Script <code>for</code> statement uses
        the same syntax as the <code>for</code> list comprehension
        operator.<!-- This needs to be linked to the list comprehension discussion in the Arrays chapter -->
        However; in this case the body of the statement is executed for each
        element generated by the list comprehension.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

        <programlisting>        for (i in [0..10]) {
             System.out.println("i = {i}");
        }

        // print only the even numbers using a filter
        for (i in [0..10] where i % 2 == 0) {
             System.out.println("i = {i}");
        }

        // print only the odd numbers using a range expression
        for (i in [1..10 step 2]) {
             System.out.println("i = {i}");
        }

        // print the cartesian product
        for (i in [0..10], j in [0..10]) {
             System.out.println(i);
             System.out.println(j);
        }

</programlisting>
</sect3>

<sect3 id="return">
   <title><code>return</code> Statement</title>

        <para>The JavaFX Script <code>return</code> statement is like the
        statement in the Java Programming language:</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>       operation add(x, y) {
           return x + y;
       }
</programlisting>
</sect3>

<sect3 id="throw">
    <title><code>throw</code> Statement</title>

        <para>The JavaFX Script <code>throw</code> statement is like the
        statement in the Java Programming language. However; any object can be
        thrown, not just those that extend
        <code>java.lang.Throwable</code>.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

<programlisting>       import java.lang.Exception;

       operation foo() {
           throw new Exception("this is a java exception");
       }

       operation bar() {
           throw "just a string";
       }
</programlisting>
      </sect3>

      <sect3 id="break">
        <title><code>break</code> and <code>continue</code> Statements</title>

        <para>The JavaFX Script <code>break</code> and <code>continue</code>
        statements are like the statement in the Java Programming language;
        however labels are not supported. As in Java, <code>break</code> and
        <code>continue</code> must appear inside the body of a
        <code>while</code> or <code>for</code> statement.</para>

        <para>
          <emphasis role="bold">Examples:</emphasis>
        </para>

        <programlisting>       operation foo() {
          for (i in [0..10]) {
              if (i &gt; 5) {
                  break;
              }
              if (i % 2 == 0) {
                  continue;
              }
              System.out.println(i);
          }
       }

 ! operation bar() {
             var i = 0;
             while (i &lt; 10) {
                 if (i &gt; 5) {
                     break;
                 }
                 if (i % 2 == 0) {
                     continue;
                 }
                 System.out.println(i);
- i += 1;
             }
         }
</programlisting>
</sect3>

<!--  ********* comment out the do and the do later 
      ********* sections for now 
            
          <sect2 id="do">
            <title><code>do</code> Statement</title>

            <para>The JavaFX Script <code>do</code> statement allows you to execute a
            block of JavaFX Script code in a background thread while allowing the AWT
            Event Dispatch Thread to continue processing events. This prevents the UI from appearing to hang. </para>
	    
	    <para> Currently, this is
            implemented by using <code>java.awt.EventQueue</code> to handle
            events while the background thread is executing. Normally, all
            JavaFX Script code executes in the AWT Event Dispatch Thread. Only code
            contained in the body of a <code>do</code> statement is allowed to
            execute in another thread. <CODE>do</CODE> statement code must only access Java language objects
            (and those objects must handle their own thread synchronization,
            if necessary).</para>

            <para><emphasis role="bold">Example:</emphasis></para>

            <programlisting>        import java.net.URL;
        import java.lang.StringBuffer;
        import java.lang.System;
        import java.io.InputStreamReader;
        import java.io.BufferedReader;



        // in the AWT EDT
        var result = new StringBuffer();

        do {
             // now in a background thread
             var url = new URL("http://www.foo.com/abc.xml");
             var is = url.openStream();
             var reader = new BufferedReader(new InputStreamReader(is));
             var line;
             while (true) {
                  line = reader.readLine();
                  if (line == null) {
                       break;
                  }
                  result.append(line);
                  result.append("\n");
             }
        } 

        // now back in the EDT
        System.out.println("result = {result}"); 
</programlisting>

 <para>In the above example, the code which is executing in
 the EDT appears to be blocked during the execution of the body of
the <code>do</code> statement. However, the system creates a new event
dispatch loop on the stack while waiting for the background thread to complete. As a result, GUI events continue to be processed while the <code>do</code> statement executes.</para>
	    
<note>This isn't a perfect solution. It can cause many event dispatch loops to be placed on the stack, and this can cause a stack overflow exception.</note>
	    
	    
</sect2>

<sect2 id="dolater">
  <title><code>do later</code> Statement</title>

<para>The <code>do</code> statement has a second form (<code>do
later</code>) that allows for asynchronous execution of its body
in the EDT rather than synchronous execution in a background
thread. This mimics the functionality of
 <code>java.awt.EventQueue.invokeLater</code>) </para>
	    
<para><emphasis role="bold">Example:</emphasis></para>

 <programlisting>        import java.lang.System;
        var saying1 = "Hello World!";
        var saying2 = "Goodbye Cruel World!";
        do later {
             System.out.println(saying1);
        }
        System.out.println(saying2);
</programlisting>

            <para>Running this code produces the following output:</para>

            <programlisting>        Goodbye Cruel World!
        Hello World!
</programlisting>
          </sect2>

-->

      <sect3 id="block">
        <title>Block Expressions</title>

        <para>A block expression consists of a list of statements (which can
        be declarations or expressions) surrounded by curly braces and
        separated by semicolons. If the last statement is an expression, then
        the value of a block expression is the value of the last expression;
        otherwise the block expression has <code>void</code> type.
</para>

        <para>So, the above example from the top of this section could also be
        written as follows:</para>

        <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String =
if (rand % 2 == 0) {
     "rand is even";
} else {
     "rand is odd";
};
System.out.println(s);
</programlisting>

        <para>Alternately the braces can be omitted:</para>

        <programlisting>import java.lang.Math;

var rand = (Math.random() * 100).intValue();
var s:String = if (rand % 2 == 0) "rand is even" else "rand is odd";
System.out.println(s);
</programlisting>

        <para>The Java programming language contains both an <code>if</code> statement,
        and a conditional expression: <code>a &lt; b ? a :
        b</code>.</para>

        <para>Thanks to block expressions, the JavaFX <code><emphasis>if</emphasis></code> expression takes
        the place of both.</para>
	
	
 </sect3>

      <sect3 id="range">
        <title>Range Expressions</title>

        <para>As mentioned in chapter two <emphasis role="bold">[TO-DO:
        confirm that location and provide link]</emphasis> it is possible to
        define a sequence of numeric values forming an arithmetic series using
        the following syntax:</para>

        <programlisting>[number1..number2]
</programlisting>

        <para>Such an expression defines an sequence whose elements consist of
        the integers from <emphasis>number1</emphasis> to
        <emphasis>number2</emphasis> (inclusive).</para>

        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>

        <programlisting>var nums = [0..3];
System.out.println(nums == [0,1,2,3]); // prints true
</programlisting>

        <para>By default the interval between the values is 1 but it's also possible to specify a different interval by including the next number in the sequence after number1 separated by a comma. For example, the following expression defines an sequence consisting of the odd numbers between 1 and 10:</para>

        <programlisting>[1,3..10]</programlisting>

        <para>... and syntax for descending sequences
"If <emphasis>number1</emphasis> is greater than <emphasis>number2</emphasis> a descending series is created:</para>

        <programlisting>var nums = [3..0 step -1];
System.out.println(nums == [3,2,1,0]); // prints true
</programlisting>

<para>Note that these declarations:</para>
<programlisting>var nums1 = [3..0 ]; 
var nums2 = [3..0 step 1]; </programlisting>

<para>actually declare empty sequences.</para>

</sect3></sect2></sect1></chapter>



