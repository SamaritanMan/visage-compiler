<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="triggers"><title>Triggers</title>


<sect2 id="replace"><title>Replace Triggers</title>

<para>
The syntax for a <emphasis>replace trigger</emphasis> is as follows:</para>

<programlisting>
 "on" "replace"
    [oldValue]
    [ "[" lowIndex ".." highIndex "]" "=" newElements ]
    block
</programlisting>


<para>
A replace trigger is invoked after every modification of the variable to which it is attached. The syntactic nonterminals <code>oldValue</code>, 
<code>lowIndex</code>, <code>highIndex</code>, and <code>newElements</code>  
are effectively formal parameters to a function with a body that consists of the block:</para>

<itemizedlist>
   <listitem> <code>oldValue</code> is the previous value of the variable, and has the same type as the variable.</listitem>

   <listitem> <code>lowIndex</code> and <code>highIndex</code> delimit the portion of <code>oldValue</code> that has been replaced. Their types are <code>Integer</code>. For a pure insertion, <code>highIndex==lowIndex-1</code>.</listitem>

    <listitem> <code>newElements</code> is the sequence of values that replaces the slice <code>oldValue[lowIndex..highIndex]</code>. Its type is the same as the variable.</listitem>
</itemizedlist>

<para>The <code>[lowIndex..highIndex]=newElements</code>  parameters are allowed only if the attached variable has sequence type.</para>

<para>
Notice the asymmetry between <code>oldValue</code> and <code>newElements</code>. <code>oldValue</code> is the previous value of the attached variable, while <code>newElements</code> is a slice of the new value of the variable, containing only the modified elements.
</para>


<para>
The syntax of the replace trigger is meant to be evocative of a slice assignment. For example:</para>

<programlisting>
var x
    on replace oldVal[lo..hi]=newVals { exp };
  var save = x;
  x[i..j] = y;
</programlisting>


<para>
Then <code>exp</code> is evaluated, with <code>oldVal</code> bound to <code>save</code>,  <code>lo</code> bound to <code>i</code>, <code>hi</code> bound to <code>j</code>,  and <code>newVals</code> bound to <code>y</code>.</para>


<para>
Unified replace triggers work well with slice assignments. For example, you can define a bind, as in the following:</para>

<programlisting>
var x;
var y = bind x;
</programlisting>


<para>

as equivalent to:</para>

<programlisting>
var x =
   on replace [i..j]=n
   { y[i..j]=n };
var y = [];
</programlisting>

<para>If y is a <emphasis>map</emphasis> of x:</para>

<programlisting>
var x;
var y = bind for (xi in x) f(xi);
</programlisting>

<para>
that is equivalent to the following:</para>

<programlisting>
var x =
  on replace [i..j]=n
  { y[i..j] = for (k in n) f(k) };
var y = [];
</programlisting>

<para>Deleting or replacing a range of elements in a sequence, or inserting a sequence into a single location all result in a single trigger invocation. Some other operations, such as deleting all elements that satisfy a predicate, might be decomposed to multiple trigger call. In that case the state that is seen by each trigger invocation is consistent. Specifically, the programmer-visible state is <emphasis>as if</emphasis> the predicate-delete (for example) were implemented as a set of independent slice-delete operations.</para>

</sect2>

</chapter>



