<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<?xml-stylesheet href="docbook.css" type="text/css"?>
<chapter id="Arrays">
<title>Arrays</title>


<sect1 id="arrays"><title>Arrays Overview</title>

<para>
<emphasis>
This Chapter will describe JavaFX arrays. 
</emphasis>

</para>
</sect1>


<sect1 id="array1"><title>Arrays Introduction</title>

      <para>Arrays represent sequences of objects. In JavaFX arrays are not
      themselves objects, however, and do not nest. Expressions that produce
      nested arrays (as in the initialization of "days" above) are
      automaticallly flattened, i.e:</para>

      <programlisting>days == ["Mon","Tue","Wed","Thur","Fri","Sat","Sun"]; // returns true
</programlisting>

      <para>The size of an array may be determined with the JavaFX
      <code>sizeof</code> operator:</para>

      <programlisting>         var n = sizeof days; // n = 7
</programlisting>

      <para>There is a shorthand notation using "<code>..</code>" for arrays
      whose elements form an arithmetic series. Here for example are
      definitions of the factorial function, and of a number "result" which is
      the sum of the odd numbers between 1 and 100</para>

      <programlisting>function fac(n) {return product([1..n]);}
        var result = sum([1,3..100]);
</programlisting>

      <para>The elements of an array must all be of the same type.</para>

      <para>Arrays may be indexed as in Java:</para>

      <programlisting>        var wednesday = days[2];
</programlisting>

      <para>In JavaFX the <code>[]</code> operator also expresses selection
      (similar to its use in XPath). In this case, the expression contained in
      the <code>[]</code> is a boolean expression. Such an expression returns
      a new array containing only those elements that satisfy the predicate
      contained in the <code>[]</code>.</para>

      <para>As in XPath, within the predicate contained inside the
      <code>[]</code> operator, the context object may be accessed with the
      dot operator, for example:</para>

      <programlisting>	var nums = [1,2,3,4];
	var numsGreaterThanTwo = nums[. &gt; 2]; // yields [3, 4]
</programlisting>

      <para>Alternatively a variable may be declared for the context object.
      For example, this is equivalent to the above statement:</para>

      <programlisting>	numsGreaterThanTwo = nums[n|n &gt; 2];
</programlisting>

      <para>The JavaFX <code>indexof</code> operator returns the ordinal
      position of an element within an array (like the <code>position()</code>
      function in XPath).</para>

      <para>The <code>car</code> and <code>cdr</code> of a list may be
      expressed using selection expressions like this:</para>

      <programlisting>	function car(list) {return list[indexof . == 0];}
	function cdr(list) {return list[indexof . &gt; 0];}
</programlisting>

      <para>Of course <code>car</code> can be expressed more succinctly as
      simply:</para>

      <programlisting>	function car(list) {return list[0];}
</programlisting>

      <para>Examples:</para>

      <programlisting>	var list = [1..10];
	car(list); // yields 1
	cdr(list); // yields [2,3,4,5,6,7,8,9,10]
</programlisting>

      <para>In JavaFX, the empty array <code>[]</code> and <code>null</code>
      are synonymous, i.e:</para>

      <programlisting>        [] == null // yields true
        sizeof null // yields 0
</programlisting>
    </sect1>

    <sect1 id="arraymod">
      <title>Modifying Arrays</title>

      <para>In addition to the assignment operator (<code>=</code>), JavaFX
      provides data modification operators (<code>insert</code> and
      <code>delete</code>) similar in syntax and semantics to those in the
      draft XQuery-Update specification as follows:</para>

      <sect2 id="insert">
        <title>Insert Statement</title>

        <para>The insert statement can take any of the following forms:</para>

        <programlisting>        insert Expression1 [as first | as last] into Expression2
        insert Expression1 before Expression2
        insert Expression1 after Expression2
</programlisting>

        <para>The <code>insert</code> statement inserts the items returned by
        evaluating Expression1 into the location indicated by remainder of the
        statement as follows:</para>

        <programlisting>into</programlisting>

        <para>Expression2 must refer to an attribute or variable. If
        Expression2 refers to a single valued attribute then the effect of the
        insert is the same as if the assignment operator were used.</para>

        <para>If <code>as first</code> is specified, the insertion location is
        before the first element of the list indicated by Expression2. If
        <code>as last</code> is specified, the insertion location is after the
        last element of the list indicated by Expression2. If neither <code>as
        first</code> nor <code>as last</code> is specified explicitly, then
        <code>as last</code> is used as the default.</para>

        <para>Examples:</para>

        <programlisting>        var x = [1,2,3];
        insert 12 into x; // yields [1,2,3,12]
        insert 10 as first into x; // yields [10,1,2,3,12]
        insert [99,100] as last into x; // yields [10,1,2,3,12,99,100]
</programlisting>

        <para>before, after</para>

        <para>Expression2 must be a selection expression over an attribute or
        variable. If <code>before</code> is specified, the insertion location
        is before the selected elements. If <code>after</code> is specified
        the insertion location is after the selected elements.</para>

        <para>Examples:</para>

        <programlisting>
        var x = [1,2,3];
        insert 10 after x[. == 10]; // yields [1,2,3,10]
        insert 12 before x[1]; // yields [1,12,2,3,10]
        insert 13 after x[. == 2]; // yields [1, 12, 2, 13, 3, 10];
</programlisting>

        <sect2 id="delete">
          <title>Delete Statement</title>

          <para>The Delete statement takes one of the following forms:</para>

          <programlisting>
        delete variable
        delete Expression.attribute
        delete variable[predicate]
        delete Expression.attribute[predicate]
</programlisting>

          <para>The first two forms remove all elements from a variable or
          attribute - which is equivalent to assigning <code>[]</code> or
          <code>null</code> to the variable or attribute. The latter two forms
          remove only those elements that match the predicate.</para>

          <para>Examples:</para>

          <programlisting>
        var x = [1,2,3];
        insert 10 into x; // yields [1,2,3,10]
        insert 12 before x[1]; // yields [1,12,2,3,10]
        delete x[. == 12]; // yields [1,2,3,10]
        delete x[. &gt;= 3]; // yields [1,2]
        insert 5 after x[. == 1]; // yields [1,5,2];
        insert 13 as first into x; // yields [13, 1, 5, 2];
        delete x; // yields []
</programlisting>
        </sect2>

        <sect1 id="query">
          <title>Querying Arrays</title>

          <para>JavaFX supports list comprehensions as in functional languages
          like Miranda and Haskell, but with a familiar syntax that should be
          easily understood by Java programmers, namely the JavaFX
          <code>select</code> and <code>foreach</code> operators.</para>

          <para>Here is an example:</para>

          <programlisting>
        class Album {
            attribute title: String;
            attribute artist: String;
            attribute tracks: String*;
        }

        var albums =
        [Album {
             title: "A Hard Day's Night"
             artist: "The Beatles"
             tracks:
             ["A Hard Day's Night",
              "I Should Have Known Better",
              "If I Fell",
              "I'm Happy Just To Dance With You",
              "And I Love Her",
              "Tell Me Why",
              "Can't Buy Me Love",
              "Any Time At All",
              "I'll Cry Instead",
              "Things We Said Today",
              "When I Get Home",
              "You Can't Do That"]
        },
        Album {
              title: "Circle Of Love"
              artist: "Steve Miller Band"
              tracks:
              ["Heart Like A Wheel",
                "Get On Home",
                "Baby Wanna Dance",
                "Circle Of Love",
                "Macho City"]
        }];

        // Get the track numbers of the albums' title tracks

        // using the select operator:

        var titleTracks =
            select indexof track + 1 from album in albums,
                      track in album.tracks
                          where track == album.title; // yields [1,4]

       // the same expressed using the foreach operator:

        titleTracks =
            foreach (album in albums,
                      track in album.tracks
                          where track == album.title)
                indexof track + 1;  // also yields [1,4]

</programlisting>

          <para>A list comprehension consists of one or more input lists, an
          optional filter and a generator expression. Each source list is
          associated with a variable. The result of the list comprehension is
          a new list which is the result of applying the generator to the
          subset of the cartesian product of the source lists' elements that
          satisfy the filter.</para>

          <para>List comprehensions give a concise syntax for a rather general
          class of iterations over lists.</para>

          <para>Another simple example of a list comprehension is:</para>

          <programlisting>        select n*n from n in [1..100]
</programlisting>

          <para>This is a list containing (in order) the squares of all the
          numbers from 1 to 100. Note that "n" is a local variable of the
          above expression.</para>

          <para>The use of a filter is shown by the following definition of a
          function which takes a number and returns a list of all its
          factors,</para>

          <programlisting>        function factors(n) {
            return select i from i in [1..n/2] where n % i == 0;
        }
</programlisting>
        </sect1>

       

</sect2></sect1></chapter>







