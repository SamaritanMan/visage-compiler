<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Objects and Classes</title>

  <sect1 id="Objects">
    <title>Objects</title>

 <!--   <para><emphasis role="bold">[DRAFT NOTES: The purpose of this draft is to
    ensure that the technical content is correct, complete (if not,
    engineering must identify what is missing), and is presented in an order
    that makes sense within the context of the book. It also fixes trademark
    violations that were present in the original text. We've decided that
    Classes and Objects will be the subject of this chapter. Once the
    technical content has been established and signed off on by engineering,
    we will focus on the narrative text to help this read more like a book
    than it does now. The next draft will include some discussion of state and
    behavior here before the reference material begins. We will take care to
    make the tone suit the intended audience.]</emphasis></para>
 -->



    <para>The previous chapter presented a basic example of how to use
    objects; this section describes them in more detail. Because objects and
    classes (and their attributes and functions) are so closely related, there
    is a slight amount of cross referencing in the code samples contained in
    this chapter.</para>



    <!--
    
    <para><emphasis role="bold">[TO-DO: Insert a short definition of the term
    "object" here. Most readers will already know what that is, but we should
    provide a short definition nonetheless. We don't want the tone to sound
    too much like a tutorial, so this definition should be kept to a few
    sentences. After that, we can proceed as below, which shows how to create
    an object. We will add this narrative in the next
    draft.]</emphasis></para>
    
  -->
    

    <para>Objects may be allocated using a declarative syntax consisting of
    the name of the class followed by a curly brace delimited list of
    attribute initializers. Each initializer consists of the attribute name
    followed by a colon, followed by an expression which defines its value
    (see <link linkend="???">Incremental and Lazy Evaluation</link> for JavaFX&trade;
    Script support of incremental evaluation in this context). 
    
    <!-- <emphasis
    role="bold">[NOTE: Original engineering text had a note/link here about
    incremental and lazy evaluation. That's a more advanced topic that can
    just be presented later. We don't need a forward link to it here.]
    </emphasis></para>
    
    -->

    

    <para>Here is a simple example:</para>

    

    <programlisting>Person { 
     name: "Chris"
}
</programlisting>

    

    <para>Multi-valued attributes are known as <emphasis><ulink
    url="???">sequences</ulink></emphasis>. A sequence is an ordered list of
    objects; they appear within square brackets:</para>

    

    <programlisting>Person {
     name: "Chris"
     children:
     [Person {
          name: "Dee"
     },
     Person {
          name: "Candice"
     }]
}</programlisting>

    

    <para>To store this newly created Person object in a variable, use the
    <code><link linkend="???">var</link></code> keyword:</para>

    

    <programlisting>var chris = Person {
     name: "Chris"
     children:
     [Person {
          name: "Dee"
     },
     Person {
          name: "Candice"
     }]
};
</programlisting>


    <para>JavaFX&trade; Script also supports Java&trade; programming language object allocation syntax. In such cases, it is possible to pass arguments to the
    constructor of a class:</para>

    

    <para><programlisting>import java.util.Date;
import java.lang.System;

var date1 = new Date(95, 4, 23); // invoke a constructor
var date2 = Date { // create the same date as an object literal
     month: 4
     date: 23
     year: 95
};
System.out.println(date1 == date2);  // prints true
</programlisting></para>

   

    <para>In fact, code written in the JavaFX Script programming language can interact with the Java
    programming language in a number of ways: it can import classes, create
    new objects, invoke methods, and implement interfaces. The following code
    snippet provides an example:</para>

    

    <para><programlisting>import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.ActionListener;
import java.lang.System;

var frame = new JFrame();
var button = new JButton("Press me");
frame.getContentPane().add(button);
button.addActionListener(new ActionListener() {
        operation actionPerformed(event) {
            System.out.println("You pressed me");
        }
     });
frame.pack();
frame.setVisible(true);
</programlisting></para>

    
    <para>This code displays the following on screen:</para>



    <screenshot>
      <mediaobject>
        <imageobject>
          <imagedata fileref="frame.png" />
        </imageobject>
      </mediaobject>
    </screenshot>

    

    <para>This, however, is not the preferred way to create GUIs in the JavaFX 
    Script programming language. The following code uses object literals to produce the same
    result:</para>

  

    <programlisting>Frame {
     content: Button {
          text: "Press Me"
          action: operation() {
          System.out.println("You pressed me");
          }
     }
     visible: true
}
</programlisting>

</para>
    
    
    </sect1>
 

  <sect1 id="classes">
    <title>Defining and Extending Classes</title>



    <para><emphasis role="bold">[TO-DO: Add narrative describing classes (and
    inheritance). This narrative will most likely include some comparison to
    the Java programming language (i.e. why does JavaFX Script support
    multiple inheritance, when the Java programming language intentionally
    does not?) Do we need a demo program to illustrate this before jumping
    into the syntax descriptions? In general, what does engineering want to
    say before we jump into the details?]</emphasis></para>



    <para>The syntax for specifying a class is the <code>class</code> keyword
    followed by the class name, optionally the <code>extends</code> keyword,
    and a comma separated list of the names of base classes, an open curly
    brace, a list of attributes and functions that each end in a
    semicolon, and a closing curly brace. Similar to the Java programming
    language, classes and their members may be declared <code>public</code>,
    <code>protected</code>, or <code>private</code>, in which case they may be
    accessed anywhere, in the current package or in derived classes, or only
    in the current class, respectively.</para>



    <para><emphasis role="bold">[QUESTION: Do we want to have a separate
    section that explains the rules of the access modifiers? We should
    probably have definitions of public, private, protected etc. otherwise the
    reader will have to look these up elsewhere]</emphasis></para>

<para><emphasis role="bold">Example:</emphasis></para>

    <programlisting>public class Person extends Object {
     public attribute name: String;
     public attribute parent: Person; 
     public attribute children: Person[];
     public function getFamilyIncome(): Number { return ...; };
     public function getNumberOfChildren(): Number { return sizeof children; }
     public function marry(spouse: Person): Void { ...; }
}
</programlisting>

   </sect1>

  <sect1 id="attrfuntrig">
    <title>Attributes, Functions, and Triggers</title>

    <sect2 id="attributes"><title>Attributes</title>
    
    
    <para>Attributes define the state of an object. They are declared using
    the <code>attribute</code> keyword followed by the attribute's name, a
    colon, the attribute's type, optionally a cardinality specification
    (<code>?</code> meaning optional, <code>*</code> meaning zero or more, or
    <code>+</code> meaning one or more), <code></code>terminated with a
    semicolon.</para>


    <para><programlisting>attribute <emphasis>AttributeName</emphasis> : <emphasis>AttributeType</emphasis> <emphasis>Cardinality</emphasis> ;</programlisting></para>


<!--
    <para><emphasis role="bold">[QUESTION: Is the above correct? I modified it
    based on the response to the last draft]</emphasis></para>

-->

    <para>Multi-valued attributes (those declared with the <code>*</code>
    or <code>+</code> cardinality specifiers) are represented as arrays. You
    can access them using the <code>[]</code> operator and update them using
    <code>insert</code> and <code>delete</code>.</para>

    

    <para>It is possible to declare default values for attributes (which can
    later be overridden by values provided in object literals.) The
    initializers are evaluated in the order the attributes are specified in
    the class declaration in the context of the newly created object:</para>

    

    <programlisting>import java.lang.System;

class X {
     attribute a: Number = 10;
     attribute b: Number = -1;
}
var x = X { };
System.out.println(x.a); // prints 10
System.out.println(x.b); // prints -1
</programlisting>

    

    <para>It is also possible to declare an incrementally evaluated expression
    as the value of an attribute using the <code>bind</code> operator:</para>

 

    <programlisting>import java.lang.System;

class X {
     attribute a: Number = 10;
     attribute b: Number = bind a + 10;
     attribute c: Number = bind lazy b + 10;
}

var x = X { };
System.out.println(x.a); // prints 10
System.out.println(x.b); // prints 20
System.out.println(x.c); // prints 30
x.a = 5;
System.out.println(x.a); // prints 5
System.out.println(x.b); // prints 15
System.out.println(x.c); // prints 25      
</programlisting>

 
</sect2>

<sect2 id="functions"><title>Functions</title>
 

    <para>Expressions may be <emphasis>factored</emphasis> into subroutines
    called <emphasis>functions</emphasis>:
    
    <para><emphasis role="bold">Example:</emphasis></para>

 

    <para><programlisting>function z(a:Number, b:Number):Number {
     var x = a + b;
     var y = a - b;
     return sq(x) / sq (y);
}

function sq(n:Number): Number {n * n;}

function main():Number {
     return z(5, 10);
}
</programlisting></para>



    <para>A function takes the form:</para>



    <programlisting>function <emphasis>name</emphasis> (<emphasis>parameterName</emphasis> : <emphasis>parameterType</emphasis>, ...): <emphasis>returnType</emphasis><emphasis> body
</emphasis></programlisting>

   

    <para>where <emphasis>body</emphasis> can be any expression.</para>

    

    <para>Functions are first-class objects (they can, for example, be
    assigned to variables, or passed as parameters to other functions.)</para>

  

    <para>Functions can be anonymous:</para>

    

    <programlisting>var add = function(a:Number, b:Number):Number { a + b; }
var result = add(1, 2);    
</programlisting></para>

    </sect2>
    
<!-- *******************************************************

Original Triggers section  below

     *******************************************************    
    
    

    <para><emphasis role="bold">3.3 Triggers</emphasis></para>

    <para></para>

    <para>JavaFX Script <code>class</code>es don't have constructors, and
    JavaFX <code>attribute</code>s don't have "setters" like Java bean
    properties. Instead, JavaFX Script provides SQL-like triggers that allow
    you to handle data modification events. <emphasis role="bold">[TO-DO:
    Expand on the narrative of this section]</emphasis></para>

    <para></para>

    <para>A trigger consists of a header and a body. The header specifies the
    type of event the trigger applies to. The body of the trigger is a
    procedure that executes whenever the specified event occurs. Triggers
    defined in a class also behave like member functions, in that the context
    object is accessible inside the body via the <code>this</code>
    keyword.</para>

    <para></para>

    <para><emphasis role="bold">Creation Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action in the context of a newly created object
    by specifying an "init" trigger, like this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[];
     init {
          insert [3,4] into this.nums;
     }
}

var x = X { };
System.out.println(x.nums == [3,4]); // prints true
</programlisting>

    <para></para>

    <para>This example defines a trigger that will be executed whenever a new
    instance of the X class is created. In this case it just assigns an
    initial value to the nums attribute.</para>

    <para><emphasis role="bold"></emphasis></para>

    <para><emphasis role="bold">Insert Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action whenever an element is inserted into a
    multi-valued attribute by specifying an "insert" trigger, like
    this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on insert[i](num) {
          System.out.println("just inserted {num} into X.nums at position {i}");
     }
}

var x = X { };
insert 12 into x.nums; // prints just inserted 12 into X.nums at position 0
insert 13 into x.nums; // prints just inserted 13 into X.nums at position 1
</programlisting>

    <para></para>

    <para>In the above example, "num" is the name of a variable that will
    contain a reference to the element being inserted (you can name the
    variable whatever you like.) The context index of the variable (denoted by
    <emphasis>i</emphasis>) corresponds to the insertion point.</para>

    <para></para>

    <para><emphasis role="bold">Delete Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action whenever an element is deleted from a
    multi-valued attribute by specifying a delete trigger, like this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on delete[i](num) {
          System.out.println("just delete {num} from X.nums at position {i}");
     }
}

var x = X {
     nums: [12, 13]
};

delete x.nums[1]; // prints just deleted 13 from X.nums at position 1
delete x.nums[0]; // prints just deleted 12 from X.nums at position 0
</programlisting>

    <para></para>

    <para>In the above example, "num" is the name of a variable that will
    contain a reference to the element being deleted (you can name the
    variable whatever you like). The variable <emphasis>i</emphasis>
    corresponds to the deletion point.</para>

    <para></para>

    <para><emphasis role="bold">Replace Triggers</emphasis></para>

    <para></para>

    <para>You can perform an action whenever the value of a single-valued
    attribute or an element of a multi-valued attribute is replaced, like
    this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on replace[i](oldValue) {
          System.out.println("just replaced {oldValue} with {newValue} at position {i} in X.nums");
     }
     attribute num: Number on replace (oldValue) {
          System.out.println("X.num: just replaced {oldValue} with {num}");
     }
}

var x = X {
     nums: [12, 13]
     num: 100
};

x.nums[1] = 5; // prints just replaced 13 with 5 at position 1 in X.nums
x.num = 3; // prints X.num: just replaced 100 with 3
</programlisting>

    <para></para>

    <para>In the above examples, "oldValue" is the name of a variable that
    contains reference to the previous value of the element being replaced
    (you can name the variable whatever you like). The variable
    <emphasis>i</emphasis> between the square brackets (which you can also
    name whatever you like) corresponds to the insertion, deletion, or
    replacement index.</para>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Use of "you" sounds like a tutorial;
    re-visit this chapter text to clean that up.]</emphasis></para>

    <para><emphasis></emphasis></para>

    <para><emphasis role="bold">[QUESTION: Do we want this chapter to end with
    a Summary section, QandA, large demo program, or anything like that? Or
    should it just simply end?]</emphasis></para>

    <para><emphasis></emphasis></para>
  </section>
  
  *******************************************************
  
  end of older triggers section 
  
  ****** New Triggers Section from Per Below  *********** -->
  

  
  <sect2 id="triggers">
    <title>Slices and Triggers</title>
  
  <para>A <emphasis>slice</emphasis> is a sequence indexed by a range. The syntax for a slice is deliberately similar to that of a range-expression:</para>

<programlisting>
SliceExpr ::=
  SeqExpr "[" LowExpr ".." [HighExpr] "]" ;
;
</programlisting>

<para>In <code>seq[low..high] </code>the value of low can range from <code> 0..(sizeof seq), </code> while <code>high </code>can range from <code>low-1..size-1.</code>  An empty slice is indicated by <code>high==low-1.</code>  (This need to add/subtract one is slightly awkward and confusing; we will probably add a way to specify an "exclusive" upper bound.)</para>

<para>Note that slice ranges do not support step sizes
different from 1.</para>


<para>The expression:</para>

<programlisting>seq[low..high]</programlisting>

<para>is in value context equivalent to:</para>

 <programlisting>for (i in [low..high]) seq[i]</programlisting>

<para>In lvalue context:</para>

<programlisting>seq[low..high] = rhs</programlisting>

  <para>s of <code>seq </code>by <code>rhs.</code>  If <code>high==lo</code>
replaces the specified <code>elementw-1,</code>
insert <code>rhs at </code> (i.e. before) <code>low.</code></para>

<para>Slice assignment subsumes insertion, deletion, and replacement.
The keyword-based <emphasis>insert/delete</emphasis> statements are viewed as
syntactic sugar for slice assignment.</para>


<sect3 id="replace">
<title>Replace triggers</title>

<programlisting>
    "on" "replace"
    [oldValue]
    [ "[" lowIndex ".." highIndex "]" "=" newElements ]
    block
    
    </programlisting>

<para>A replace trigger is invoked after every modification of
the variable it is attached to.  The syntactic non-terminals
<code>oldValue, lowIndex, highIndex,</code> and <code>newElements </code> are effectively
formal parameters to a function whose body is the block:</para>

<itemizedlist>

<listitem><code>oldValue </code>is the previous value of the variable, and has the
same type as the variable.</listitem>


<listitem><code>lowIndex </code> and <code>highIndex </code>delimit the portion of <code>oldValue </code>that
has been replaced.  Their types are <code>Integer.</code>  For a pure insertion, <code>
highIndex==lowIndex-1.</code></listitem>

<listitem>
<code>newElements </code>is the sequence of values that replaces the slice
<code>oldValue[lowIndex..highIndex].</code>  Its type is the same as the variable.</listitem>
</itemizedlist>


<para>The <code>[lowIndex..highIndex]=newElements </code> parameters are only allowed if the attached variable has sequence type.<para>

<para>Notice there is an asymmetry between <code>oldValue </code>and <code>newElements:</code>  
<code>oldValue </code>is the previous value of the attached variable,
while <code>newElements </code>is a slice of the new value of the variable, containing only the modified elements.</para>

<para>The syntax of the replace trigger is meant to be evocative of a
slice assignment.  Given:</para>

<programlisting>attribute x
    on replace oldVal[lo..hi]=newVals { exp };
  var save = x;
  x[i..j] = y;
  </programlisting>
  
<para>Then <code>exp </code>will be evaluated, with <code>oldVal </code>bound to <code>save, </code> lo bound to<code> i, hi</code> bound to <code>j, </code> and <code>newVals </code>bound to <code>y.</code></para>

<para>Using the unified replace triggers should result in simpler
programs.  In some cases the existing code has identical code for
all three triggers.  For example  <code>Polygon.points </code>can be simplified to:</para>

<programlisting>    public attribute points: Number[]
        on replace {
            updatePolygon();
        };
</programlisting>

<para>Unified replace triggers work great with slice assignments.  For
example, we can define a bind, as in:</para>

<programlisting>  attribute x;
  attribute y = bind x;
</programlisting>

<para>as equivalent to:</para>

<programlisting>  attribute x =
    on replace [i..j]=n
    { y[i..j]=n };
  attribute y = [];
</programlisting>

<para>If y is a "map" of x:</para>
<programlisting>  attribute x;
  attribute y = bind for (xi in x) f(xi);
  
  </programlisting>

<para>that is equivalent to:</para>

<programlisting>  attribute x =
    on replace [i..j]=n
    { y[i..j] = for (k in n) f(k) };
  attribute y = [];
</programlisting>

<para>Deleting or replacing a range of elements in a sequence,
or inserting a sequence into a single location all
result in a single trigger invocation.  Some other
operations, such as deleting all elements that satisfy
a predicate, may be decomposed to multiple trigger
call.  In that case the state as seen by each
trigger invocation is <emphasis>consistent</emphasis> in the sense
that the programmer-visible state is <emphasis>as if</emphasis>
the predicate-delete (for example) were implemented
as a set of independent slice-delete operations.

        </para>
      </para>
    </para>

   </sect3>

  </sect2>

 </sect1>

</chapter>



  
