<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<?xml-stylesheet href="docbook.css" type="text/css"?>
<chapter id="intro">
  <title>Introduction</title>

  <section>
    <title> </title>

    <para>The JavaFX Script™ (hereinafter referred to as JavaFX) language is a
    declarative and statically typed programming language. It has first-class
    functions, declarative syntax, list-comprehensions, and incremental
    dependency-based evaluation. The JavaFX Script language makes intensive
    use of the Java2D swing GUI components and allows for easy creation of
    GUIs.</para>

    <para>This document gives an informal description of the JavaFX Script
    programming language.</para>

    <sect1>
      <title>Basic Types</title>

      <para>The JavaFX programming language provides four primitive types: <code>
      String, Boolean, Number,</code> and <code>Integer.</code> These types correspond to Java
      types as follows:</para>


    
    <table cellpadding="5" cellspacing="5"
                 style="border: medium groove ;">
            <tbody>
              <tr>
                <th style="text-decoration: underline;">JavaFX</th>

                <th style="text-decoration: underline;">Java</th>

               
              </tr>

              <tr>
                <td>
                  <code>String</code>
                </td>
             
                <td>
                  <code>java.lang.String</code>
                </td>

            
              </tr>                  

              <tr>
                <td>
                  <code>Boolean</code>
                </td>
		
		<td>
                  <code>java.lang.boolean</code>
                </td>
		</tr>
		
		<tr>

                <td><code>Number</code></td>

                <td> <code>java.lang.Number</code> </td>
              </tr>
    
	      		<tr>

                <td><code>Integer</code></td>

                <td>
                  <code>byte,short,int,long,BigInteger</code>
                </td>
              </tr>
    
                </tbody>
          </table>
    
    
    
      <emphasis role="bold">Example:</emphasis>

      <programlisting>        var s = "Hello";
        s.toUpperCase(); // yields "HELLO";
        s.substring(1);  // yields "ello";
        var n = 1.5;
        n.intValue();    // yields 1
        (1.5).intValue();    // yields 1
        s.substring(n);  // yields "ello"
        var b = true;
        b instanceof Boolean; // yields true
</programlisting>

      <para>Coercions are automatically performed on numeric types when
      passing arguments or return values to/from Java methods. In addition,
      implicit truncating coercions are performed when converting Numbers to
      Integers.</para>
    </sect1>

    <sect1>
      <title>Calling Java Objects</title>

      <para>JavaFX programs can import Java classes, create new Java objects,
      call their methods, and implement Java interfaces. The following code
      snippet provides an example:</para>

      <programlisting>        import javax.swing.JFrame;
        import javax.swing.JButton;
        import java.awt.event.ActionListener;
        import java.lang.System;

        var frame = new JFrame();
        var button = new JButton("Press me");
        frame.getContentPane().add(button);
        button.addActionListener(new ActionListener() {
                operation actionPerformed(event) {
                    System.out.println("You pressed me");
                }
            });
        frame.pack();
        frame.setVisible(true);</programlisting>

      <para>Running the above program displays the following on the screen:
      Image of simple frame window with Press me button.</para>

      <para>Of course, this isn't the preferred way of creating GUI's in
      JavaFX. The following JavaFX code achieves the same effect:</para>

      <programlisting>         Frame {
              content: Button {
                   text: "Press Me"
                   action: operation() {
                        System.out.println("You pressed me");
                   }
              }
              visible: true
         }</programlisting>
    </sect1>

    <sect1>
      <title>Variables</title>

      <para>In JavaFX, the var keyword introduces a new variable. You may
      specify the type of a variable in its declaration. However, that's
      optional in JavaFX. If you don't specify the type, the JavaFX
      interpreter infers the variable's type from its use. A variable
      declaration takes the form</para>

      <programlisting>        var variableName : typeName [?,+,*] = initializer;
</programlisting>

      <para>You may use one of the ?, +, or * operators to denote the
      cardinality of the variable, as follows:</para>

      <programlisting>Operator   Meaning
   ?       Optional (i.e, may be null)
   +       One or more
   *       Zero or more
</programlisting>

      <para>Example:</para>

      <programlisting>        var nums:Number* = [1,2,3];	
</programlisting>

      <para>The above example declares a new variable named nums whose value
      is defined to consist of zero or more instances of type Number and whose
      initial value is [1,2,3].</para>

      <para>The :typeName, [?,+,*], and = initializer portions of the
      declaration are optional, so the following is equivalent to the
      above:</para>

      <programlisting>        var nums = [1,2,3];
</programlisting>
    </sect1>

    <sect1>
      <title>Functions, Arrays, Expressions, and Operations</title>

      <para>JavaFX <code>function</code>s represent a pure functional subset
      of the JavaFX programming language. The body of a <code>function</code>
      may only contain a series of variable declarations and a return
      statement. JavaFX also provides procedures (called
      <code>operation</code>s, see below) which may contain any number of
      statements including conditional statements, looping statements,
      try/catch, etc.</para>

      <para>The order in which the functions are given is not in general
      significant. Following is a very simple example of a functional
      program:</para>

      <programlisting>function z(a,b) {
           var x = a + b;
           var y = a - b;
           return sq(x) / sq (y);
        }

        function sq(n) {return n * n;}

        function main() {
           return z(5, 10);
        }
</programlisting>

      <para>There are no mandatory type declarations, although the language is
      statically typed (see more details later).</para>

      <para>The most commonly used data structure is the array, which in
      JavaFX is written with square brackets and commas, e.g.:</para>

      <programlisting>var week_days = ["Mon","Tue","Wed","Thur","Fri"];
        var days = [week_days, ["Sat","Sun"]];
</programlisting>

      <para>Arrays represent sequences of objects. In JavaFX arrays are not
      themselves objects, however, and do not nest. Expressions that produce
      nested arrays (as in the initialization of "days" above) are
      automaticallly flattened, i.e:</para>

      <programlisting>days == ["Mon","Tue","Wed","Thur","Fri","Sat","Sun"]; // returns true
</programlisting>

      <para>The size of an array may be determined with the JavaFX
      <code>sizeof</code> operator:</para>

      <programlisting>         var n = sizeof days; // n = 7
</programlisting>

      <para>There is a shorthand notation using "<code>..</code>" for arrays
      whose elements form an arithmetic series. Here for example are
      definitions of the factorial function, and of a number "result" which is
      the sum of the odd numbers between 1 and 100</para>

      <programlisting>function fac(n) {return product([1..n]);}
        var result = sum([1,3..100]);
</programlisting>

      <para>The elements of an array must all be of the same type.</para>

      <para>Arrays may be indexed as in Java:</para>

      <programlisting>        var wednesday = days[2];
</programlisting>

      <para>In JavaFX the <code>[]</code> operator also expresses selection
      (similar to its use in XPath). In this case, the expression contained in
      the <code>[]</code> is a boolean expression. Such an expression returns
      a new array containing only those elements that satisfy the predicate
      contained in the <code>[]</code>.</para>

      <para>As in XPath, within the predicate contained inside the
      <code>[]</code> operator, the context object may be accessed with the
      dot operator, for example:</para>

      <programlisting>	var nums = [1,2,3,4];
	var numsGreaterThanTwo = nums[. &gt; 2]; // yields [3, 4]
</programlisting>

      <para>Alternatively a variable may be declared for the context object.
      For example, this is equivalent to the above statement:</para>

      <programlisting>	numsGreaterThanTwo = nums[n|n &gt; 2];
</programlisting>

      <para>The JavaFX <code>indexof</code> operator returns the ordinal
      position of an element within an array (like the <code>position()</code>
      function in XPath).</para>

      <para>The <code>car</code> and <code>cdr</code> of a list may be
      expressed using selection expressions like this:</para>

      <programlisting>	function car(list) {return list[indexof . == 0];}
	function cdr(list) {return list[indexof . &gt; 0];}
</programlisting>

      <para>Of course <code>car</code> can be expressed more succinctly as
      simply:</para>

      <programlisting>	function car(list) {return list[0];}
</programlisting>

      <para>Examples:</para>

      <programlisting>	var list = [1..10];
	car(list); // yields 1
	cdr(list); // yields [2,3,4,5,6,7,8,9,10]
</programlisting>

      <para>In JavaFX, the empty array <code>[]</code> and <code>null</code>
      are synonymous, i.e:</para>

      <programlisting>        [] == null // yields true
        sizeof null // yields 0
</programlisting>
    </sect1>

    <sect1>
      <title>Modifying Arrays</title>

      <para>In addition to the assignment operator (<code>=</code>), JavaFX
      provides data modification operators (<code>insert</code> and
      <code>delete</code>) similar in syntax and semantics to those in the
      draft XQuery-Update specification as follows:</para>

      <sect2>
        <title>Insert Statement</title>

        <para>The insert statement can take any of the following forms:</para>

        <programlisting>        insert Expression1 [as first | as last] into Expression2
        insert Expression1 before Expression2
        insert Expression1 after Expression2
</programlisting>

        <para>The <code>insert</code> statement inserts the items returned by
        evaluating Expression1 into the location indicated by remainder of the
        statement as follows:</para>

        <programlisting>into</programlisting>

        <para>Expression2 must refer to an attribute or variable. If
        Expression2 refers to a single valued attribute then the effect of the
        insert is the same as if the assignment operator were used.</para>

        <para>If <code>as first</code> is specified, the insertion location is
        before the first element of the list indicated by Expression2. If
        <code>as last</code> is specified, the insertion location is after the
        last element of the list indicated by Expression2. If neither <code>as
        first</code> nor <code>as last</code> is specified explicitly, then
        <code>as last</code> is used as the default.</para>

        <para>Examples:</para>

        <programlisting>        var x = [1,2,3];
        insert 12 into x; // yields [1,2,3,12]
        insert 10 as first into x; // yields [10,1,2,3,12]
        insert [99,100] as last into x; // yields [10,1,2,3,12,99,100]
</programlisting>

        <para>before, after</para>

        <para>Expression2 must be a selection expression over an attribute or
        variable. If <code>before</code> is specified, the insertion location
        is before the selected elements. If <code>after</code> is specified
        the insertion location is after the selected elements.</para>

        <para>Examples:</para>

        <programlisting>
        var x = [1,2,3];
        insert 10 after x[. == 10]; // yields [1,2,3,10]
        insert 12 before x[1]; // yields [1,12,2,3,10]
        insert 13 after x[. == 2]; // yields [1, 12, 2, 13, 3, 10];
</programlisting>

        <sect2>
          <title>Delete Statement</title>

          <para>The Delete statement takes one of the following forms:</para>

          <programlisting>
        delete variable
        delete Expression.attribute
        delete variable[predicate]
        delete Expression.attribute[predicate]
</programlisting>

          <para>The first two forms remove all elements from a variable or
          attribute - which is equivalent to assigning <code>[]</code> or
          <code>null</code> to the variable or attribute. The latter two forms
          remove only those elements that match the predicate.</para>

          <para>Examples:</para>

          <programlisting>
        var x = [1,2,3];
        insert 10 into x; // yields [1,2,3,10]
        insert 12 before x[1]; // yields [1,12,2,3,10]
        delete x[. == 12]; // yields [1,2,3,10]
        delete x[. &gt;= 3]; // yields [1,2]
        insert 5 after x[. == 1]; // yields [1,5,2];
        insert 13 as first into x; // yields [13, 1, 5, 2];
        delete x; // yields []
</programlisting>
        </sect2>

        <sect1>
          <title>Querying Arrays</title>

          <para>JavaFX supports list comprehensions as in functional languages
          like Miranda and Haskell, but with a familiar syntax that should be
          easily understood by Java programmers, namely the JavaFX
          <code>select</code> and <code>foreach</code> operators.</para>

          <para>Here is an example:</para>

          <programlisting>
        class Album {
            attribute title: String;
            attribute artist: String;
            attribute tracks: String*;
        }

        var albums =
        [Album {
             title: "A Hard Day's Night"
             artist: "The Beatles"
             tracks:
             ["A Hard Day's Night",
              "I Should Have Known Better",
              "If I Fell",
              "I'm Happy Just To Dance With You",
              "And I Love Her",
              "Tell Me Why",
              "Can't Buy Me Love",
              "Any Time At All",
              "I'll Cry Instead",
              "Things We Said Today",
              "When I Get Home",
              "You Can't Do That"]
        },
        Album {
              title: "Circle Of Love"
              artist: "Steve Miller Band"
              tracks:
              ["Heart Like A Wheel",
                "Get On Home",
                "Baby Wanna Dance",
                "Circle Of Love",
                "Macho City"]
        }];

        // Get the track numbers of the albums' title tracks

        // using the select operator:

        var titleTracks =
            select indexof track + 1 from album in albums,
                      track in album.tracks
                          where track == album.title; // yields [1,4]

       // the same expressed using the foreach operator:

        titleTracks =
            foreach (album in albums,
                      track in album.tracks
                          where track == album.title)
                indexof track + 1;  // also yields [1,4]

</programlisting>

          <para>A list comprehension consists of one or more input lists, an
          optional filter and a generator expression. Each source list is
          associated with a variable. The result of the list comprehension is
          a new list which is the result of applying the generator to the
          subset of the cartesian product of the source lists' elements that
          satisfy the filter.</para>

          <para>List comprehensions give a concise syntax for a rather general
          class of iterations over lists.</para>

          <para>Another simple example of a list comprehension is:</para>

          <programlisting>        select n*n from n in [1..100]
</programlisting>

          <para>This is a list containing (in order) the squares of all the
          numbers from 1 to 100. Note that "n" is a local variable of the
          above expression.</para>

          <para>The use of a filter is shown by the following definition of a
          function which takes a number and returns a list of all its
          factors,</para>

          <programlisting>        function factors(n) {
            return select i from i in [1..n/2] where n % i == 0;
        }
</programlisting>
        </sect1>

        <sect1>
          <title>Expressions</title>

          <para>JavaFX supports the following operators:</para>

          <table cellpadding="5" cellspacing="5"
                 style="border: medium groove ;">
            <tbody>
              <tr>
                <th style="text-decoration: underline;">Operator</th>

                <th style="text-decoration: underline;">Meaning</th>

                <th style="text-decoration: underline;">Java Equivalent</th>
              </tr>

              <tr>
                <th />
              </tr>

              <tr>
                <td colspan="2">
                  <emphasis>Relational Operators</emphasis>
                </td>
              </tr>

              <tr>
                <td>
                  <code>==</code>
                </td>

                <td>equality</td>

                <td>
                  <code>==</code>
                </td>
              </tr>                  

              <tr>
                <td>
                  <code>&lt;&gt;</code>
                </td>

                <td>inequality</td>

                <td>
                  <code>!=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>&lt;</code>
                </td>

                <td>less than</td>

                <td>
                  <code>&lt;</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>&gt;</code>
                </td>

                <td>greater than</td>

                <td>
                  <code>&gt;</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>&lt;=</code>
                </td>

                <td>less than or equal</td>

                <td>
                  <code>&lt;=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>&gt;=</code>
                </td>

                <td>greater than or equal</td>

                <td>
                  <code>&gt;=</code>
                </td>
              </tr>

              <tr>
                <th />
              </tr>

              <tr>
                <td colspan="2">
                  <emphasis>Boolean Operators</emphasis>
                </td>

                <td />
              </tr>

              <tr>
                <td>
                  <code>and</code>
                </td>

                <td>logical and</td>

                <td>
                  <code>&amp;&amp;</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>or</code>
                </td>

                <td>logical or</td>

                <td>
                  <code>||</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>not</code>
                </td>

                <td>logical negation</td>

                <td>
                  <code>!</code>
                </td>
              </tr>

              <tr>
                <th />
              </tr>

              <tr>
                <td colspan="2">
                  <emphasis>Arithmetic Operators</emphasis>
                </td>
              </tr>

              <tr>
                <td>
                  <code>+</code>
                </td>

                <td>addition</td>

                <td>
                  <code>+</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>-</code>
                </td>

                <td>subtraction; unary negation</td>

                <td>
                  <code>-</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>*</code>
                </td>

                <td>multiplication</td>

                <td>
                  <code>*</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>/</code>
                </td>

                <td>division</td>

                <td>
                  <code>/</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>%</code>
                </td>

                <td>remainder</td>

                <td>
                  <code>%</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>+=</code>
                </td>

                <td>add and assign</td>

                <td>
                  <code>+=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>-=</code>
                </td>

                <td>subtract and assign</td>

                <td>
                  <code>-=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>*=</code>
                </td>

                <td>multiply and assign</td>

                <td>
                  <code>*=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>/=</code>
                </td>

                <td>divide and assign</td>

                <td>
                  <code>/=</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>%=</code>
                </td>

                <td>remainder and assign</td>

                <td>
                  <code>%=</code>
                </td>
              </tr>

              <tr>
                <th />
              </tr>

              <tr>
                <td colspan="2">
                  <emphasis>Other Operators</emphasis>
                </td>
              </tr>

              <tr>
                <td>
                  <code>sizeof</code>
                </td>

                <td>array length</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>indexof</code>
                </td>

                <td>ordinal position</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>if <emphasis>e1</emphasis> then
                  <emphasis>e2</emphasis> else <emphasis>e3</emphasis></code>
                </td>

                <td>conditional expression</td>

                <td>
                  <code><emphasis>e1</emphasis> ? <emphasis>e2</emphasis> :
                  <emphasis>e3</emphasis></code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>select</code>
                </td>

                <td>list comprehension</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>foreach</code>
                </td>

                <td>list comprehension</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>new</code>
                </td>

                <td>allocation</td>

                <td>
                  <code>new</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code><emphasis>op</emphasis>()</code>
                </td>

                <td>function/operation call</td>

                <td>
                  <code>
                    <emphasis>n/a</emphasis>
                  </code>
                </td>
              </tr>

              <tr>
                <td>
                  <code><emphasis>x</emphasis>.<emphasis>op</emphasis>()</code>
                </td>

                <td>member function/operation call</td>

                <td>
                  <code><emphasis>x</emphasis>.<emphasis>op</emphasis>()</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>instanceof</code>
                </td>

                <td>type check</td>

                <td>
                  <code>instanceof</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>this</code>
                </td>

                <td>self access</td>

                <td>
                  <code>this</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>.</code>
                </td>

                <td>attribute access, context access</td>

                <td>
                  <code>., n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>bind [lazy]</code>
                </td>

                <td>incremental [lazy] evaluation</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>:</code>
                </td>

                <td>eager initialization</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>[]</code>
                </td>

                <td>array selection</td>

                <td>
                  <code>[]</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>format as</code>
                </td>

                <td>String formatting</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>&lt;&lt;&gt;&gt;</code>
                </td>

                <td>Identifier quotes</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>{}</code>
                </td>

                <td>String expression</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>(<emphasis>expr</emphasis>)</code>
                </td>

                <td>grouping</td>

                <td>
                  <code>(<emphasis>expr</emphasis>)</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>reverse</code>
                </td>

                <td>reverses a list</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>

              <tr>
                <td>
                  <code>[<emphasis>number1</emphasis>,<emphasis>next</emphasis>..<emphasis>number2</emphasis>]<!--</code--></code>
                </td>

                <td>numeric range</td>

                <td>
                  <code>n/a</code>
                </td>
              </tr>
            </tbody>
          </table>

          <para>Some Examples:</para>

          <programlisting>         import java.lang.System;
         import java.lang.Math;

         var x = 2;
         var y = 4;
         var a = true;
         var b = false;
         System.out.println(x == y);  // prints false
         System.out.println(x &lt;&gt; y);  // prints true
         System.out.println(x &lt; y);   // prints true
         System.out.println(x &gt; y);   // prints true
         System.out.println(x &gt;= y);  // prints false
         System.out.println(x &lt;= y);  // prints true
         System.out.println(x + y);   // prints  6
         System.out.println(x - y);   // prints  -2
         System.out.println(x * y);   // prints  8
         System.out.println(x / y);   // prints  0.5
         System.out.println(x % y);   // prints  2
         System.out.println(a and b); // prints  false
         System.out.println(a or b);  // prints  true
         System.out.println(not a);   // prints  false
         System.out.println(sizeof [x,y]);   // prints  2
         System.out.println([x,y][indexof . == 0]);   // prints  2
         System.out.println(if a then x else y); // prints 2
         System.out.println(select q from q in [x, y] where q &gt; 3); // prints 4
         System.out.println(foreach(q in [x, y] where q &lt; 3) q); // prints 2
         System.out.println(Math.max(x, y)); // prints 4
         System.out.println("abc".toUpperCase()); // prints ABC
         System.out.println(x instanceof Number); // prints true
         x = 10;
         System.out.println(x); // prints 10
</programlisting>
        </sect1>

        <sect1>
          <title>String Literals and String Expressions</title>

          <para>In JavaFX, a literal character string is specified with single
          quotes, e.g.</para>

          <programlisting>        var s = 'Hello';
</programlisting>

          <para>or with double quotes:</para>

          <programlisting>        var s = "Hello";
</programlisting>

          <para>In the latter case, JavaFX expressions may be embedded using
          <code>{}</code>, e.g</para>

          <programlisting>        var name = 'Joe';
        var s = "Hello {name}"; // s = 'Hello Joe'
</programlisting>

          <para>The embedded expression may itself contain quoted strings
          (which, in turn, may contain further embedded expressions),
          e.g</para>

          <programlisting>        var answer = true;
        var s = "The answer is {if answer then "Yes" else "No"}"; // s = 'The answer is Yes'
</programlisting>

          <para>Unlike in Java, JavaFX double-quoted String literals
          <emphasis>can</emphasis> contain newlines:</para>

          <programlisting>        var s = "This
                 contains
                 new lines";
</programlisting>
        </sect1>

        <sect1>
          <title>Quoted Identifiers</title>

          <para>In JavaFX, any sequence of characters (including whitespace)
          contained in french quotes <code>&lt;&lt;&gt;&gt;</code> is treated
          as an identifier. This allows you to use JavaFX keywords (or other
          normally illegal identifiers) as class, variable, function, or
          attribute names, e.g.</para>

          <programlisting>        var &lt;&lt;while&gt;&gt; = 100;
</programlisting>

          <para>It also makes it possible to call Java methods whose names are
          the same as JavaFX keywords, for example:</para>

          <programlisting>        import javax.swing.JTextArea;

        var textArea = new JTextArea();
        textArea.&lt;&lt;insert&gt;&gt;("Hello", 0);
</programlisting>
        </sect1>

        <sect1>
          <title>Range Expression</title>

          <para>As mentioned above you can define an array of numeric values
          that form an arithmetic series using the following syntax:</para>

          <programlisting>            [<emphasis>number1</emphasis>..<emphasis>number2</emphasis>]
</programlisting>

          <para>Such an expression defines an array whose elements consist of
          the integers from <emphasis>number1</emphasis> to
          <emphasis>number2</emphasis> (inclusive).</para>

          <para>For example:</para>

          <programlisting>            var nums = [0..3];
            System.out.println(nums == [0,1,2,3]); // prints true
</programlisting>

          <para>By default the interval between the values is <code>1</code>
          but it's also possible to specify a different interval by including
          the next number in the sequence after <emphasis>number1</emphasis>
          separated by a comma. For example, the following expression defines
          an array consisting of the odd numbers between <code>1</code> and
          <code>10</code>:</para>

          <programlisting>            [1,3..10]
</programlisting>

          <para>If <code>number1</code> is greater than <code>number2</code> a
          descending series is created:</para>

          <programlisting>            var nums = [3..0];
            System.out.println(nums == [3,2,1,0]); // prints true
</programlisting>
        </sect1>

        <sect1>
          <title>String, Number, and Date Formatting</title>

          <para>JavaFX has a built-in String formatting operator (<code>format
          as</code>), which has the following syntax:</para>

          <programlisting>        <emphasis>expr</emphasis> format as <emphasis>directive</emphasis>
</programlisting>

          <para>The <code>format as </code>operator supports
          <code>java.text.DecimalFormat</code>,
          <code>java.text.SimpleDateFormat</code>, and
          <code>java.util.Formatter</code> formatting directives. If the
          formatting directive starts with <code>%</code>, then
          <code>java.util.Formatter</code> is used, otherwise if <code>
              <emphasis>expr</emphasis>
            </code> is of type <code>Number</code> then
          <code>java.text.DecimalFormat</code> is used, otherwise if <code>
              <emphasis>expr</emphasis>
            </code> is of type <code>java.util.Date</code> then
          <code>java.text.SimpleDateFormat</code> is used. The <code>
              <emphasis>directive</emphasis>
            </code> operand is syntactically an identifier, not an expression.
          This allows the content of <code>
              <emphasis>directive</emphasis>
            </code> to be statically checked for correctness at compile
          time.</para>

          <para>Examples:</para>

          <programlisting>        import java.util.Date;

        100.896 format as &lt;&lt;%f&gt;&gt;; // yields '100.896000'
        31.intValue() format as &lt;&lt;%02X&gt;&gt;; // yields '1F'
        var d = new Date();
        d format as &lt;&lt;yyyy-MM-dd'T'HH:mm:ss.SSSZ&gt;&gt;; // yields '2005-10-31T08:04:31.323-0800'
        0.00123 format as &lt;&lt;00.###E0&gt;&gt;; // yields '12.3E-4'
</programlisting>
        </sect1>

        <sect1>
          <title>Operations</title>

          <para>In JavaFX, procedures are declared with the
          <code>operation</code> keyword. For example:</para>

          <programlisting>        import java.lang.StringIndexOutOfBoundsException;

        operation substring(s:String, n:Number): String {
              try {
                  return s.substring(n);
              } catch (e:StringIndexOutOfBoundsException) {
                  throw "sorry, index out of bounds";
              }
        }
</programlisting>

          <para>The above example defines a new procedure called
          "<code>substring</code>" with two arguments, the first named "s" of
          type "String", the second named "n" of type "Number", returning type
          "String".</para>

          <para>In addition to the <code>assignment</code>,
          <code>delete</code>, and <code>insert</code> statements mentioned
          above, the following statements are possible inside the body of an
          operation :</para>
        </sect1>

        <sect2>
          <title>Expression Statement</title>

          <para>A primary expression may be used as a statement, for
          example:</para>

          <programlisting>       System.out.println("Hello World!");
</programlisting>
        </sect2>

        <sect1>
          <title>If Statement</title>

          <para>The JavaFX <code>if</code> statement is like Java's except
          that curly braces are always required around the then and else
          clauses, unless the the else clause is another <code>if</code>
          statement.</para>

          <para>Example:</para>

          <programlisting>       if (condition1) {
           System.out.println("Condition 1");
       } else if (condition2) {
           System.out.println("Condition2");
       } else {
           System.out.println("not Condition 1 or Condition 2");
       }
</programlisting>
        </sect1>

        <sect2>
          <title>While Statement</title>

          <para>The JavaFX <code>while</code> statement is like Java's except
          that curly braces are always required around the body.</para>

          <para>Example:</para>

          <programlisting>       var i = 0;
       while (i &lt; 10) {
           if (i &gt; 5) {
              break;
           }
           System.out.println("i = {i}");
           i += 1;
       }
</programlisting>
        </sect2>

        <sect2>
          <title>Try Statement</title>

          <para>The JavaFX <code>try</code> statement is like Java's but with
          JavaFX variable declaration syntax. Note: in JavaFX any object can
          be thrown and caught, not just those that extend
          <code>java.lang.Throwable</code>.</para>

          <para>Example:</para>

          <programlisting>       try {
          throw "Hello";
       } catch (s:String) {
          System.out.println("caught a String: {s}");
       } catch (any) {
          System.out.println("caught something not a String: {any}");
       } finally {
          System.out.println("finally...");
       }
</programlisting>
        </sect2>

        <sect2>
          <title>For Statement</title>

          <para>The header of the JavaFX <code>for</code> statement uses the
          same syntax as the <code>foreach</code> list comprehension operator.
          However, in this case the body of the statement is executed for each
          element generated by the list comprehension.</para>

          <para>Examples:</para>

          <programlisting>        for (i in [0..10]) {
             System.out.println("i = {i}");
        }

        // print only the even numbers using a filter
        for (i in [0..10] where i % 2 == 0) {
             System.out.println("i = {i}");
        }

        // print only the odd numbers using a range expression
        for (i in [1,3..10]) {
             System.out.println("i = {i}");
        }

        // print the cartesian product
        for (i in [0..10], j in [0..10]) {
             System.out.println(i);
             System.out.println(j);
        }

</programlisting>
        </sect2>

        <sect2>
          <title>Return Statement</title>

          <para>The JavaFX <code>return</code> statement is like
          Java's:</para>

          <para>Example:</para>

          <programlisting>       operation add(x, y) {
           return x + y;
       }
</programlisting>

          <sect2>
            <title>Throw Statement</title>

            <para>The JavaFX <code>throw</code> statement is like Java's.
            However, any object may be thrown, not just those that extend
            <code>java.lang.Throwable</code>.</para>

            <para>Examples:</para>

            <programlisting>       import java.lang.Exception;

       operation foo() {
           throw new Exception("this is a java exception");
       }

       operation bar() {
           throw "just a string";
       }
</programlisting>
          </sect2>

          <sect2>
            <title>Break and Continue Statements</title>

            <para>The JavaFX <code>break</code> and <code>continue</code>
            statements are like Java's, however labels are not supported. As
            in Java, <code>break</code> and <code>continue</code> must appear
            inside the body of a <code>while</code> or <code>for</code>
            statement.</para>

            <para>Examples:</para>

            <programlisting>       operation foo() {
          for (i in [0..10]) {
              if (i &gt; 5) {
                  break;
              }
              if (i % 2 == 0) {
                  continue;
              }
              System.out.println(i);
          }
       }

       operation bar() {
           var i = 0;
           while (i &lt; 10) {
               if (i &gt; 5) {
                   break;
               }
               if (i % 2 == 0) {
                   continue;
               }
               System.out.println(i);
               i += 1;
           }
       }
</programlisting>
          </sect2>

          <sect2>
            <title>Do Statement</title>

            <para>The JavaFX <code>do</code> statement allows you to execute a
            block of JavaFX code in a background thread while allowing the AWT
            Event Dispatch Thread to continue processing events, thereby
            preventing the UI from appearing to hang. Currently, this is
            implemented by using <code>java.awt.EventQueue</code> to pump
            events while the background thread is executing. Normally, all
            JavaFX code executes in the AWT Event Dispatch Thread. Only code
            contained in the body of a <code>do</code> statement is allowed to
            execute in another thread. Such code must only access Java objects
            (and those objects must handle their own thread synchronization,
            if necessary).</para>

            <para>Example:</para>

            <programlisting>        import java.net.URL;
        import java.lang.StringBuffer;
        import java.lang.System;
        import java.io.InputStreamReader;
        import java.io.BufferedReader;



        // in the AWT EDT
        var result = new StringBuffer();

        do {
             // now in a background thread
             var url = new URL("http://www.foo.com/abc.xml");
             var is = url.openStream();
             var reader = new BufferedReader(new InputStreamReader(is));
             var line;
             while (true) {
                  line = reader.readLine();
                  if (line == null) {
                       break;
                  }
                  result.append(line);
                  result.append("\n");
             }
        } 

        // now back in the EDT
        System.out.println("result = {result}"); 
</programlisting>

            <para>In the above example, the green code which is executing in
            the EDT appears to be blocked during the execution of the body of
            the <code>do</code> statement (the red code). However, a new event
            dispatch loop is created on the stack while waiting for the
            background thread to complete. As a result, GUI events continue to
            be processed while the <code>do</code> statement is executing.
            <emphasis>Unfortunately, this isn't a perfect solution, however,
            since it can cause multiple event dispatch loops to build up on
            the stack - in the degenerate case causing a stack overflow
            exception</emphasis>.</para>
          </sect2>

          <sect2>
            <title>&gt;do later</title>

            <para>The <code>do</code> statement has a second form (<code>do
            later</code>) that allows for asynchronous execution of its body
            in the EDT rather than synchronous execution in a background
            thread (providing the functionality of
            <code>java.awt.EventQueue.invokeLater</code>) Here's an
            example:</para>

            <programlisting>        import java.lang.System;
        var saying1 = "Hello World!";
        var saying2 = "Goodbye Cruel World!";
        do later {
             System.out.println(saying1);
        }
        System.out.println(saying2);
</programlisting>

            <para>Running this code produces the following output:</para>

            <programlisting>        Goodbye Cruel World!
        Hello World!
</programlisting>
          </sect2>

          <sect1>
            <title>Classes and Objects</title>

            <para>The JavaFX syntax for specifying a class is the
            <code>class</code> keyword followed by the class name, optionally
            the <code>extends</code> keyword, and a comma separated list of
            the names of base classes, an open curly brace, a list of
            attributes, functions, and operations that each end in a
            semicolon, and a closing curly brace.</para>

            <para>Here is an example:</para>

            <programlisting>        class Person {
           attribute name: String;
           attribute parent: Person inverse Person.children;
           attribute children: Person* inverse Person.parent;
           function getFamilyIncome(): Number;
           function getNumberOfChildren(): Number;
           operation marry(spouse: Person);
        }         </programlisting>

            <para>Attributes are declared using the <code>attribute</code>
            keyword followed by the attribute's name, a colon, the attribute's
            type, optionally a cardinality specification (<code>?</code>
            meaning optional, <code>*</code> meaning zero or more, or
            <code>+</code> meaning one or more), and an optional
            <code>inverse</code> clause specifying a bidirectional
            relationship to another attribute in the class of the attributes'
            type, and terminated with a semicolon.</para>

            <programlisting>        attribute <emphasis>AttributeName</emphasis> : <emphasis>AttributeType</emphasis> <emphasis>Cardinality</emphasis> inverse <emphasis>ClassName</emphasis>.<emphasis>InverseAttributeName</emphasis>;

</programlisting>

            <para>If the <code>inverse</code> clause is present the JavaFX
            interpreter will automatically perform updates (insert or delete
            or replace depending on the kind of update and cardinalities of
            the attributes) on the inverse attribute whenever the attribute's
            value is modified.</para>

            <para>Multi-valued attributes (i.e. those declared with the
            <code>*</code> or <code>+</code> cardinality specifiers) are
            represented as arrays, and can be accessed via the <code>[]</code>
            operator and updated with the <code>insert</code> and
            <code>delete</code> operators.</para>

            <para>Unlike Java methods, the bodies all JavaFX member operations
            and member functions are defined outside of the class declaration,
            for example, like this:</para>

            <programlisting>       function Person.getNumberOfChildren() {
            return sizeof this.children;
       }         </programlisting>

            <para>Parameter and return types are required in the declaration
            of operations and functions in the class declaration but may be
            omitted in their definitions.</para>

            <sect2>
              <title>Attribute Declarations</title>

              <para>In JavaFX, it's possible to declare initial values for
              attributes. The initializers are evaluated in the order the
              attributes are specified in the class declaration in the context
              of the newly created object:</para>

              <programlisting>       import java.lang.System;

       class X {
            attribute a: Number;
            attribute b: Number;
       }
<emphasis>
       attribute X.a = 10;
       attribute X.b = -1;
</emphasis>
       var x = new X();
       System.out.println(x.a); // prints 10
       System.out.println(x.b); // prints -1
         </programlisting>

              <para>It is also possible to declare an incrementally evaluated
              expression as the value of an attribute using the
              <code>bind</code> operator:</para>

              <programlisting>       import java.lang.System;

       class X {
            attribute a: Number;
            attribute b: Number;
            attribute c: Number;
       }

       attribute X.a = 10;
<emphasis>
       attribute X.b = bind a + 10;
       attribute X.c = bind lazy b + 10;
</emphasis>

       var x = new X();
       System.out.println(x.a); // prints 10
       System.out.println(x.b); // prints 20
       System.out.println(x.c); // prints 30
       x.a = 5;
       System.out.println(x.a); // prints 5
       System.out.println(x.b); // prints 15
       System.out.println(x.c); // prints 25         </programlisting>
            </sect2>

            <sect2>
              <title>Object Literals</title>

              <para>JavaFX objects may be allocated using a declarative syntax
              consisting of the name of the class followed by a curly brace
              delimited list of attribute initializers. Each initializer
              consists of the attribute name followed by a colon, followed by
              an expression which defines its value (but see below regarding
              JavaFX's support for incremental evaluation in this context).
              Here is an example:</para>

              <programlisting>         var chris = Person {
             name: "Chris"
             children:
             [Person {
                 name: "Dee"
             },
             Person {
                 name: "Candice"

             }]
       };         </programlisting>

              <para>Java object allocation syntax is also supported. In the
              case of Java classes, you can pass arguments to the class's
              constructor as in Java:</para>

              <programlisting>        import java.util.Date;
        import java.lang.System;

        var date1 = new Date(95, 4, 23); // call a java constructor
        var date2 = Date { // create the same date as an object literal
             month: 4
             date: 23
             year: 95
        };
        System.out.println(date1 == date2);  // prints true
         </programlisting>

              <para>In JavaFX, it's possible to declare local variables inside
              an object literal. Such variables are only visible within the
              scope of the object literal itself. In addition, a variable
              referring to the object being initialized may be declared by
              using the <code>var</code> keyword as a pseudo-attribute, for
              example:</para>

              <programlisting>        var chris = Person {
             var: me
             name: "Chris"
             var child1 = Person {
                  name: "Dee"
                  parent: me
             }
             var child2 = Person { name: "Candice" }
             children: [child1, child2]
       };         </programlisting>
            </sect2>

            <sect1>
              <title>&gt;Update Triggers</title>

              <para>JavaFX <code>class</code>es don't have constructors, and
              JavaFX <code>attribute</code>s don't have "setters" like Java
              bean properties. Instead, JavaFX provides SQL-like
              <code>trigger</code>s that allow you to handle data modification
              events.</para>

              <para>Triggers are introduced with the <code>trigger</code>
              keyword.</para>

              <para>A trigger consists of a header and a body. The header
              specifies the type of event the <code>trigger</code> applies to.
              The body of the <code>trigger</code> is a procedure that
              executes whenever the specified event occurs. Inside the body
              you can use any of the statements available inside the body of
              an operation. Triggers also behave like member
              functions/operations, in that the context object is accessible
              inside the body via the <code>this</code> keyword.</para>
            </sect1>

            <sect2>
              <title>Creation Triggers</title>

              <para>You can perform an action in the context of a newly
              created object by specifying a creation "trigger", like
              this:</para>

              <programlisting>          import java.lang.System;

         class X {
              attribute nums: Number*;
         }

         trigger on new X {
              insert [3,4] into this.nums;
         }

         var x = new X();
         System.out.println(x.nums == [3,4]); // prints true         </programlisting>

              <para>This example defines a trigger that will be executed
              whenever a new instance of the <code>X</code> class is created.
              In this case it just assigns an initial value to the
              <code>nums</code> attribute.</para>
            </sect2>

            <sect2>
              <title>Insert Triggers</title>

              <para>You can perform an action whenever an element is inserted
              into a multi-valued attribute by specifying an insert trigger,
              like this:</para>

              <programlisting>         import java.lang.System;

         class X {
              attribute nums: Number*;
         }

         trigger on insert num into X.nums {
              System.out.println("just inserted {num} into X.nums at position {indexof num}");
         }
         var x = new X();
         insert 12 into x.nums; // prints just inserted 12 into X.nums at position 0
         insert 13 into x.nums; // prints just inserted 13 into X.nums at position 1
         </programlisting>

              <para>In the above example, "num" is the name of a variable that
              will contain a reference to the element being inserted (you can
              name the variable whatever you like). The context index of the
              variable (returned by the <code>indexof</code> operator)
              corresponds to the insertion point.</para>
            </sect2>

            <sect2>
              <title>Delete Triggers</title>

              <para>You can perform an action whenever an element is deleted
              from a multi-valued attribute by specifying a delete trigger,
              like this:</para>

              <programlisting>         import java.lang.System;

         class X {
              attribute nums: Number*;
         }

         trigger on delete num from X.nums {
              System.out.println("just deleted {num} from X.nums at position {indexof num}");
         }

         var x = X {
              nums: [12, 13]
         };

         delete x.nums[1]; // prints just deleted 13 from X.nums at position 1
         delete x.nums[0]; // prints just deleted 12 from X.nums at position 0
         </programlisting>

              <para>In the above example, "num" is the name of a variable that
              will contain a reference to the element being deleted (you can
              name the variable whatever you like). The context index of the
              variable (returned by the <code>indexof</code> operator)
              corresponds to the deletion point.</para>
            </sect2>

            <sect2>
              <title>Replace Triggers</title>

              <para>You can perform an action whenever the value of a
              single-valued attribute or an element of a multi-valued
              attribute is replaced, like this:</para>

              <programlisting>         import java.lang.System;

         class X {
              attribute nums: Number*;
              attribute num: Number?;
         }

         trigger on X.nums[oldValue] = newValue {
              System.out.println("just replaced {oldValue} with {newValue} at position {indexof newValue} in X.nums");
         }

         trigger on X.num[oldValue] = newValue {
              System.out.println("X.num: just replaced {oldValue} with {newValue}");
         }

         var x = X {
              nums: [12, 13]
              num: 100
         };
         x.nums[1] = 5; // prints just replaced 13 with 5 at position 1 in X.nums
         x.num = 3; // prints X.num: just replaced 100 with 3
         x.num = null;  // prints X.num: just replaced 3 with null
         </programlisting>

              <para>In the above examples, "oldValue" and "newValue" are the
              names of variables that contain references to the previous and
              current values of the element being replaced (you can name the
              variables whatever you like). The context index of the variable
              (returned by the <code>indexof</code> operator) corresponds to
              the ordinal position of the element being replaced.</para>
            </sect2>

            <sect1>
              <title>Incremental and Lazy Evaluation</title>

              <para>In JavaFX, attribute initializers can be specified to be
              lazily and/or incrementally evaluated with the <code>bind</code>
              operator. Attributes initialized with <code>bind</code> are akin
              to cells in a spreadsheet that contain formulas rather than
              literal values. During the lifetime of the object containg the
              attribute, whenever any of the objects referenced by the right
              hand side of the initializer expression changes the left hand
              side (the attribute's value) is automatically updated. Here is
              an example:</para>

              <programlisting>         import java.lang.System;

         class X {
               attribute a: Number;
               attribute b: Number;
               attribute c: Number;
         }

         trigger on X.b = newValue {
               System.out.println("X.b is now {newValue}");
         }

         trigger on X.c = newValue {
               System.out.println("X.c is now {newValue}");
         }

         var x1 = X {
              a: 1
              b: 2   // X.b is now 2 is printed
              c: 3   // X.c is now 3 is printed
         };

         var x2 = X {
              a:  x1.a       // eager, non-incremental
              b:  bind x1.b // eager, incremental (X.b is now 2 is printed)
              c:  bind lazy x1.c  // lazy, incremental (nothing is printed yet)
         };

        System.out.println(x2.a); // prints 1
        System.out.println(x2.b); // prints 2
        System.out.println(x2.c); // prints X.c is now 3, then prints 3

        x1.a = 5;
        x1.b = 5; // prints X.b is now 5, twice
        x1.c = 5; // prints X.c is now 5, twice

        System.out.println(x2.a); // prints 1
        System.out.println(x2.b); // prints 5
        System.out.println(x2.c); // prints 5
         </programlisting>

              <para>In the above example, the b and c attributes of x2 are
              bound to the b and c attributes of x1. This means that whenever
              x1's b or c attribute is updated the b and c attributes of x2
              will be correspondingly updated. The difference between x2.b and
              x2.c is that the former's value is immediately updated in its
              attribute initializer whereas the latter's binding is not
              evaluated until its value is accessed the first time.</para>

              <para>Note: the body of a <code>function</code> is always
              incrementally evaluated without requiring the <code>bind</code>
              operator, however the body of an <code>operation</code> is not.
              Unlike a function, inside an <code>operation</code> changes to
              local variables do not trigger incremental evaluation.
              Incremental evaluation is not performed inside the body of an
              <code>operation</code> except for expressions explicitly
              prefixed by <code>bind</code>.</para>

              <para>Nevertheless when you call an <code>operation</code> (or a
              Java method) from an incremental evaluation context the call
              itself is incrementally evaluated. This means that if the values
              of any of the arguments to the call change a new fresh call to
              that operation or method will be made and a new value
              returned.</para>

              <para>By contrast, <code>function</code>'s are only called once
              and the result of the evaluation is incorporated into the
              callers evaluation tree.</para>

              <para>Incremental evaluation is one of JavaFX's main
              distinguishing features that makes it possible to define complex
              dynamic GUI's declaratively. The lazy evaluation feature is
              needed to handle recursive data structures like trees and
              graphs.</para>
            </sect1>

            <sect1>
              <title>Reflection</title>

              <para>JavaFX classes, attributes, and operations are reflected
              as follows:</para>

              <programlisting>        public class Class {
            public attribute Name: String;
            public attribute Documentation:String?;
            public attribute Superclasses: Class* inverse Class.Subclasses;
            public attribute Subclasses: Class* inverse Class.Superclasses;
            public attribute Attributes: Attribute* inverse Attribute.Scope;
            public attribute Operations: Operation* inverse Operation.Target;
            public function instantiate();
        }

        public class Operation extends Class {
            public attribute Target: Class? inverse Class.Operations;
        }

        public class Attribute {
            public attribute Name: String;
            public attribute Documentation: String?;
            public attribute Scope: Class? inverse Class.Attributes;
            public attribute Type: Class?;
            public attribute Inverse: Attribute* inverse Attribute.Inverse;
            public attribute OneToOne: Boolean;
            public attribute ManyToOne: Boolean;
            public attribute OneToMany: Boolean;
            public attribute ManyToMany: Boolean;
            public attribute Optional: Boolean;
        }
</programlisting>

              <para>JavaFX supports reflective access to classes, attributes,
              and member functions and operations, through the
              <code>class</code> operator, for example:</para>

              <programlisting>        import java.lang.System;

        System.out.println(1.class.Name) // prints "Number"

        System.out.println("Hello".class.Name); // prints "String"

        class X {
            attribute a: Number;
        }
        var x = new X();
        System.out.println(x.class.Name); // prints "X"
        System.out.println(sizeof x.class.Attributes); // prints 1
        System.out.println(x.class.Attributes[0].Name); // prints "a"</programlisting>

              <para>Reflective access to the <emphasis>value</emphasis> of an
              attribute is provided by the <code>[]</code> operator when its
              operand is of type <code>Attribute</code>, for example</para>

              <programlisting>        import java.lang.System;

        class X {
            attribute a: Number;
        }
        var x = new X();
        x.a = 2;
        System.out.println(x[x.class.Attributes[Name == 'a']]); // prints 2
        // the above statement is equivalent to this non-reflective code:
        System.out.println(x.a);
</programlisting>

              <para>In JavaFX, the member functions and operations of a class
              are themselves modeled as classes in which the target class,
              formal parameters, and return value are represented as
              attributes. The name of the attribute representing the target
              object is 'this'. The name of the attribute representing the
              return value is 'return'. The attributes representing the formal
              parameters have the same names as the formal parameters.</para>

              <para>You obtain such reflected operations from the
              <code>Class</code> object.</para>

              <para>Reflected JavaFX operations can be called like functions
              by passing the target object as the first argument and any
              parameters as subsequent arguments, e.g:</para>

              <programlisting>        import java.lang.System;

        class X {
            operation foo(n: Number): Number;
        }

        var x = new X();
        var op = x.class.Operations[Name == 'foo'];
        System.out.println(op(x, 100));

        // the above code is equivalent to the following non-reflective code:
        System.out.println(x.foo(100));
</programlisting>

              <para>Currently, the bean properties and public fields of Java
              classes are reflected as JavaFX attributes. However, Java
              methods are not reflected as JavaFX operations. If you want to
              call a Java method reflectively you can simply use the normal
              Java API's.</para>

              <para>Note that, unlike Java, in JavaFX the <code>class</code>
              operator is applied to an expression rather than to a type name.
              JavaFX supports the following syntax to obtain the reflected
              class object from a type name:</para>

              <programlisting>           :<emphasis>TypeName</emphasis>
</programlisting>

              <para>For example:</para>

              <programlisting>           import java.lang.System;
           System.out.println(:System.Name); // prints "java.lang.System"
           System.out.println(:System.class.Name); // prints "Class"
</programlisting>
            </sect1>

            <sect1>
              <title>Enumerations</title>

              <para>JavaFX provides the capability to declare named
              instances of a class with the following syntax:</para>

              <programlisting>

              <emphasis>objectName</emphasis>:<emphasis>ClassName</emphasis>
</programlisting>

              <para>For example:</para>

              <programlisting>
              import java.lang.System;

              myString:String = "This is a string";

              System.out.println(myString:String);
</programlisting>

              <para>Such named instances are globally accessible but must
              normally be qualified with the class name. However, in the
              context of attribute initializers and assignments the named
              instances of the expression's type are introduced into the
              lexical scope (with weaker visibility than variables and
              attributes) and may be referenced with their unqualified names,
              for example:</para>

              <programlisting>              Button {
                  mnemonic: P
                  text: "Press Me"
              }</programlisting>

              <para>In the above example, since the <code>mnemonic</code>
              attribute of <code>Button</code> is of type
              <code>KeyStroke</code>, I can access the named value
              <code>P</code> with its unqualified name (elsewhere I would have
              to refer to it as <code>P:KeyStroke</code>).</para>

              <para>The values of Java 1.5 enumerated types may be accessed
              with the same syntax, for example:</para>

              <programlisting>              import java.lang.management.MemoryType;

              var heap = HEAP:MemoryType;
              var nonHeap = NON_HEAP:MemoryType;
</programlisting>
            </sect1>
          </sect1>
        </sect2>
      </sect2>
    </sect1>
  </section>
</chapter>