<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Objects and Classes</title>

  <section>
    <title>Objects</title>

    <para><emphasis role="bold">[DRAFT NOTES: The purpose of this draft is to
    ensure that the technical content is correct, complete (if not,
    engineering must identify what is missing), and is presented in an order
    that makes sense within the context of the book. It also fixes trademark
    violations that were present in the original text. We've decided that
    Classes and Objects will be the subject of this chapter. Once the
    technical content has been established and signed off on by engineering,
    we will focus on the narrative text to help this read more like a book
    than it does now. The next draft will include some discussion of state and
    behavior here before the reference material begins. We will take care to
    make the tone suit the intended audience.]</emphasis></para>

    <para></para>

    <para>The previous chapter presented a basic example of how to use
    objects; this section describes them in more detail. Because objects and
    classes (and their attributes and functions) are so closely related, there
    is a slight amount of cross referencing in the code samples contained in
    this chapter.</para>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Insert a short definition of the term
    "object" here. Most readers will already know what that is, but we should
    provide a short definition nonetheless. We don't want the tone to sound
    too much like a tutorial, so this definition should be kept to a few
    sentences. After that, we can proceed as below, which shows how to create
    an object. We will add this narrative in the next
    draft.]</emphasis></para>

    <para></para>

    <para>Objects may be allocated using a declarative syntax consisting of
    the name of the class followed by a curly brace delimited list of
    attribute initializers. Each initializer consists of the attribute name
    followed by a colon, followed by an expression which defines its value
    (see <link linkend="???">Incremental and Lazy Evaluation</link> for JavaFX
    Script's support for incremental evaluation in this context). <emphasis
    role="bold">[NOTE: Original engineering text had a note/link here about
    incremental and lazy evaluation. That's a more advanced topic that can
    just be presented later. We don't need a forward link to it here.]
    </emphasis></para>

    <para></para>

    <para>Here is a simple example:</para>

    <para></para>

    <programlisting>Person { 
     name: "Chris"
}
</programlisting>

    <para></para>

    <para>Multi-valued attributes are known as <emphasis><ulink
    url="???">sequences</ulink></emphasis>. A sequence is an ordered list of
    objects; they appear within square brackets:</para>

    <para></para>

    <programlisting>Person {
     name: "Chris"
     children:
     [Person {
          name: "Dee"
     },
     Person {
          name: "Candice"
     }]
}</programlisting>

    <para></para>

    <para>To store this newly created Person object in a variable, use the
    <code><link linkend="???">var</link></code> keyword:</para>

    <para></para>

    <programlisting>var chris = Person {
     name: "Chris"
     children:
     [Person {
          name: "Dee"
     },
     Person {
          name: "Candice"
     }]
};
</programlisting>

    <para></para>

    <para>Java programming language object allocation syntax is also
    supported. In such cases, it is possible to pass arguments to the
    constructor of a class:</para>

    <para></para>

    <para><programlisting>import java.util.Date;
import java.lang.System;

var date1 = new Date(95, 4, 23); // invoke a constructor
var date2 = Date { // create the same date as an object literal
     month: 4
     date: 23
     year: 95
};
System.out.println(date1 == date2);  // prints true
</programlisting></para>

    <para></para>

    <para>In fact, code written in JavaFX Script can interact with the Java
    programming language in a number of ways: it can import classes, create
    new objects, invoke methods, and implement interfaces. The following code
    snippet provides an example:</para>

    <para></para>

    <para><programlisting>import javax.swing.JFrame;
import javax.swing.JButton;
import java.awt.event.ActionListener;
import java.lang.System;

var frame = new JFrame();
var button = new JButton("Press me");
frame.getContentPane().add(button);
button.addActionListener(new ActionListener() {
        operation actionPerformed(event) {
            System.out.println("You pressed me");
        }
     });
frame.pack();
frame.setVisible(true);
</programlisting></para>

    <para></para>

    <para>This code displays the following on screen:</para>

    <para></para>

    <screenshot>
      <mediaobject>
        <imageobject>
          <imagedata fileref="frame.png" />
        </imageobject>
      </mediaobject>
    </screenshot>

    <para></para>

    <para>This, however, is not the preferred way to create GUIs in JavaFX
    Script. The following code uses object literals to produce the same
    result:</para>

    <para></para>

    <programlisting>Frame {
     content: Button {
          text: "Press Me"
          action: operation() {
          System.out.println("You pressed me");
          }
     }
     visible: true
}
</programlisting>

    <para></para>
  </section>

  <section>
    <title>Defining and Extending Classes</title>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Add narrative describing classes (and
    inheritance). This narrative will most likely include some comparison to
    the Java programming language (i.e. why does JavaFX Script support
    multiple inheritance, when the Java programming language intentionally
    does not?) Do we need a demo program to illustrate this before jumping
    into the syntax descriptions? In general, what does engineering want to
    say before we jump into the details?]</emphasis></para>

    <para></para>

    <para>The syntax for specifying a class is the <code>class</code> keyword
    followed by the class name, optionally the <code>extends</code> keyword,
    and a comma separated list of the names of base classes, an open curly
    brace, a list of attributes, functions, and operations that each end in a
    semicolon, and a closing curly brace. Similar to the Java programming
    language, classes and their members may be declared <code>public</code>,
    <code>protected</code>, or <code>private</code>, in which case they may be
    accessed anywhere, in the current package or in derived classes, or only
    in the current class, respectively.</para>

    <para></para>

    <para><emphasis role="bold">[QUESTION: Do we want to have a separate
    section that explains the rules of the access modifiers? We should
    probably have definitions of public, private, protected etc. otherwise the
    reader will have to look these up elsewhere]</emphasis></para>

    <para></para>

    <para>Here is an example:</para>

    <para></para>

    <programlisting>public class Person extends Object {
     public attribute name: String;
     public attribute parent: Person; 
     public attribute children: Person[];
     public function getFamilyIncome(): Number { return ...; };
     public function getNumberOfChildren(): Number { return sizeof children; }
     public function marry(spouse: Person): Void { ...; }
}
</programlisting>

    <para></para>

    <para><emphasis role="bold">[QUESTION: Readers might expect to see the
    usual convention of private variables with public accessors; Should we
    describe here why the attributes and functions are all public? Will the
    reader need to learn a new coding convention?]</emphasis></para>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Engineering to provide more details
    about defining and extending classes, in particular multiple
    inheritance.]</emphasis></para>

    <para></para>

    <para><emphasis role="bold">[QUESTION: <code></code><code></code>The
    original engineering text had a couple of sentences saying that "this"
    accesses the current object (for non-static members), and that "static"
    associates a member with the class itself. Is that enough informatio, or
    do we want a section here dedicated to "this" and "static"?]
    </emphasis></para>

    <para></para>
  </section>

  <section>
    <title>Attributes, Functions, and Triggers</title>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Add Narrative to describe that
    attributes define the state of an object, again following the tone that's
    been established (we have plenty of demo code so far that has used
    attributes; tie into that as needed.]</emphasis></para>

    <para><emphasis role="bold">(NOTE: The sections "Attributes", "Functions",
    and "Triggers" below will have larger headings 3.1, 3.2, 3.3 in the next
    draft. The XML editor is having a problem with this at the moment so for
    now I'm writing it in bold text only.)</emphasis></para>

    <para></para>

    <para><emphasis role="bold">3.1 Attributes</emphasis></para>

    <para>Attributes define the state of an object. They are declared using
    the <code>attribute</code> keyword followed by the attribute's name, a
    colon, the attribute's type, optionally a cardinality specification
    (<code>?</code> meaning optional, <code>*</code> meaning zero or more, or
    <code>+</code> meaning one or more), <code></code>terminated with a
    semicolon.</para>

    <para></para>

    <para><programlisting>attribute <emphasis>AttributeName</emphasis> : <emphasis>AttributeType</emphasis> <emphasis>Cardinality</emphasis> ;</programlisting></para>

    <para><emphasis role="bold"><link linkend="???"></link></emphasis></para>

    <para><emphasis role="bold">[QUESTION: Is the above correct? I modified it
    based on the response to the last draft]</emphasis></para>

    <para></para>

    <para>Multi-valued attributes (i.e. those declared with the <code>*</code>
    or <code>+</code> cardinality specifiers) are represented as arrays. You
    can access them using the <code>[]</code> operator and update them using
    the <code>insert</code> and <code>delete</code> operators.</para>

    <para></para>

    <para>It is possible to declare default values for attributes (which can
    later be overridden by values provided in object literals.) The
    initializers are evaluated in the order the attributes are specified in
    the class declaration in the context of the newly created object:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute a: Number = 10;
     attribute b: Number = -1;
}
var x = X { };
System.out.println(x.a); // prints 10
System.out.println(x.b); // prints -1
</programlisting>

    <para></para>

    <para>It is also possible to declare an incrementally evaluated expression
    as the value of an attribute using the <code>bind</code> operator:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute a: Number = 10;
     attribute b: Number = bind a + 10;
     attribute c: Number = bind lazy b + 10;
}

var x = X { };
System.out.println(x.a); // prints 10
System.out.println(x.b); // prints 20
System.out.println(x.c); // prints 30
x.a = 5;
System.out.println(x.a); // prints 5
System.out.println(x.b); // prints 15
System.out.println(x.c); // prints 25      
</programlisting>

    <para></para>

    <para><emphasis role="bold">3.2 Functions</emphasis></para>

    <para><emphasis></emphasis></para>

    <para><emphasis><emphasis role="bold">[TO-DO: Add narrative explaining how
    functions define the behavior of an object, keeping the tone that's been
    established]</emphasis></emphasis></para>

    <para><emphasis></emphasis></para>

    <para>Expressions may be <emphasis>factored</emphasis> into subroutines
    called <emphasis>functions</emphasis>, for example:</para>

    <para></para>

    <para><programlisting>function z(a:Number, b:Number):Number {
     var x = a + b;
     var y = a - b;
     return sq(x) / sq (y);
}

function sq(n:Number): Number {n * n;}

function main():Number {
     return z(5, 10);
}
</programlisting></para>

    <para></para>

    <para>A function takes the form:</para>

    <para></para>

    <programlisting>function <emphasis>name</emphasis> (<emphasis>parameterName</emphasis> : <emphasis>parameterType</emphasis>, ...): <emphasis>returnType</emphasis><emphasis> body
</emphasis></programlisting>

    <para></para>

    <para>where <emphasis>body</emphasis> can be any expression.</para>

    <para></para>

    <para>Functions are first-class objects (they can, for example, be
    assigned to variables, or passed as parameters to other functions.)</para>

    <para></para>

    <para>Functions may be anonymous:</para>

    <para></para>

    <programlisting>var add = function(a:Number, b:Number):Number { a + b; }
var result = add(1, 2);    
</programlisting>

    <para><emphasis role="bold"></emphasis></para>

    <para><emphasis role="bold">3.3 Triggers</emphasis></para>

    <para></para>

    <para>JavaFX Script <code>class</code>es don't have constructors, and
    JavaFX <code>attribute</code>s don't have "setters" like Java bean
    properties. Instead, JavaFX Script provides SQL-like triggers that allow
    you to handle data modification events. <emphasis role="bold">[TO-DO:
    Expand on the narrative of this section]</emphasis></para>

    <para></para>

    <para>A trigger consists of a header and a body. The header specifies the
    type of event the trigger applies to. The body of the trigger is a
    procedure that executes whenever the specified event occurs. Triggers
    defined in a class also behave like member functions, in that the context
    object is accessible inside the body via the <code>this</code>
    keyword.</para>

    <para></para>

    <para><emphasis role="bold">Creation Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action in the context of a newly created object
    by specifying an "init" trigger, like this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[];
     init {
          insert [3,4] into this.nums;
     }
}

var x = X { };
System.out.println(x.nums == [3,4]); // prints true
</programlisting>

    <para></para>

    <para>This example defines a trigger that will be executed whenever a new
    instance of the X class is created. In this case it just assigns an
    initial value to the nums attribute.</para>

    <para><emphasis role="bold"></emphasis></para>

    <para><emphasis role="bold">Insert Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action whenever an element is inserted into a
    multi-valued attribute by specifying an "insert" trigger, like
    this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on insert[i](num) {
          System.out.println("just inserted {num} into X.nums at position {i}");
     }
}

var x = X { };
insert 12 into x.nums; // prints just inserted 12 into X.nums at position 0
insert 13 into x.nums; // prints just inserted 13 into X.nums at position 1
</programlisting>

    <para></para>

    <para>In the above example, "num" is the name of a variable that will
    contain a reference to the element being inserted (you can name the
    variable whatever you like.) The context index of the variable (denoted by
    <emphasis>i</emphasis>) corresponds to the insertion point.</para>

    <para></para>

    <para><emphasis role="bold">Delete Triggers </emphasis></para>

    <para></para>

    <para>You can perform an action whenever an element is deleted from a
    multi-valued attribute by specifying a delete trigger, like this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on delete[i](num) {
          System.out.println("just delete {num} from X.nums at position {i}");
     }
}

var x = X {
     nums: [12, 13]
};

delete x.nums[1]; // prints just deleted 13 from X.nums at position 1
delete x.nums[0]; // prints just deleted 12 from X.nums at position 0
</programlisting>

    <para></para>

    <para>In the above example, "num" is the name of a variable that will
    contain a reference to the element being deleted (you can name the
    variable whatever you like). The variable <emphasis>i</emphasis>
    corresponds to the deletion point.</para>

    <para></para>

    <para><emphasis role="bold">Replace Triggers</emphasis></para>

    <para></para>

    <para>You can perform an action whenever the value of a single-valued
    attribute or an element of a multi-valued attribute is replaced, like
    this:</para>

    <para></para>

    <programlisting>import java.lang.System;

class X {
     attribute nums: Number[] on replace[i](oldValue) {
          System.out.println("just replaced {oldValue} with {newValue} at position {i} in X.nums");
     }
     attribute num: Number on replace (oldValue) {
          System.out.println("X.num: just replaced {oldValue} with {num}");
     }
}

var x = X {
     nums: [12, 13]
     num: 100
};

x.nums[1] = 5; // prints just replaced 13 with 5 at position 1 in X.nums
x.num = 3; // prints X.num: just replaced 100 with 3
</programlisting>

    <para></para>

    <para>In the above examples, "oldValue" is the name of a variable that
    contains reference to the previous value of the element being replaced
    (you can name the variable whatever you like). The variable
    <emphasis>i</emphasis> between the square brackets (which you can also
    name whatever you like) corresponds to the insertion, deletion, or
    replacement index.</para>

    <para></para>

    <para><emphasis role="bold">[TO-DO: Use of "you" sounds like a tutorial;
    re-visit this chapter text to clean that up.]</emphasis></para>

    <para><emphasis></emphasis></para>

    <para><emphasis role="bold">[QUESTION: Do we want this chapter to end with
    a Summary section, QandA, large demo program, or anything like that? Or
    should it just simply end?]</emphasis></para>

    <para><emphasis></emphasis></para>
  </section>
</chapter>