<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Expressions</title>

  <para>All executable code in JavaFX Script is expressions. This chapter
  describes the syntax, meaning, and use of expressions.</para>

  <para>This chapter is organized by the syntactic structure of JavaFX
  expressions.</para>

  <para><remark>[To do: add semantics, typing, and examples. Possibly add an
  introductory section in a conceptual rather than syntactic
  order]</remark></para>

  <sect1>
    <title>expression</title>

    <para>At the top level of expression syntax are the expressions that stand
    alone and have no value.</para>

    <para></para>

    <figure>
      <title>expression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="expression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <sect2>
      <title>insert</title>

      <para>The <command>insert</command> expression is used to insert a value
      (which may be a sequence) into a sequence.</para>

      <figure>
        <title>insert</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="insert.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>indexedSequenceForInsert</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="indexedSequenceForInsert.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para><command>insert-into</command> inserts into the sequence at the
      end. The other forms allow you to specify where in the sequence the
      value should be inserted by using an indexed expression.
      <command>insert-before</command> inserts before the indexed element;
      <command>insert-after</command> inserts after the indexed element. For
      example:</para>

      <programlisting>var names = ['Evelyn', 'Will'];
insert 'Marsha' into names;
println(names);
insert ['Ron', 'Melissa'] before names[1];
println(names);
insert 'Daz' after names[3];
println(names);</programlisting>

      <para>Will print:</para>

      <para><computeroutput>[ Evelyn, Will, Marsha ] </computeroutput></para>

      <para><computeroutput>[ Evelyn, Ron, Melissa, Will, Marsha ]
      </computeroutput></para>

      <para><computeroutput>[ Evelyn, Ron, Melissa, Will, Daz, Marsha ]
      </computeroutput></para>

      <para>Note that inserting a sequence inserts the elements of the
      sequence -- sequences are never nested.</para>

      <para>Inserting before or after a negative index inserts at the
      beginning of the sequence. Inserting before or after an index beyond the
      end of the sequence inserts at the end of the sequence. Though neither
      of these cases is implemented in V1.0 of the language.</para>

      <para>An insert expression has no value, it is of Void type.</para>
    </sect2>

    <sect2>
      <title>delete</title>

      <para>The delete expression is used to delete an element or elements
      from a sequence.</para>

      <figure>
        <title>delete</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="delete.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Delete has four forms:</para>

      <table>
        <title>Form of Delete</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry><command>delete</command>
              <emphasis>sequence</emphasis>[<emphasis>index</emphasis>]</entry>

              <entry>Delete from <emphasis>sequence</emphasis> the element at
              <emphasis>index</emphasis>. If there is no element at that
              <emphasis>index</emphasis>, ignore the delete.</entry>
            </row>

            <row>
              <entry><command>delete</command>
              <emphasis>sequence</emphasis>[<emphasis>begin..end</emphasis>]</entry>

              <entry>Delete from <emphasis>sequence</emphasis> the elements
              from indices <emphasis>begin</emphasis> to
              <emphasis>end</emphasis> inclusive. If there is no element at
              some of these indices, those indices are ignored. Note that,
              more generally, this allows full slice syntax. See
              slices.</entry>
            </row>

            <row>
              <entry><command>delete</command> <emphasis>value</emphasis>
              <command>from</command>
              <emphasis>sequence</emphasis><emphasis></emphasis></entry>

              <entry>Delete the value, if present, from the sequence.
              Otherwise, ignore.</entry>
            </row>

            <row>
              <entry><command>delete</command>
              <emphasis>sequence</emphasis><emphasis></emphasis></entry>

              <entry>Delete all elements from the sequence -- but not the
              sequence itself.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>For example:</para>

      <programlisting>var names = [ 'Donna', 'Barb', 'Ron', 'Melissa', 'Will', 'Daz', 'Jim' ] ;
println(names);
delete 'Will' from names;
println(names);
delete names[1..3];
println(names);
delete names[0];
println(names);
delete names;
println(names);
</programlisting>

      <para>Will print:</para>

      <para><computeroutput>[ Donna, Barb, Ron, Melissa, Will, Daz, Jim ]
      </computeroutput></para>

      <para><computeroutput>[ Donna, Barb, Ron, Melissa, Daz, Jim ]
      </computeroutput></para>

      <para><computeroutput>[ Donna, Daz, Jim ] </computeroutput></para>

      <para><computeroutput>[ Daz, Jim ] </computeroutput></para>

      <para><computeroutput>[ ]</computeroutput></para>

      <para>A delete expression has no value, it is of Void type.</para>
    </sect2>

    <sect2>
      <title>while</title>

      <para>The while expression evaluates its body (the expression after the
      close-parenthesis) repeatedly as long as the Boolean condition (the
      <emphasis>valueExpression</emphasis>) is true. Basically the same as a
      while-loop in most languages.</para>

      <figure>
        <title>while</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="while.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A while expression has no value, it is of Void type.</para>
    </sect2>

    <sect2>
      <title>break</title>

      <para>Evaluating a break causes the loop in which it is lexically
      contained to terminate. Where a loop is either a
      <command>while</command> or <command>for</command>-exapression.</para>

      <figure>
        <title>break</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="break.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A break always completes abruptly and thus has no value.</para>
    </sect2>

    <sect2>
      <title>continue</title>

      <para>Evaluating a continue causes the loop it is lexically contained to
      immediately complete the iteration currently executing and attempt the
      next iteration. Where a loop is either a <command>while</command> or
      <command>for</command>-exapression.</para>

      <figure>
        <title>continue</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="continue.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A break expression always completes abruptly and thus has no
      value.</para>
    </sect2>

    <sect2>
      <title>throw</title>

      <para>A throw expression causes an Exception to be thrown. See the Error
      Handling chapter.</para>

      <figure>
        <title>throw</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="throw.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>A throw expression always completes abruptly and thus has no
      value.</para>
    </sect2>

    <sect2>
      <title>return</title>

      <para>A return expression causes return from a function, optionally with
      the value of the function.</para>

      <figure>
        <title>return</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="return.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>try</title>

      <para><remark>[To do: describe]</remark></para>

      <para></para>

      <figure>
        <title>try</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="try.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>catchClause</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="catchClause.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>finallyClause</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="finallyClause.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para>A try expression has no value, it is of Void type.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>valueExpression</title>

    <para></para>

    <figure>
      <title>valueExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="valueExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <sect2>
      <title>ifExpression</title>

      <para>The <emphasis>ifExpression</emphasis> is used to selectively
      evaluate code.</para>

      <figure>
        <title>ifExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="if.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>If the <command>else</command> part is present and neither of the
      <emphasis>expression</emphasis>s is of Void type, then the
      <emphasis>ifExpression</emphasis> has a value. That value is the value
      of the first <emphasis>expression</emphasis> if
      <emphasis>valueExpression</emphasis> is true, and otherwise the value of
      the second <emphasis>expression</emphasis>. The type of such an
      <emphasis>ifExpression</emphasis> is the most specific type that has the
      type of the first <emphasis>expression</emphasis>. as a subtype and also
      has the type of the second <emphasis>expression</emphasis> as a subtype.
      For example:</para>

      <programlisting>var x = if (bip) "Fern" else 2.68;</programlisting>

      <para>Here, bip must be a Boolean variable. If bip is true the value of
      x is "Fern". If bip is false the value of x is 2.68. The type of x is
      Object as there is no more specific type that has String and Number as
      subtypes.</para>

      <para>If there is no <command>else</command> part or either
      <emphasis>expression</emphasis> is of Void type, then the
      <emphasis>ifExpression</emphasis> has Void type. For example:</para>

      <programlisting>if (temp &gt; 1000) {
   println("Reactor breach!")
}</programlisting>

      <para>Here the println will be executed if the temp is greater than
      1000.</para>
    </sect2>

    <sect2>
      <title>forExpression</title>

      <para>The <emphasis>forExpression</emphasis> iterates over one or more
      sequences. The expression is called the body of the
      <emphasis>forExpression</emphasis>. If the body is of Void type, then
      the <emphasis>forExpression</emphasis> has Void. Otherwise the value of
      the <emphasis>forExpression</emphasis> is a sequence consisting of each
      body value.</para>

      <figure>
        <title>forExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="for.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>inClause</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="inClause.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>newExpression</title>

      <para>A newExpression can be used to create an instance of a Java class.
      It allows the arguments to a Java constructor to be provided. It can
      also be used to create an instance of a JavaFX class, but objectLiteral
      is generally used for that purpose.</para>

      <figure>
        <title>newExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="newExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>For example:</para>

      <programlisting>var stream = new java.io.FileInputStream("myBuddies.gif");</programlisting>

      <para></para>
    </sect2>
  </sect1>

  <sect1>
    <title>assignmentExpression</title>

    <para>An assignmentExpression assigns the value of the right-hand-side
    (<emphasis>valueExpression</emphasis>) to the variable, sequence element,
    or sequence slice referenced on the left-hand-side.</para>

    <figure>
      <title>assignmentExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="assignmentExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>This example demonstrates sequence element, or sequence slice
    assignment:</para>

    <programlisting>var food = ['cheese', 'soda', 'fries', 'cupcake'];
println( food );
food[2] = 'eggplant';
println( food );
food[4] = 'measles';
println( food );
food[0..1] = ['spinach', 'brocolli', 'apples'];
println( food );
food[4..20] = 'tomatoes';
println( food );
</programlisting>

    <para>Note that assignments to out of range indicies (the attempt to
    assign 'measles' at index 4) are ignored; as is also the case for
    out-of-range portions of slice assignments (4..20). That the size of the
    slice being assigned need not match the size of the assigned sequence.
    Note: as in all cases where sequences are required, singletons are
    automatically converted ('tomatoes'). As a result, the follwoing is
    printed on the console:</para>

    <para><computeroutput>[ cheese, soda, fries, cupcake ]
    </computeroutput></para>

    <para><computeroutput>[ cheese, soda, eggplant, cupcake ]
    </computeroutput></para>

    <para><computeroutput>[ cheese, soda, eggplant, cupcake ]
    </computeroutput></para>

    <para><computeroutput>[ spinach, brocolli, apples, eggplant, cupcake ]
    </computeroutput></para>

    <para><computeroutput>[ spinach, brocolli, apples, eggplant, tomatoes
    ]</computeroutput></para>

    <para>The value of the assignment expression is the value of the variable,
    element, or slice after the assignment. The type of the assignment
    expression is the type of the variable, element, or slice.</para>
  </sect1>

  <sect1>
    <title>assignmentOpExpression</title>

    <para><remark>[To do: break out tween expression]</remark></para>

    <para>An assignmentOpExpression performs an arithmetic operation, then
    assigns the result to the variable or sequence element referenced on the
    left-hand-side.</para>

    <figure>
      <title>assignmentOpExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="assignOpExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>assignmentOperator</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="assignmentOperator.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <table>
      <title>Assignment Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center"> Operator</entry>

            <entry align="center">Meaning </entry>

            <entry align="center">Operand Types</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry morerows="4"><command>+=</command></entry>

            <entry morerows="4">Add then assign</entry>

            <entry>Integer += Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer += Number</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Number += Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number += Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration += Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="4"><command>-=</command></entry>

            <entry morerows="4">Subtract then assign</entry>

            <entry>Integer -= Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer -= Number</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Number -= Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number -= Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration -= Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="5"><command>*=</command></entry>

            <entry morerows="5">Multiply then assign</entry>

            <entry>Integer *= Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer *= Number</entry>

            <entry>Integer (computed using Number)</entry>
          </row>

          <row>
            <entry>Number *= Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number *= Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration *= Integer</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration *= Number</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="5"><command>/=</command></entry>

            <entry morerows="5">Divide then assign</entry>

            <entry>Integer /= Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer /= Number</entry>

            <entry>Integer (computed using Number)</entry>
          </row>

          <row>
            <entry>Number /= Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number /= Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration /= Integer</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration /= Number</entry>

            <entry>Duration</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para></para>
  </sect1>

  <sect1>
    <title>andExpression orExpression (Two Argument Boolean
    Operations)</title>

    <para>These provide the logical <command>and</command> and the logical
    <command>or</command> operators. Both are cut-off operations, that is:
    with <command>and</command>, if the left-hand-side is false then the value
    is known to be false, so the right-hand-side is not evaluated; with
    <command>or</command>, if the left-hand-side is true then the value is
    known to be true, so the right-hand-side is not evaluated</para>

    <figure>
      <title>andExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="andExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>orExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="orExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <para></para>

    <table>
      <title>Binary Logical Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center"> Operator</entry>

            <entry align="center">Meaning </entry>

            <entry align="center">Operand Types</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>and</command></entry>

            <entry>Logical and</entry>

            <entry>Boolean and Boolean</entry>

            <entry>Boolean</entry>
          </row>

          <row>
            <entry><command>or</command></entry>

            <entry>Logical or</entry>

            <entry>Boolean or Boolean</entry>

            <entry>Boolean</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>For example:</para>

    <programlisting>var inRange : Boolean = (x &gt;= 0) and (x &lt;= 100);
var done : Boolean = (timeRemaining &lt;= 0ms) or cancelled;</programlisting>

    <para>Because of type inference, these variables don't need to be
    explicitly declared as Boolean.</para>
  </sect1>

  <sect1>
    <title>typeExpression</title>

    <para>Two operators over data type.</para>

    <figure>
      <title>typeExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="typeExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <table>
      <title>Binary Logical Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center"> Operator</entry>

            <entry align="center">Meaning </entry>

            <entry align="center">Operand Types</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>instanceof</command></entry>

            <entry>Is this object of the specified type</entry>

            <entry>Object instanceof Type</entry>

            <entry>Boolean</entry>
          </row>

          <row>
            <entry><command>as</command></entry>

            <entry>Convert this object to the specified type</entry>

            <entry>Object as Type</entry>

            <entry>Object (of type Type)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>For example:</para>

    <programlisting>function toString(val : Object) : String {
   if (val instanceof String) 
      val as String 
   else 
      "Not a String"
}</programlisting>

    <para>This example function uses <command>instanceof</command> to check is
    the input is a String, and if it is, it changes the type of the expression
    to String using the <command>as</command> operator.</para>
  </sect1>

  <sect1>
    <title>relationalExpression</title>

    <para>A relational expression is a comparison between two values. The
    result is Boolean: true or false.</para>

    <figure>
      <title>relationalExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="relationalExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>relationalOperator</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="relationalOperator.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <table>
      <title>Relational Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center">Operator</entry>

            <entry align="center">Meaning</entry>

            <entry align="center">Operand Types</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><command>==</command></entry>

            <entry>Equals (value)</entry>

            <entry>Object == Object</entry>

            <entry>Boolean</entry>
          </row>

          <row>
            <entry><command>!=</command></entry>

            <entry>Not equals (value)</entry>

            <entry>Object != Object</entry>

            <entry>Boolean</entry>
          </row>

          <row>
            <entry morerows="4"><command>&lt;</command></entry>

            <entry morerows="4">Less than</entry>

            <entry>Integer &lt; Integer</entry>

            <entry morerows="4">Boolean</entry>
          </row>

          <row>
            <entry>Integer &lt; Number</entry>
          </row>

          <row>
            <entry>Number &lt; Integer</entry>
          </row>

          <row>
            <entry>Number &lt; Number</entry>
          </row>

          <row>
            <entry>Duration &lt; Duration</entry>
          </row>

          <row>
            <entry morerows="4"><command>&lt;=</command></entry>

            <entry morerows="4">Less than or equal</entry>

            <entry>Integer &lt;= Integer</entry>

            <entry morerows="4">Boolean</entry>
          </row>

          <row>
            <entry>Integer &lt;= Number</entry>
          </row>

          <row>
            <entry>Number &lt;= Integer</entry>
          </row>

          <row>
            <entry>Number &lt;= Number</entry>
          </row>

          <row>
            <entry>Duration &lt;= Duration</entry>
          </row>

          <row>
            <entry morerows="4"><command>&gt;</command></entry>

            <entry morerows="4">Greater than</entry>

            <entry>Integer &gt; Integer</entry>

            <entry morerows="4">Boolean</entry>
          </row>

          <row>
            <entry>Integer &gt; Number</entry>
          </row>

          <row>
            <entry>Number &gt; Integer</entry>
          </row>

          <row>
            <entry>Number &gt; Number</entry>
          </row>

          <row>
            <entry>Duration &gt; Duration</entry>
          </row>

          <row>
            <entry morerows="4"><command>&gt;=</command></entry>

            <entry morerows="4">Greater than or equal</entry>

            <entry>Integer &gt;= Integer</entry>

            <entry morerows="4">Boolean</entry>
          </row>

          <row>
            <entry>Integer &gt;= Number</entry>
          </row>

          <row>
            <entry>Number &gt;= Integer</entry>
          </row>

          <row>
            <entry>Number &gt;= Number</entry>
          </row>

          <row>
            <entry>Duration &gt;= Duration</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Note: for relational operators, when comparing Integer to Number,
    the Integer will first be converted to Number.</para>

    <para>For example:</para>

    <programlisting>var x : Number = tonnage(current);
if (x &gt; 20) {
   println("It is big");
}</programlisting>

    <para>Note that, unlike Java, == and != are value comparisons, not
    identity comparisons. So, the following will work:</para>

    <programlisting>def input : String = userInput();
if (input == "dabnabit") {
   println("Censored");
}</programlisting>

    <para></para>
  </sect1>

  <sect1>
    <title>additiveExpression multiplicativeExpression (Two Argument
    Arithmetic Operations)</title>

    <para>These are arithmetic operations which take two operarands.</para>

    <figure>
      <title>additiveExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="additiveExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>multiplicativeExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="multiplicativeExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <table>
      <title>Binary Arithmetic Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center"> Operator</entry>

            <entry align="center">Meaning </entry>

            <entry align="center">Operand Types</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry morerows="4"><command>+</command></entry>

            <entry morerows="4">Add</entry>

            <entry>Integer + Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer + Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number + Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number + Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration + Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="4"><command>-</command></entry>

            <entry morerows="4">Subtract</entry>

            <entry>Integer - Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer - Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number - Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number - Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration - Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="7"><command>*</command></entry>

            <entry morerows="7">Multiply</entry>

            <entry>Integer * Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry>Integer * Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number * Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number * Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Integer * Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Number * Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration * Integer</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration * Number</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry morerows="6"><command>/</command></entry>

            <entry morerows="6">Divide</entry>

            <entry>Integer / Integer</entry>

            <entry>??? (under discussion -- see JFXC-1381)</entry>
          </row>

          <row>
            <entry>Integer / Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number / Integer</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Number / Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry>Duration / Integer</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration / Number</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry>Duration / Duration</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry><command>mod</command></entry>

            <entry>Modulo (sign of result not defined for negative
            operands)</entry>

            <entry>Integer mod Integer</entry>

            <entry>Integer</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Note: + does not operate over String.</para>

    <para>Note: Duration / Duration is not supported in V1.0</para>

    <para></para>
  </sect1>

  <sect1>
    <title>unaryExpression</title>

    <para></para>

    <figure>
      <title>unaryExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="unaryExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <table>
      <title>Prefix Unary Operator</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center">Operator</entry>

            <entry align="center">Meaning</entry>

            <entry align="center">Operand Type</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry morerows="2"><command>-</command></entry>

            <entry morerows="2">Negation</entry>

            <entry><command>-</command> Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>-</command> Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry><command>-</command> Duration</entry>

            <entry>Duration</entry>
          </row>

          <row>
            <entry><command>not</command></entry>

            <entry>Logical not</entry>

            <entry><command>not</command> Boolean</entry>

            <entry>Boolean</entry>
          </row>

          <row>
            <entry><command>sizeof</command></entry>

            <entry>Number of elements in a sequence</entry>

            <entry><command>sizeof</command> Object</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>reverse</command></entry>

            <entry>Reverse the elements in a sequence</entry>

            <entry><command>reverse</command> Object</entry>

            <entry>Object</entry>
          </row>

          <row>
            <entry morerows="1"><command>++</command></entry>

            <entry morerows="1">Add one to the value of the operand, value is
            updated value</entry>

            <entry><command>++</command> Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>++</command> Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry morerows="1"><command>--</command></entry>

            <entry morerows="1">Subtract one from the value of the operand,
            value is updated value</entry>

            <entry><command>--</command> Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>--</command> Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry><command>indexof</command></entry>

            <entry>Current position in the sequence being iterated</entry>

            <entry>n/a</entry>

            <entry>Integer</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>This example demonstrates the three sequence operators:</para>

    <programlisting>def endangered = ['Caribou', 'Ocelot', 'Puma', 'Sei'];
println( endangered );
def flipped = reverse endangered;
println( flipped );
println( sizeof endangered );
for (mammal in endangered) {
   println( 'Mammal #{ indexof mammal } is { mammal }' );
}
</programlisting>

    <para>The console shows the following:</para>

    <para><computeroutput>[ Caribou, Ocelot, Puma, Sei ]
    </computeroutput></para>

    <para><computeroutput>[ Sei, Puma, Ocelot, Caribou ]
    </computeroutput></para>

    <para><computeroutput>4 </computeroutput></para>

    <para><computeroutput>Mammal #0 is Caribou </computeroutput></para>

    <para><computeroutput>Mammal #1 is Ocelot </computeroutput></para>

    <para><computeroutput>Mammal #2 is Puma </computeroutput></para>

    <para><computeroutput>Mammal #3 is Sei</computeroutput></para>

    <para></para>
  </sect1>

  <sect1>
    <title>suffixedExpression</title>

    <para></para>

    <para></para>

    <figure>
      <title>suffixedExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="suffixedExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <table>
      <title>Postfix Increment/Decrement Operators</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry align="center">Operator</entry>

            <entry align="center">Meaning</entry>

            <entry align="center">Operand Type</entry>

            <entry align="center">Result Type</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry morerows="1"><command>++</command></entry>

            <entry morerows="1">Add one to the value of the operand, value is
            the previous value</entry>

            <entry><command>++</command> Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>++</command> Number</entry>

            <entry>Number</entry>
          </row>

          <row>
            <entry morerows="1"><command>--</command></entry>

            <entry morerows="1">Subtract one from the value of the operand,
            value is the previous value</entry>

            <entry><command>--</command> Integer</entry>

            <entry>Integer</entry>
          </row>

          <row>
            <entry><command>--</command> Number</entry>

            <entry>Number</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>This example contrasts these postfix increment/decrement operators
    with the prefix operators in unaryExpression:</para>

    <programlisting>var x = 0;
println( x++ );
println( ++x );
println( x-- );
println( --x );</programlisting>

    <para>The following is printed on the console:</para>

    <para><computeroutput>0 </computeroutput></para>

    <para><computeroutput>2 </computeroutput></para>

    <para><computeroutput>2 </computeroutput></para>

    <para><computeroutput>0</computeroutput></para>

    <para></para>
  </sect1>

  <sect1>
    <title>postfixExpression</title>

    <para></para>

    <para></para>

    <figure>
      <title>postfixExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="postfixExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <sect2>
      <title>Member Access</title>

      <para>Access a member (variable or function) of a class instance.</para>

      <figure>
        <title>postfixExpression [Member Access clause]</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="memberAccess.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This example shows member access using a dot of both a variable
      (<command>aPair.good</command>) and a instance function
      (<command>aPair.topsy()</command>):</para>

      <programlisting>class Pair {
   var good : String;
   var bad : String;
   function topsy() {
      def tmp = good;
      good = bad;
      bad = tmp;
   }
}
def aPair = Pair {
   good: 'Sunflower Sprouts'
   bad: 'Lard'
}
println( aPair.good );
aPair.topsy();
println( aPair.good );
</programlisting>

      <para>It will print:</para>

      <para><computeroutput>Sunflower Sprouts </computeroutput></para>

      <para><computeroutput>Lard</computeroutput></para>

      <para></para>
    </sect2>

    <sect2>
      <title>Function Invocation</title>

      <para>Function invocation, also known as function call, is how functions
      are, well..., called.</para>

      <para></para>

      <figure>
        <title>postfixExpression [Function Invocation clause]</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="functionInvocation.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title></title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="expressionList.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This is an example of calling a script function, see the Member
      Access section (above) for an example of calling an instance
      function:</para>

      <programlisting>function squared(x : Number) : Number { x * x }
println( squared(14,2) );</programlisting>

      <para></para>
    </sect2>

    <sect2>
      <title>Sequence Select</title>

      <para>A sequence select expression evaluates to a new sequence
      containing selected elements of another sequence.</para>

      <figure>
        <title>postfixExpression [Sequence Select clause]</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="sequenceSelect.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Elements are included in the resulting sequence if the Boolean
      <emphasis>valueExpression</emphasis> evaluates to true. The
      <emphasis>name</emphasis> provides a name for each element for use in
      the <emphasis>valueExpression</emphasis>. For example:</para>

      <programlisting>def seq = [1..100];
def selected = seq[x | (x*x) &lt; 20];
println( selected );</programlisting>

      <para>The selected elements of seq are those whose square is less than
      20. So the following is printed:</para>

      <para><computeroutput>[ 1, 2, 3, 4 ]</computeroutput></para>

      <para>Note that this selection could also have been done with the
      equivalent <command>for</command>-expression:</para>

      <programlisting>def selected = for (x in seq where (x*x) &lt; 20) x;</programlisting>

      <para></para>
    </sect2>

    <sect2>
      <title>Sequence Indexing</title>

      <para>A sequece indexing expression accesses a single element of a
      sequence at the supplied index. If no element exists at that index, the
      sequece indexing expression will evaluate to the default value for the
      elemebt specifier of the sequence.</para>

      <figure>
        <title>postfixExpression [Index clause]</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="index.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>For example:</para>

      <programlisting>def seq = [100..105];
println( seq[0] );
println( seq[3] );
println( seq[22] );
println( seq[-1] );</programlisting>

      <para>Here the element specifier of seq is Integer, so the following is
      printed -- since zero is the default value of Integer:</para>

      <para><computeroutput>100 </computeroutput></para>

      <para><computeroutput>103 </computeroutput></para>

      <para><computeroutput>0 </computeroutput></para>

      <para><computeroutput>0</computeroutput></para>

      <para>The type of a sequece indexing expression is that of the indexed
      sequence's element specifier (the element type).</para>
    </sect2>

    <sect2>
      <title>Sequence Slice</title>

      <para>A sequence slice expression evaluates to a sequence a portion of
      another sequence. Those elements by specifying a range of
      indicies.</para>

      <figure>
        <title>postfixExpression [Slice clause]</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="slice.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The two <emphasis>valueExpression</emphasis>s give the beginning
      and ending of the range. The beginning is always inclusive, the ending
      of the range is inclusive unless the less-than sign is used. The ending
      <emphasis>valueExpression</emphasis> is optional, and if absent, the
      ending of the range is the last index of the sequence. For
      example:</para>

      <programlisting>def usprez = ['Washington', 'Adams', 'Jefferson', 'Madison', 'Monroe'];
println( usprez[1..3] );
println( usprez[1..&lt;3] );
println( usprez[3..] );
println( usprez[3..&lt;] );
</programlisting>

      <para>Will print to the console:</para>

      <para><computeroutput>[ Adams, Jefferson, Madison ]
      </computeroutput></para>

      <para><computeroutput>[ Adams, Jefferson ] </computeroutput></para>

      <para><computeroutput>[ Madison, Monroe ] </computeroutput></para>

      <para><computeroutput>[ Madison ]</computeroutput></para>

      <para>The type of a sequence slice expression is the type of the
      sequence to which the slice clause is applied.</para>
    </sect2>
  </sect1>

  <sect1>
    <title>primaryExpression</title>

    <para></para>

    <para></para>

    <figure>
      <title>primaryExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="primaryExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <para></para>

    <sect2>
      <title>qualifiedName</title>

      <para>A qualified name is a reference to a package or class by a dot
      separated list of package and subpackage names.</para>

      <figure>
        <title>qualifiedName</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="qualifiedName.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para><command>java.lang.Object</command> is a qualified name
      referencing the Object class in the lang subpackage of the java package.
      These are some ways that qualified names are used:</para>

      <programlisting>import java.util.GregorianCalendar;
class FooWriter extends java.io.PrintWriter {}
var baseFile = new java.io.File("base.txt");
</programlisting>

      <para></para>
    </sect2>

    <sect2>
      <title>objectLiteral</title>

      <para>An object literal is the primary way that new instances of a class
      are created in JavaFX Script. They also allow adding new functionality
      to the instance including functions and additional on-replace clauses on
      instance variables.</para>

      <figure>
        <title>objectLiteral</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="objectLiteral.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>objectLiteralPart</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="objectLiteralPart.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>objectLiteralInit</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="objectLiteralInit.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <emphasis>qualifiedName</emphasis> must reference a JavaFX
      Script class.</para>

      <para>For these examples assume a Point class defined like this:</para>

      <programlisting>class Point {
   var x : Number;
   var y : Number;
}
</programlisting>

      <para>An object literal creates an instance of the class and sets the
      initial values of instance variables:</para>

      <programlisting>def somewhere = Point {
   x: 3.2
   y: 7.8
}
</programlisting>

      <para>Note that the instance variable initializers may be written in any
      order and that the initializing expressions are evaluated in the order
      wriitten. </para>

      <para>An object literal need not provide initializers for instance
      variables, though some classes may require certain instance variables to
      be initialized for proper functioning of an instance. Thus these are
      valid:</para>

      <programlisting>def default = Point {}
def high = Point {
   y: 92.1
}</programlisting>

      <para>See the classes chapter for more information on instance variable
      initialization.</para>

      <para>Variables and functions local to the object literal may be
      supplied to assist in its construction. Here, the local variable radius
      is defined.</para>

      <programlisting>def location = Point {
   var radius = 10.3;
   x: radius * 2
   y: radius * 5
}
</programlisting>

      <para>Often local variables are used in the construction of nested
      object literals to allow cross-referencing.</para>

      <para>Additional on-replace clauses may added by overriding an instance
      variable:</para>

      <programlisting>def current = Point {
   override var x on replace { println( "Changed x to {x}" ) }
   override var y on replace { println( "Changed y to {y}" ) }
   x: 66.6
   y: 33.3
}
current.x = 99.9;</programlisting>

      <para>This will print:</para>

      <para><computeroutput>Changed x to 66.6 </computeroutput></para>

      <para><computeroutput>Changed y to 33.3 </computeroutput></para>

      <para><computeroutput>Changed x to 99.9</computeroutput></para>

      <para>The instance variable initiailizer can be a unidirectionally or
      bidirectionally bound expression, as this object literal (which keeps
      its Point on a circle) demonstrates:</para>

      <programlisting>import java.lang.Math.*;
var angle = 0.0;
def onCircle = Point {
   x: bind cos(angle)
   y: bind sin(angle)
   override function toString() : String { "Point({%4.1f x}, {%4.1f y})" }
}
println( onCircle );
angle = 0.5 * PI;
println( onCircle );
angle = PI;
println( onCircle );
angle = 1.5 * PI;
println( onCircle );
angle = 2 * PI;
println( onCircle );
</programlisting>

      <para>The x instance variable of onCircle will be maintained as the
      cosine of the angle, while y will be maintained as the sine. See the
      Binding chapter for more information of bind. The toString() function
      (defined on Object) has been overridden in the object literal to provide
      a better output format. This is what is printed to the console:</para>

      <para><computeroutput>Point( 1.0, 0.0) </computeroutput></para>

      <para><computeroutput>Point( 0.0, 1.0) </computeroutput></para>

      <para><computeroutput>Point(-1.0, 0.0) </computeroutput></para>

      <para><computeroutput>Point(-0.0, -1.0) </computeroutput></para>

      <para><computeroutput>Point( 1.0, -0.0)</computeroutput></para>

      <para>The value of an object literal is the new instance. The type of an
      object literal is the class given in the
      <emphasis>qualifiedName</emphasis>.</para>
    </sect2>

    <sect2>
      <title><command>this</command></title>

      <para>The <command>this</command> expression is a reference to the
      current instance.</para>

      <para><remark>[To do: add examples, syntax diagram,
      description]</remark></para>

      <para></para>
    </sect2>

    <sect2>
      <title>stringExpression</title>

      <para></para>

      <para></para>

      <figure>
        <title>simplfied StringExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="stringExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Where the two QUOTE tokens are matching single or double
      quote.</para>

      <para>Like string literals, adjacent string expressions (and string
      literals) are automatically concatenated at compile time.</para>

      <para><remark>[To do: describe portable Formatter that handles the
      common subset]</remark></para>

      <para></para>
    </sect2>

    <sect2>
      <title>explicitSequenceExpression</title>

      <para>Creates a sequence by explicitly listing the elements of the
      sequence.</para>

      <para></para>

      <figure>
        <title>explicitSequenceExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="explicitSequenceExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>rangeExpression</title>

      <para>Creates a sequence which is a range of Integer or Number
      values.</para>

      <figure>
        <title>rangeExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="rangeExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>block</title>

      <para></para>

      <para></para>

      <figure>
        <title>block</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="block.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para></para>
    </sect2>

    <sect2>
      <title>literal</title>

      <para></para>

      <para></para>

      <figure>
        <title>literal</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="literal.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>functionExpression</title>

      <para></para>

      <para></para>

      <figure>
        <title>functionExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="functionExpression.jpeg"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>formalParameters</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameters.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>formalParameter</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameter.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>

    <sect2>
      <title>timelineExpression</title>

      <para></para>

      <para></para>

      <figure>
        <title>timelineExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="timelineExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>keyFrameLiteralPart</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="keyFrameLiteralPart.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>
    </sect2>
  </sect1>
</chapter>
