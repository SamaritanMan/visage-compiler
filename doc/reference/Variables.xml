<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Variables</title>

  <para>The declaration, use and scope of variables.</para>

  <sect1>
    <title>def and var</title>

    <para>Variables are declared with two keywords: def and var. Variables
    which are defined once and are never assigned to are defined with
    def.</para>

    <para><programlisting>def Z0 = 376.730313;</programlisting></para>

    <para>Note that a bound variable (without inverse) is defined once and can
    never be assigned. It to should be declared with def:</para>

    <para><programlisting>def x = bind y + z;</programlisting></para>

    <para>See the Binding chapter.</para>

    <para>Variables that will or can be assigned to should be declared with
    var:</para>

    <para><programlisting>var x = 0; 
++x;</programlisting></para>

    <para>Be sure to use <command>def</command> when the intend is that it is
    a definition with will not change. Doing so is a useful tool that allows
    the compiler to generate more efficient code and to better check the
    correctness of programs. Using <command>def</command> is also important
    for readers of this code (or documentation generated from it) helping them
    understand what can change, and what cannot.</para>
  </sect1>

  <sect1>
    <title>Kinds of Variables</title>

    <para>Variables can be declared at the script level (script variable),
    inside a class (instance variable), or within blocks (local
    variable)</para>

    <para></para>

    <sect2>
      <title>Script Variables</title>

      <para>Script variables are variable which are declared at the top-level
      of a script (as opposed to inside a class definition or block). Script
      variables are visible through-out the entire script -- a member access
      expression is not needed.</para>

      <para><programlisting>var thing = "Thing"; 
class A { 
   function getThing() : String { thing } 
}</programlisting></para>

      <para>Without an added access modifer, script variables are not visible
      outside the script. If access modifiers are added which make the script
      variable visible outside the script, they may be accessed as members of
      the script. For example, if this is script Foo.fx:</para>

      <para><programlisting>public def bohr = 0.529177e-10</programlisting></para>

      <para>Then script Bar.fx can access bohr:</para>

      <para><programlisting>println(Foo.bohr)</programlisting></para>

      <para>The lifetime of a script variable is from the time the script is
      loaded until the end of program execution.</para>

      <para></para>
    </sect2>

    <sect2>
      <title>Instance Variables</title>

      <para>Instance variables are declared at the top-level of a class.
      Within the declaring class (and its subclasses</para>

      <para><programlisting>def anA = A{ rat: true }; 
println(anA.rat); 
class A { 
   var rat : Boolean; 
   function isIt() { rat }  
}  
class B { 
   function wellisIt() { anA.rat } 
}</programlisting></para>

      <para>Access modifiers control the visiblity of instance variables. If
      no access modifersXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</para>

      <para>The lifetime of an instance variable is the lifetime of the class
      instance.</para>
    </sect2>

    <sect2>
      <title>Local Variables</title>

      <para>Local variables are declared within blocks, including blocks which
      are the bodies of functions. Local variables are visible only within the
      inner-most block -- their scope includes the entire body of that block
      (not just below the variable declaration). Member access expressions are
      not applicable to local variables. Access modifiers must not be applied
      to local variable declarations.</para>

      <para>The lifetime of a local variable ends when the block is
      exited.</para>

      <para>Local variable declarations are both declarations and expressions,
      that is, they have type and value.</para>

      <para></para>
    </sect2>

    <sect2>
      <title>Parameters, Induction Variables, and other Expression
      Parameters</title>

      <para>Function parameters are visible only within the function body.
      For-expression induction variables are visible only within the
      for-expression body. The scope of other expression parameters is their
      expression.</para>

      <para>They must not be assigned to.</para>

      <para>See Function, the For section of expressions, and On Replace
      (below) for syntax.</para>

      <para></para>
    </sect2>
  </sect1>

  <sect1>
    <title>Syntax of Variable Declarations</title>

    <para></para>

    <figure>
      <title>variableDeclaration</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="variableDeclaration.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>typeSpecifier</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="typeSpecifier.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <figure>
      <title>initializingExpression</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="initializingExpression.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para></para>

    <figure>
      <title>onReplaceClause</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="onReplaceClause.png"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>While syntactically optional, an
    <emphasis>initializingExpression</emphasis> is required with
    <command>def</command>.</para>

    <para>When <command>bind</command> is specified in the
    <emphasis>initializingExpression</emphasis> the variable is kept updated
    to the value of the <emphasis>expression</emphasis>. When <command>with
    inverse</command> is specified, the <emphasis>expression</emphasis> must
    be a simple variable reference and that variable is kept updated when the
    variable being declared is changed. See the Binding chapter for
    details.</para>

    <para></para>
  </sect1>

  <sect1>
    <title>On Replace</title>

    <para>The <emphasis>onReplaceClause</emphasis>, if present, causes the
    block to be executed each time the value of the variable changes --
    including the assignment of its initial value.</para>

    <para>The optional parameters provide information about what is changed:
    <command>on replace</command> <emphasis>oldValue</emphasis>
    <command>[</command> <emphasis>firstIndex</emphasis> <command>..</command>
    <emphasis>lastIndex</emphasis><command> ] =</command>
    <emphasis>newElements</emphasis> <command>{</command> ...
    <command>}</command></para>

    <para>But these parameters are all optional, in the simplest form none of
    these are present:</para>

    <para><programlisting>var x = 0 on replace { println("x is now: {x}") }</programlisting></para>

    <para>The <emphasis>oldValue</emphasis> parameter provides the previous
    value.</para>

    <para><programlisting>var x = 0 on replace oldValue { println("x was {oldValue} and is now: {x}") }</programlisting></para>

    <para>The remaining parameters are useful with sequences.</para>

    <para><programlisting>var seq = ['A', 'B', 'C', 'D', 'E', 'F'] on replace oldValue[firstIdx .. lastIdx] = newElements { 
    println("replaced {oldValue}[{firstIdx}..{lastIdx}] by {newElements} yielding {seq}") 
} 
seq[3] = '$'; 
insert '#' into seq; 
delete '$' from seq; 
delete seq[2]; 
seq[1..4] = ['X', 'Y']; 
delete seq; </programlisting></para>

    <para>Which prints:</para>

    <screen>replaced [0..-1] by ABCDEF yielding ABCDEF
replaced ABCDEF[3..3] by $ yielding ABC$EF
replaced ABC$EF[6..5] by # yielding ABC$EF#
replaced ABC$EF#[3..3] by  yielding ABCEF#
replaced ABCEF#[2..2] by  yielding ABEF#
replaced ABEF#[1..4] by XY yielding AXY
replaced AXY[0..2] by  yielding</screen>

    <para>Note that <emphasis>firstIndex</emphasis>,
    <emphasis>lastIndex</emphasis> and <emphasis>newElements</emphasis> refer
    only to the portion of the sequence which has changed,</para>

    <para></para>

    <para></para>
  </sect1>
</chapter>
