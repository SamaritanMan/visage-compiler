<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>JavaFX Language Reference</title>

    <author>
      <personname><firstname>Robert</firstname><surname>Field</surname></personname>

      <affiliation>
        <orgname>Sun Microsystems</orgname>
      </affiliation>
    </author>

    <pubdate></pubdate>
  </info>

  <chapter>
    <title>Introduction</title>

    <para>Discusses the what and why of JavaFX Script, and then provides
    examples to give you an overview.</para>

    <sect1>
      <title>Why JavaFX Script?</title>

      <para>There are thousands of programming languages, why use JavaFX? Two
      reasons: ubiquitous delivery and rapid development of graphical
      applications. JavaFX is built on the Java platform which is available on
      everything from cell phones to supercomputers. JavaFX is designed so
      that the developer can express their desired results succinctly and
      simply. Much can be expressed declaratively, including the interactive
      relationships between components, greatly easing development
      complexity.</para>
    </sect1>

    <sect1>
      <title>What is JavaFX Script?</title>

      <para>JavaFX Script is a scripting language which means it provides fast
      and easy development with less of the armor provided by conventional
      languages. It is thus tailored to moderately sized interactive graphical
      applications rather than programming in the large. It does, however,
      have one of the most important advantages of compile-time typing. That
      is, before your program even runs, it is checked for incompatible
      relationships between data.</para>
    </sect1>

    <sect1>
      <title>A Taste of JavaFX Script</title>

      <para>But the best way to get the idea of JavaFX Script is to see some
      examples. Don't worry if some of these don't make sense, the rest of
      this Reference will provide the details.</para>

      <para>JavaFX Script programs are written as one or more
      <emphasis>scripts</emphasis>. A script consists of expressions and
      declarations, typically in a file. The following is an expression and
      thus a valid script:</para>

      <programlisting>4</programlisting>

      <para>But it doesn't do anything. So, we could print it using the
      built-in function 'println':</para>

      <programlisting>println(4)</programlisting>

      <para>Which makes it irresistible to show the Hello World script:</para>

      <programlisting>println("Hello, World")</programlisting>

      <para>Which really isn't in the spirit of JavaFX since it isn't
      graphical. Refer to the graphics tutorial for that.</para>

      <para>You can, of course, have more complex expressions:</para>

      <programlisting>println("Circumference is { 2*3.1415*7 } ")</programlisting>

      <para>Note that the expression enclosed in braces is computed at runtime
      and inserted into the string. But this would be more interesting if we
      used variables:</para>

      <programlisting>def PI = 3.14159265; 
var r = 7; 
println("Circumference is { 2 * PI * r } ")</programlisting>

      <para>You can define a function:</para>

      <programlisting>def PI = 3.14159265; 
var r = 7; 
function circumference(radius) { 2 * PI * radius }
println("Circumference is { circumference(r) } ")</programlisting>

      <para>Note that JavaFX Script uses type inference to figure out the type
      of variables and function. Without type inference, this would be
      written:</para>

      <programlisting>def PI : Number = 3.14159265;  
var r : Number = 7; 
function circumference(radius : Number) : Number {
   2 * PI * radius 
} 
println("Circumference is { circumference(r) }")</programlisting>

      <para>You can define a class to represent a real or abstract entity. In
      this case, a point:</para>

      <programlisting>class Point { 
   var x : Integer; 
   var y : Integer; 
   function show() {
      println("Point {x}, {y}")
   } 
} </programlisting>

      <para>This class defines the x and y coordinates and a function to
      display the Point.</para>

      <para>We can create an instance of the Point and assign it to a variable
      like this:</para>

      <programlisting>var myPoint = Point { 
   x: 12
   y: 9
}</programlisting>

      <para>Note that the x and y instance variables are set during
      creation.</para>

      <para>Finally we can ask the point to show itself.</para>

      <programlisting>myPoint.show()</programlisting>

      <para>For an example-based introduction to JavaFX see the JavaFX Script
      Tutorial.</para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Types and Values</title>

    <para>Covers the data types and values which can be represented and
    manipulated in JavaFX Script</para>

    <sect1>
      <title>JavaFX Script Data Types</title>

      <para>The Void type is an odd duck that is only used to indicate that a
      function does not return a value, the remainder of this chapter excludes
      Void.</para>

      <para>JavaFX Script Data Types, hereafter called JavaFX Types , consist
      of an <emphasis>element specifier</emphasis> and a
      <emphasis>cardinality</emphasis>. The element specifier determines what
      the type holds and the cardinality determines how many of them can be
      held.</para>

      <sect2>
        <title>Element Specifier</title>

        <para>Element specifiers are classes or function signatures. Classes
        include both JavaFX classes and Java classes. A function signature
        consists of the parameter types and return type -- function signatures
        are unnamed and are not tied to particular functions which might
        implement the signature. All element specifiers are subtypes of
        java.lang.Object.</para>

        <para>[In formal type systems this would be called the
        <emphasis>ground type</emphasis>]</para>
      </sect2>

      <sect2>
        <title>Cardinality</title>

        <para>The cardinality of a type determines how many elements can be
        held in a JavaFX type. The three cardinalities are
        <emphasis>optional</emphasis>, <emphasis>required</emphasis>, and
        <emphasis>sequence</emphasis>.</para>

        <sect3>
          <title>Cardinality: Optional (0 or 1)</title>

          <para>Optional cardinality means there can be one element or no
          elements. This is the cardinality associated with most types,
          currently including all user defined classes. If you define a class
          Foo, then the JavaFX type "Foo" has class Foo as its element
          specifier and optional as its cardinality. For example:</para>

          <programlisting>var x : Foo;</programlisting>

          <para>Says that x can hold an instance of Foo (one element) or can
          hold null, the nonexistent value (no elements).</para>
        </sect3>

        <sect3>
          <title>Cardinality: Required (1)</title>

          <para>Required cardinality means there must be one element. This is
          the cardinality associated with the built-in types String, Integer,
          Number, Boolean, and Duration. For example:</para>

          <programlisting>var k : Integer;</programlisting>

          <para>Says that k holds one Integer.</para>

          <para>The nonexistent value, null, is not a permitted value for
          types with required cardinality. Attempts to assign null to a type
          with required cardinality will be converted to the default value
          (see below). Attempts to convert null to a type with required
          cardinality will also be converted to the default value.</para>
        </sect3>

        <sect3>
          <title>Cardinality: Sequence (0-n)</title>

          <para>Sequence cardinality means there can be any number of
          elements, including zero. This is the cardinality associated with
          explicitly declared sequences. For example:</para>

          <programlisting>var seq : Integer[];</programlisting>

          <para>Says that seq can hold any number of Integers.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Default Values</title>

      <para>Each JavaFX type has an associated default value. The default
      variable is the value of a variable before it is set. It is also the
      value of an expression of that type if an error is encountered For types
      with optional cardinality their default value is null. For
      example:</para>

      <programlisting>var x : Foo; 
println(x);</programlisting>

      <para>Will print null since x has not been set.</para>

      <para>For types with sequence cardinality their default value is the
      empty sequence of their element specifier. For example:</para>

      <programlisting>var seq : Integer[]; 
println(sizeof seq);</programlisting>

      <para>Will print zero as the size of seq since seq has not been set and
      its initial value will be an empty sequence of Integer.</para>

      <para>Each required type has its own default value, as shown in the
      table below.</para>

      <programlisting>var k : Integer; 
println(k);</programlisting>

      <para>Will print zero since k has not been set and the default value for
      Integer is 0.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>Built-in Types</title>

      <para></para>

      <sect2>
        <title>String</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Integer</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Number</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Boolean</title>

        <para></para>
      </sect2>

      <sect2>
        <title>Duration</title>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Sequence Types</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Function Types</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Type Chart</title>

      <para></para>

      <table>
        <title></title>

        <tgroup cols="6">
          <colspec colname="t2" />

          <colspec colname="decl" />

          <colspec colname="dflt" />

          <colspec colname="element" />

          <colspec colname="card" />

          <colspec colname="lit" />

          <thead>
            <row>
              <entry align="center"><para>Type</para></entry>

              <entry align="center"><para>Declaration</para></entry>

              <entry align="center"><para>Default Value</para></entry>

              <entry align="center"><para>Element Specifier</para></entry>

              <entry align="center"><para>Cardinality</para></entry>

              <entry align="center"><para>Literal or Creation
              Examples</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><literal>Object</literal></para></entry>

              <entry><para><literal>: Object</literal></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><literal>java.lang.Object</literal></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>new Object</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>String</literal></para></entry>

              <entry><para><literal>: String</literal></para></entry>

              <entry><para><literal>""</literal></para></entry>

              <entry><para><literal>java.lang.String</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>"Brownian"</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Integer</literal></para></entry>

              <entry><para><literal>: Integer</literal></para></entry>

              <entry><para>0</para></entry>

              <entry><para><literal>java.lang.Integer</literal></para></entry>

              <entry><para><literal>1 Required</literal></para></entry>

              <entry><para><literal>1956</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Number</literal></para></entry>

              <entry><para><literal>: Number</literal></para></entry>

              <entry><para><literal>0.0</literal></para></entry>

              <entry><para><literal>java.lang.Double</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>1.4142</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Boolean</literal></para></entry>

              <entry><para><literal>: Boolean</literal></para></entry>

              <entry><para><literal>false</literal></para></entry>

              <entry><para><literal>java.lang.Boolean</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>true</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Duration</literal></para></entry>

              <entry><para><literal>: Duration</literal></para></entry>

              <entry><para><literal>0ms</literal></para></entry>

              <entry><para><literal>javafx.lang.Duration</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>47s</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>other class
              types</emphasis></para></entry>

              <entry><para><literal>:
              </literal><emphasis>ClassName</emphasis></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><emphasis>ClassName</emphasis></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>Point {x: 3 y: 9}</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>function types</emphasis></para></entry>

              <entry><para><literal>:
              function(</literal><emphasis>name</emphasis><literal> :
              </literal><emphasis>ParamType</emphasis><literal>,
              </literal><emphasis>...</emphasis><literal>) : </literal>
              <emphasis>ReturnType</emphasis></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><literal>function(</literal><emphasis>name</emphasis><literal>
              : </literal><emphasis>ParamType</emphasis><literal>,
              </literal><emphasis>...</emphasis><literal>) : </literal>
              <emphasis>ReturnType</emphasis></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>function(x:Integer):String {" {x}
              "}</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>sequence types</emphasis></para></entry>

              <entry><para><literal>:
              </literal><emphasis>ElementSpec</emphasis><literal>[]</literal></para></entry>

              <entry><para><literal>[]</literal></para></entry>

              <entry><para><emphasis>ElementSpec</emphasis></para></entry>

              <entry><para>0-n Sequence</para></entry>

              <entry><para><literal>[9, 14, 21, 4]</literal></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Expressions</title>

    <para>The miriad ways that expressions can be form are described.</para>

    <sect1>
      <title>Operators</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Function Invocation</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Member Access</title>

      <para></para>
    </sect1>

    <sect1>
      <title>String Expressions</title>

      <para></para>

      <sect2>
        <title>Translation Keys</title>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Object Literals</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Creation</title>

      <para></para>
    </sect1>

    <sect1>
      <title>This</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Blocks</title>

      <para></para>
    </sect1>

    <sect1>
      <title>If</title>

      <para></para>
    </sect1>

    <sect1>
      <title>While</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Return</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Break</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Continue</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Try-Catch-Finally</title>

      <para></para>
    </sect1>

    <sect1>
      <title>For</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Access</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Modification</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Timelines</title>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Variables</title>

    <para>The declaration, use and scope of variables.</para>

    <sect1>
      <title>def and var</title>

      <para>Variables are declared with two keywords: def and var. Variables
      which are defined once and are never assigned to are defined with
      def.</para>

      <para><programlisting>def Z0 = 376.730313;</programlisting></para>

      <para>Note that a bound variable (without inverse) is defined once and
      can never be assigned. It to should be declared with def:</para>

      <para><programlisting>def x = bind y + z;</programlisting></para>

      <para>See the Binding chapter.</para>

      <para>Variables that will or can be assigned to should be declared with
      var:</para>

      <para><programlisting>var x = 0; 
++x;</programlisting></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Kinds of Variables</title>

      <para>Variables can be declared at the script level (script variable),
      inside a class (instance variable), or within blocks (local
      variable)</para>

      <para></para>

      <sect2>
        <title>Script Variables</title>

        <para>Script variables are declared at the top-level of a script, not
        inside a class definition. Script variables are visible through-out
        the entire script -- a member access expression is not needed.</para>

        <para><programlisting>var thing = "Thing"; 
class A { 
   function getThing() : String { thing } 
}</programlisting></para>

        <para>If access modifiers are added which make the script variable
        visible outside the script, they may be accessed as members of the
        script. For example, if this is script Foo.fx:</para>

        <para><programlisting>public def bohr = 0.529177e-10</programlisting></para>

        <para>Then script Bar.fx can access bohr:</para>

        <para><programlisting>println(Foo.bohr)</programlisting></para>

        <para>The lifetime of a script variable is from the time the script is
        loaded until the end of program execution.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Instance Variables</title>

        <para>Instance variables are declared at the top-level of a class.
        Instance variables are visible through-out the entire script -- a
        member access expression is not needed within the class but is needed
        outside of the class.</para>

        <para><programlisting>def anA = A{ rat: true }; 
println(anA.rat); 
class A { 
   var rat : Boolean; 
   function isIt() { rat }  
}  
class B { 
   function wellisIt() { anA.rat } 
}</programlisting></para>

        <para>The lifetime of an instance variable is the lifetime of the
        class instance.</para>
      </sect2>

      <sect2>
        <title>Local Variables</title>

        <para>Local variables are declared within blocks, including blocks
        which are the bodies of functions. Local variables are visible only
        within the inner-most block -- their scope includes the entire body of
        that block (not just below the variable declaration). Member access
        expressions are not applicable to local variables. Access modifiers
        must not be applied to local variable declarations.</para>

        <para>The lifetime of a local variable ends when the block is
        exited.</para>

        <para>Local variable declarations are both declarations and
        expressions, that is, they have type and value.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Parameters, Induction Variables, and other Expression
        Parameters</title>

        <para>Function parameters are visible only within the function body.
        For-expression induction variables are visible only within the
        for-expression body. The scope of other expression parameters is their
        expression.</para>

        <para>They must not be assigned to.</para>

        <para>See Function, the For section of expressions, and On Replace
        (below) for syntax.</para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Syntax of Variable Declarations</title>

      <para></para>

      <figure>
        <title>variableDeclaration</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="variableDeclaration.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>typeSpecifier</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="typeSpecifier.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>initializingExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="initializingExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>onReplaceClause</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="onReplaceClause.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>While syntactically optional, an
      <emphasis>initializingExpression</emphasis> is required with
      <command>def</command>.</para>

      <para>When <command>bind</command> is specified in the
      <emphasis>initializingExpression</emphasis> the variable is kept updated
      to the value of the <emphasis>expression</emphasis>. When <command>with
      inverse</command> is specified, the <emphasis>expression</emphasis> must
      be a simple variable reference and that variable is kept updated when
      the variable being declared is changed. See the Binding chapter for
      details.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>On Replace</title>

      <para>The <emphasis>onReplaceClause</emphasis>, if present, causes the
      block to be executed each time the value of the variable changes --
      including the assignment of its initial value.</para>

      <para>The optional parameters provide information about what is changed:
      <command>on replace</command> <emphasis>oldValue</emphasis>
      <command>[</command> <emphasis>firstIndex</emphasis>
      <command>..</command> <emphasis>lastIndex</emphasis><command> ]
      =</command> <emphasis>newElements</emphasis> <command>{</command> ...
      <command>}</command></para>

      <para>But these parameters are all optional, in the simplest form none
      of these are present:</para>

      <para><programlisting>var x = 0 on replace { println("x is now: {x}") }</programlisting></para>

      <para>The <emphasis>oldValue</emphasis> parameter provides the previous
      value.</para>

      <para><programlisting>var x = 0 on replace oldValue { println("x was {oldValue} and is now: {x}") }</programlisting></para>

      <para>The remaining parameters are useful with sequences.</para>

      <para><programlisting>var seq = ['A', 'B', 'C', 'D', 'E', 'F'] on replace oldValue[firstIdx .. lastIdx] = newElements { 
    println("replaced {oldValue}[{firstIdx}..{lastIdx}] by {newElements} yielding {seq}") 
} 
seq[3] = '$'; 
insert '#' into seq; 
delete '$' from seq; 
delete seq[2]; 
seq[1..4] = ['X', 'Y']; 
delete seq; </programlisting></para>

      <para>Which prints:</para>

      <screen>replaced [0..-1] by ABCDEF yielding ABCDEF
replaced ABCDEF[3..3] by $ yielding ABC$EF
replaced ABC$EF[6..5] by # yielding ABC$EF#
replaced ABC$EF#[3..3] by  yielding ABCEF#
replaced ABCEF#[2..2] by  yielding ABEF#
replaced ABEF#[1..4] by XY yielding AXY
replaced AXY[0..2] by  yielding</screen>

      <para>Note that <emphasis>firstIndex</emphasis>,
      <emphasis>lastIndex</emphasis> and <emphasis>newElements</emphasis>
      refer only to the portion of the sequence which has changed,</para>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Functions</title>

    <para></para>

    <para></para>

    <sect1>
      <title>Function Syntax</title>

      <para></para>

      <figure>
        <title>functionDefinition</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="functionDefinition.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>formalParameters</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameters.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>formalParameter</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameter.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>typeSpecifier</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="typeSpecifier.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </sect1>

    <sect1>
      <title>Kinds of Functions</title>

      <para>Functions can be declared at the script level (script function) or
      inside a class (instance function). Local functions are not yet
      supported.</para>

      <para></para>

      <sect2>
        <title>Script Functions</title>

        <para>Script functions are declared at the top-level of a script, not
        inside a class definition. Script functions are visible through-out
        the entire script -- a member access expression is not needed.</para>

        <para><programlisting>function square(x : Number) : Number { x * x }
println( square(7) )</programlisting></para>

        <para>If access modifiers are added which make the script function
        visible outside the script, they may be accessed as members of the
        script. For example, if this is script Foo.fx:</para>

        <para><programlisting>public function square(x : Number) : Number { x * x }</programlisting></para>

        <para>Then script Bar.fx can access bohr:</para>

        <para><programlisting>println(Foo.square(10))</programlisting></para>
      </sect2>

      <sect2>
        <title>Instance Functions</title>

        <para>Instance functions are declared at the top-level of a class.
        Instance functions are visible through-out the entire script -- a
        member access expression is not needed within the class but is needed
        outside of the class.</para>

        <para><programlisting>class Scale { 
   var factor : Number; 
   function transform(x : Number) : Number { factor * x } 
} 
var tf = Scale { factor: 25.0 } 
println(tf.transform(10.0)</programlisting></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Type Inference</title>

      <para>Type inferencing can generally determine the return type of a
      function. In most cases the parameter types can be determined by type
      inference as well.</para>

      <para>However, functions which, by virtue of their access modifiers, are
      visible outside the script should be explicitly typed.</para>
    </sect1>

    <sect1>
      <title>Bound Functions</title>

      <para>The modifier <command>bound</command> is only allowed on
      functions, such functions are called <emphasis>bound
      functions</emphasis>. Bound functions are covered in the Binding
      chapter.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>Parameter passing</title>

      <para>When called in a bound context, the parameters of a bound function
      are passed by reference and the return value is by reference as well. In
      all other cases, non-bound functions and bound functions called form
      non-bound contexts, parameters are passed by value and the the return
      value is by value.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>Overriding Functions</title>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Classes</title>

    <para></para>

    <para></para>

    <sect1>
      <title>Syntax of Class Definition</title>

      <para></para>

      <figure>
        <title>classDefinition</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="classDefinition.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para></para>

      <figure>
        <title>superclasses</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="superclasses.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Class Members</title>

      <para></para>

      <figure>
        <title>classMember</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="classMember.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para><emphasis>functionDefinition</emphasis> and
      <emphasis>variableDeclaration</emphasis> are covered in their respective
      chapters. The remaining class members are covered below.</para>

      <para></para>

      <sect2>
        <title><command>init</command> Block</title>

        <para></para>

        <para></para>

        <figure>
          <title>initBlock</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="initDefinition.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The <emphasis>initBlock</emphasis> is an optional block of code
        which is executed as the final step of class initialization.</para>
      </sect2>

      <sect2>
        <title><command>postinit</command> Block</title>

        <para></para>

        <para></para>

        <figure>
          <title>postinitBlock</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="postinitDefinition.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>The <emphasis>postInitBlock</emphasis> is an optional block of
        code which is executed after class initialization has
        completed.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Variable Override Declaration</title>

        <para></para>

        <para></para>

        <figure>
          <title>variableOverrideDeclaration</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="variableOverrideDeclaration.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>A <emphasis>variableOverrideDeclaration</emphasis> allows
        changing the default value of a subclass' instance
        <command>var</command> and/or adding an
        <emphasis>onReplaceClause</emphasis> for that <command>var</command>.
        Either an <emphasis>initializingExpression</emphasis> or an
        <emphasis>onReplaceClause</emphasis> or both must be present. Note
        that while an <emphasis>initializingExpression</emphasis> overrides
        the default value, an <emphasis>onReplaceClause</emphasis> adds a
        block to be executed on update -- any
        <emphasis>onReplaceClause</emphasis> defined in a subclass is also
        executed on change to the variable -- this is critical for maintaining
        subclass invariants..</para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Inheritance</title>

      <para>JavaFX classes may inherit from other JavaFX classes, from Java
      interfaces, and from Java classes. Multiple inheritance, inheriting from
      more than one class, is allowed, but with the restriction described
      below.</para>

      <para>Define an <emphasis>impure class</emphasis> as a Java class or a
      JavaFX class which inherits, directly or indirectly, from a Java class.
      Define a <emphasis>pure class</emphasis> a JavaFX class which only
      inherits from Java interfaces or pure classes (a JavaFX class with no
      supertypes is thus a pure class).</para>

      <para>A JavaFX class may inherit from any number of Java interfaces, any
      number of pure classes, and no more than one impure class.</para>

      <para>.</para>
    </sect1>

    <sect1>
      <title>Instance Variable Initialization</title>

      <para></para>

      <para></para>

      <sect2>
        <title>Instance Variable Initialization Avenues</title>

        <para></para>

        <para>The value of an instance variable at the end of initialization
        can be set in any of several ways: value provided in the object
        literal, the initial value specified in the variable declaration, an
        <emphasis>initializingExpression</emphasis> on a variable override
        declaration, or an assignment in an <emphasis>initBlock</emphasis>.
        These avenues are discussed below.</para>

        <para>Class instances are created with object literal expression (a
        newExpression can be considered, for these purposes as equivalent to
        an object literal that sets no instance variables). For
        example:</para>

        <para><programlisting>var fu = Foo { x: 14 }</programlisting></para>

        <para>Here the instance variable x in Foo is set in the object literal
        to 14 (note: x may be declared in a subclass of Foo).</para>

        <para>The declaration of an instance variable explicitly or implicitly
        sets a default value for the variable. For example it could be set
        explicitly:</para>

        <para><programlisting>class Foo {
   var x = 99;
}</programlisting></para>

        <para>Here x has an <emphasis>initializingExpression</emphasis>.
        </para>

        <para>If no <emphasis>initializingExpression</emphasis> is provided,
        the default value for the type is the default value of of the instance
        variable -- see the Types and Values chapter. For example:</para>

        <para><programlisting>class Answers {
   var ungulate : Boolean;
}</programlisting></para>

        <para>Since false is the default value for the Boolean type, the
        default value of ungulate is false.</para>

        <para>A <emphasis>variableOverrideDeclaration</emphasis> can override
        the default value. For example:</para>

        <programlisting>class Shed {
   var siding = "aluminum";
}

class FancyShed extends Shed {
   override var siding = "copper";
}</programlisting>

        <para>Here FancyShed overrides the default value of siding. Note that
        a <emphasis>variableOverrideDeclaration</emphasis> that does not have
        an <emphasis>initializingExpression</emphasis> will not override the
        default value.</para>

        <para>Exactly one of the above will set the initial value. If the
        value is provided in the object literal, that will be used. Otherwise,
        if an override for the variable provides an
        <emphasis>initializingExpression</emphasis> it will be used. If it is
        not overridden, an explicit
        <emphasis>initializingExpression</emphasis> will supply the initial
        value. Failing all that, the default value for the type will be used.
        </para>

        <para>After one of the above has set the instance variable, the
        <emphasis>initBlock</emphasis>, if present, is executed. This block
        can reset the instance variable.</para>

        <para></para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Initialization Order</title>

        <para></para>
      </sect2>

      <sect2>
        <title><command>isInitialized()</command> Built-In Function</title>

        <para></para>
      </sect2>
    </sect1>
  </chapter>
</book>
