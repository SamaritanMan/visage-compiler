<?xml version="1.0" encoding="UTF-8"?>
<book version="5.0" xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink"
      xmlns:xi="http://www.w3.org/2001/XInclude"
      xmlns:svg="http://www.w3.org/2000/svg"
      xmlns:m="http://www.w3.org/1998/Math/MathML"
      xmlns:html="http://www.w3.org/1999/xhtml"
      xmlns:db="http://docbook.org/ns/docbook">
  <info>
    <title>JavaFX Language Reference</title>

    <author>
      <personname><firstname>Robert</firstname><surname>Field</surname></personname>

      <affiliation>
        <orgname>Sun Microsystems</orgname>
      </affiliation>
    </author>

    <pubdate></pubdate>
  </info>

  <chapter>
    <title>Introduction</title>

    <para>Discusses the what and why of JavaFX Script, and then provides
    examples to give you an overview.</para>

    <sect1>
      <title>Why JavaFX Script?</title>

      <para>There are thousands of programming languages, why use JavaFX? Two
      reasons: ubiquitous delivery and rapid development of graphical
      applications. JavaFX is built on the Java platform which is available on
      everything from cell phones to supercomputers. JavaFX is designed so
      that the developer can express their desired results succinctly and
      simply. Much can be expressed declaratively, including the interactive
      relationships between components, greatly easing development
      complexity.</para>
    </sect1>

    <sect1>
      <title>What is JavaFX Script?</title>

      <para>JavaFX Script is a scripting language which means it provides fast
      and easy development with less of the armor provided by conventional
      languages. It is thus tailored to moderately sized interactive graphical
      applications rather than programming in the large. It does, however,
      have one of the most important advantages of compile-time typing. That
      is, before your program even runs, it is checked for incompatible
      relationships between data.</para>
    </sect1>

    <sect1>
      <title>A Taste of JavaFX Script</title>

      <para>But the best way to get the idea of JavaFX Script is to see some
      examples. Don't worry if some of these don't make sense, the rest of
      this Reference will provide the details.</para>

      <para>JavaFX Script programs are written as one or more
      <emphasis>scripts</emphasis>. A script consists of expressions and
      declarations, typically in a file. The following is an expression and
      thus a valid script:</para>

      <programlisting>4</programlisting>

      <para>But it doesn't do anything. So, we could print it using the
      built-in function 'println':</para>

      <programlisting>println(4)</programlisting>

      <para>Which makes it irresistible to show the Hello World script:</para>

      <programlisting>println("Hello, World")</programlisting>

      <para>This script will print:</para>

      <para><computeroutput>Hello, World</computeroutput></para>

      <para>Which really isn't in the spirit of JavaFX since it isn't
      graphical. Refer to the graphics tutorial for that.</para>

      <para>You can, of course, have more complex expressions:</para>

      <programlisting>println("Circumference is { 2*3.1415*7 } ")</programlisting>

      <para>This script will print:</para>

      <para><computeroutput>Circumference is 43.981</computeroutput></para>

      <para>Note that the expression enclosed in braces is computed at runtime
      and inserted into the string. </para>

      <para>This script would be more interesting if we used variables:</para>

      <programlisting>def PI = 3.14159265; 
var r = 7; 
println("Circumference is { 2 * PI * r } ")</programlisting>

      <para>You could also define a function:</para>

      <programlisting>def PI = 3.14159265; 
var r = 7; 
function circumference(radius) { 2 * PI * radius }
println("Circumference is { circumference(r) } ")</programlisting>

      <para>Note that JavaFX Script uses type inference to figure out the type
      of variables and function. Without type inference, this would be
      written:</para>

      <programlisting>def PI : Number = 3.14159265;  
var r : Number = 7; 
function circumference(radius : Number) : Number {
   2 * PI * radius 
} 
println("Circumference is { circumference(r) }")</programlisting>

      <para>You can define a class to represent a real or abstract entity. In
      this case, a point:</para>

      <programlisting>class Point { 
   var x : Integer; 
   var y : Integer; 
   function show() {
      println("Point {x}, {y}")
   } 
} </programlisting>

      <para>This class defines the x and y coordinates and a function to
      display the Point.</para>

      <para>We can create an instance of the Point and assign it to a variable
      like this:</para>

      <programlisting>var myPoint = Point { 
   x: 12
   y: 9
}</programlisting>

      <para>Note that the x and y instance variables are set during
      creation.</para>

      <para>Finally we can ask the point to print itself by calling the show()
      function defined in the Point class (above).</para>

      <programlisting>myPoint.show()</programlisting>

      <para>This will print:</para>

      <para><computeroutput>Point 12, 9</computeroutput></para>

      <para>For an example-based introduction to JavaFX see the JavaFX Script
      Tutorial.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Types and Values</title>

    <para>Covers the data types and values which can be represented and
    manipulated in JavaFX Script</para>

    <sect1>
      <title>JavaFX Script Data Types</title>

      <para>The Void type is an odd duck that is only used to indicate that an
      expression does not have a value (examples of such expressions are the
      <command>while</command>-expression and calls to functions which have no
      return value), the remainder of this chapter excludes Void.</para>

      <para>JavaFX Script Data Types, hereafter called JavaFX Types , consist
      of an <emphasis>element specifier</emphasis> and a
      <emphasis>cardinality</emphasis>. The element specifier determines what
      the type holds and the cardinality determines how many of them can be
      held.</para>

      <sect2>
        <title>Element Specifier</title>

        <para>Element specifiers are classes or function signatures. Classes
        include both JavaFX classes and Java classes. A function signature
        consists of the parameter types and return type -- function signatures
        are unnamed and are not tied to particular functions which might
        implement the signature. All element specifiers are subtypes of
        java.lang.Object.</para>

        <para>[In formal type systems this would be called the
        <emphasis>ground type</emphasis>]</para>
      </sect2>

      <sect2>
        <title>Cardinality</title>

        <para>The cardinality of a type determines how many elements can be
        held in a JavaFX type. The three cardinalities are
        <emphasis>optional</emphasis>, <emphasis>required</emphasis>, and
        <emphasis>sequence</emphasis>.</para>

        <sect3>
          <title>Cardinality: Optional (0 or 1)</title>

          <para>Optional cardinality means there can be one element or no
          elements. This is the cardinality associated with most types,
          currently including all user defined classes. If you define a class
          Foo, then the JavaFX type "Foo" has class Foo as its element
          specifier and optional as its cardinality. For example:</para>

          <programlisting>var x : Foo;</programlisting>

          <para>Says that x can hold an instance of Foo (one element) or can
          hold null, the nonexistent value (no elements).</para>
        </sect3>

        <sect3>
          <title>Cardinality: Required (1)</title>

          <para>Required cardinality means there must be one element. This is
          the cardinality associated with the built-in types String, Integer,
          Number, Boolean, and Duration. For example:</para>

          <programlisting>var k : Integer;</programlisting>

          <para>Says that k holds one Integer.</para>

          <para>The nonexistent value, null, is not a permitted value for
          types with required cardinality. Attempts to assign null to a type
          with required cardinality will be converted to the default value
          (see below). Attempts to convert null to a type with required
          cardinality will also be converted to the default value.</para>
        </sect3>

        <sect3>
          <title>Cardinality: Sequence (0-n)</title>

          <para>Sequence cardinality means there can be any number of
          elements, including zero. This is the cardinality associated with
          explicitly declared sequences. For example:</para>

          <programlisting>var seq : Integer[];</programlisting>

          <para>Says that seq can hold any number of Integers.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Default Values</title>

      <para>Each JavaFX type has an associated default value. The default
      variable is the value of a variable before it is set. It is also the
      value of an expression of that type if an error is encountered For types
      with optional cardinality their default value is null. For
      example:</para>

      <programlisting>var x : Foo; 
println(x);</programlisting>

      <para>Will print null since x has not been set.</para>

      <para>For types with sequence cardinality their default value is the
      empty sequence of their element specifier. For example:</para>

      <programlisting>var seq : Integer[]; 
println(sizeof seq);</programlisting>

      <para>Will print zero as the size of seq since seq has not been set and
      its initial value will be an empty sequence of Integer.</para>

      <para>Each required type has its own default value, as shown in the
      table below.</para>

      <programlisting>var k : Integer; 
println(k);</programlisting>

      <para>Will print zero since k has not been set and the default value for
      Integer is 0.</para>
    </sect1>

    <sect1>
      <title>Built-in Types</title>

      <para>The built-in types -- String, Integer, Number, Boolean, and
      Duration -- have the following characteristics:</para>

      <itemizedlist>
        <listitem>
          <para>are all immutable -- they do not have internal state that can
          be changed (for example, you can't change the characters in a
          String)</para>
        </listitem>

        <listitem>
          <para>all have required cardinality (and thus are subclasses of
          java.lang.Object)</para>
        </listitem>

        <listitem>
          <para>all have default value different from null</para>
        </listitem>

        <listitem>
          <para>all have a built-in literal format</para>
        </listitem>

        <listitem>
          <para>all, but Duration, have built-in operations that return values
          of the type</para>
        </listitem>
      </itemizedlist>

      <sect2>
        <title>String</title>

        <para>String represents character strings. The default value for the
        String type is the empty string ("").</para>

        <sect3>
          <title>String Literal Syntax</title>

          <para><programlisting>    StringLiteral:
            OneStringLiteral
            StringLiteral OneStringLiteral

    OneStringLiteral:
            <command>"</command> DoubleQuoteStringCharacters<subscript>opt</subscript> <command>"</command>
            <command>'</command> SingleQuoteStringCharacters<subscript>opt</subscript> <command>'</command>

    DoubleQuoteStringCharacters:
            DoubleQuoteStringCharacter
            DoubleQuoteStringCharacters DoubleQuoteStringCharacter

    DoubleQuoteStringCharacter:
            InputCharacter but not <command>"</command>, <command>{</command>, <command>}</command> or <command>\</command>
            <command>\</command> InputCharacter

    SingleQuoteStringCharacters:
            SingleQuoteStringCharacter
            SingleQuoteStringCharacters SingleQuoteStringCharacter

    SingleQuoteStringCharacter:
            InputCharacter but not <command>'</command>, <command>{</command>, <command>}</command> or <command>\</command>
            <command>\</command> InputCharacter
</programlisting></para>

          <para>Literals are bracketed in either single or double quotes. That
          is, a double quote followed by a sequence of characters (here
          "sequence" does not refer to the cardinality) and ending with a
          double quote. Or a single quote followed by a sequence of characters
          and ending with a single quote. If the sequence of characters
          includes braces ('{' or '}') it is a string-expression (which is
          covered in the Expressions chapter). Any character may be escaped
          with the backslash character ('\') -- this is useful for including
          the brace, quote, and backslash characters. Note that single quotes
          may be included in double quoted strings without being escaped, and
          visa versa. The sequence of characters must not include
          carriage-return or linefeed. Two adjacent strings are automatically
          merged -- this is convenient for making multiple line strings.
          Thus:</para>

          <programlisting>"Hello "
't\here'</programlisting>

          <para>Is equivalent to:</para>

          <para>"Hello there"</para>
        </sect3>

        <sect3>
          <title>Operations over String</title>

          <para>String-expressions are of String type -- see the Expressions
          chapter</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Integer</title>

        <para><programlisting>    IntegerLiteral:
            DecimalIntegerLiteral
            HexIntegerLiteral       
            OctalIntegerLiteral

    DecimalIntegerLiteral:
            <command>0</command>
            NonZeroDigit Digitsopt

    Digits:
            Digit
            Digits Digit

    Digit:
            <command>0</command>
            NonZeroDigit

    NonZeroDigit: one of
            <command>1 2 3 4 5 6 7 8 9</command>


    HexIntegerLiteral:
            <command>0 x</command> HexDigits
            <command>0 X</command> HexDigits

    HexDigits:
            HexDigit
            HexDigit HexDigits

    HexDigit: one of
            <command>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</command>


    OctalIntegerLiteral:
            <command>0</command> OctalDigits

    OctalDigits:
            OctalDigit
            OctalDigit OctalDigits

    OctalDigit: one of
            <command>0 1 2 3 4 5 6 7</command>
</programlisting></para>

        <para>The Integer type represents integers in the range -2147483648 to
        2147483647, inclusive. The default value for the Integer type is zero
        (0).</para>

        <sect3>
          <title>Integer Literal Syntax.</title>

          <para>Integers may be represented in decimal, octal, or hexidecimal
          formats. Decimal format is the digit 1 through 9 followed by digits
          in the range 0 through 9, or simply 0 by itself. Octal format is the
          digit 0 followed by digits in the range 0 through 7. Hexidecimal
          format is the digit 0 following by 'x' or 'X' then followed by
          digits in the range 0 through 9 or A through F (upper or lower
          case).</para>
        </sect3>

        <sect3>
          <title>Operations over Integer</title>

          <para>Arithmetic operators (+, -, *, /, and <command>mod</command>)
          operate over and return Integer. Comparison operators (==, &lt;,
          &gt;=, etc) operate over Integer. The <command>sizeof</command>
          operator returns Integer.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Number</title>

        <para>The Number type represents floating-point numbers.</para>

        <para>The Number type is conceptually associated with the
        double-precision 64-bit format IEEE 754 values and operations as
        specified in IEEE Standard for Binary Floating-Point Arithmetic,
        ANSI/IEEE Standard 754-1985 (IEEE, New York).</para>

        <para>The IEEE 754 standard includes not only positive and negative
        numbers that consist of a sign and magnitude, but also positive and
        negative zeros, positive and negative infinities, and special
        Not-a-Number values (hereafter abbreviated NaN). A NaN value is used
        to represent the result of certain invalid operations such as dividing
        zero by zero. The double-extended-exponent value set may, under
        certain circumstances, be used instead of the standard value sets to
        represent the values of expressions of type Number.</para>

        <sect3>
          <title>Number Literal Syntax</title>

          <para><programlisting>NumberLiteral:
      Digits . Digits<subscript>opt</subscript> ExponentPart<subscript>opt</subscript> 
      <command>.</command> Digits ExponentPart<subscript>opt</subscript> 
      Digits ExponentPart<subscript>opt</subscript> 

ExponentPart:
        ExponentIndicator SignedInteger

ExponentIndicator: one of
        <command>e E</command>

SignedInteger:
        Sign<subscript>opt</subscript> Digits

Sign: one of
        <command>+ -</command>
</programlisting></para>

          <para></para>
        </sect3>

        <sect3>
          <title>Operations over Number</title>

          <para>Arithmetic operators (+, -, *, and /) operate over and return
          Number. The comparison operators (==, &lt;, &gt;=, etc) operate over
          Number.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Boolean</title>

        <para>Boolean represents the values true and false.</para>

        <sect3>
          <title>Boolean Literal Syntax</title>

          <programlisting>    BooleanLiteral: one of
            <command>true false</command>
</programlisting>

          <para></para>
        </sect3>

        <sect3>
          <title>Operations over Boolean</title>

          <para>The <command>not</command>, <command>and</command>, and
          <command>or</command> operators operate over and return Boolean. The
          comparison operators (==, &lt;, &gt;=, etc) return Boolean. The
          <command>if</command>-expression and
          <command>while</command>-expression take Boolean as their
          condition.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>Duration</title>

        <para>Duration represents an amount of time.</para>

        <sect3>
          <title>Duration Literal Syntax</title>

          <programlisting>    DurationLiteral:
        IntegerLiteral TimeUnit
        NumberLiteral TimeUnit

    TimeUnit: one of
        <command>ms  s  m  h</command></programlisting>

          <para>For example: 10s is ten seconds, 4ms is four milliseconds,
          010m is eight minutes, and 0.5h is half an hour.</para>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Function Types</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Type Chart</title>

      <para></para>

      <table>
        <title></title>

        <tgroup cols="6">
          <colspec colname="t2" />

          <colspec colname="decl" />

          <colspec colname="dflt" />

          <colspec colname="element" />

          <colspec colname="card" />

          <colspec colname="lit" />

          <thead>
            <row>
              <entry align="center"><para>Type</para></entry>

              <entry align="center"><para>Declaration</para></entry>

              <entry align="center"><para>Default Value</para></entry>

              <entry align="center"><para>Element Specifier</para></entry>

              <entry align="center"><para>Cardinality</para></entry>

              <entry align="center"><para>Literal or Creation
              Examples</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para><literal>Object</literal></para></entry>

              <entry><para><literal>: Object</literal></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><literal>java.lang.Object</literal></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>new Object</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>String</literal></para></entry>

              <entry><para><literal>: String</literal></para></entry>

              <entry><para><literal>""</literal></para></entry>

              <entry><para><literal>java.lang.String</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>"Brownian"</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Integer</literal></para></entry>

              <entry><para><literal>: Integer</literal></para></entry>

              <entry><para>0</para></entry>

              <entry><para><literal>java.lang.Integer</literal></para></entry>

              <entry><para><literal>1 Required</literal></para></entry>

              <entry><para><literal>1956</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Number</literal></para></entry>

              <entry><para><literal>: Number</literal></para></entry>

              <entry><para><literal>0.0</literal></para></entry>

              <entry><para><literal>java.lang.Double</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>1.4142</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Boolean</literal></para></entry>

              <entry><para><literal>: Boolean</literal></para></entry>

              <entry><para><literal>false</literal></para></entry>

              <entry><para><literal>java.lang.Boolean</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>true</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>Duration</literal></para></entry>

              <entry><para><literal>: Duration</literal></para></entry>

              <entry><para><literal>0ms</literal></para></entry>

              <entry><para><literal>javafx.lang.Duration</literal></para></entry>

              <entry><para>1 Required</para></entry>

              <entry><para><literal>47s</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>other class
              types</emphasis></para></entry>

              <entry><para><literal>:
              </literal><emphasis>ClassName</emphasis></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><emphasis>ClassName</emphasis></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>Point {x: 3 y: 9}</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>function types</emphasis></para></entry>

              <entry><para><literal>:
              function(</literal><emphasis>name</emphasis><literal> :
              </literal><emphasis>ParamType</emphasis><literal>,
              </literal><emphasis>...</emphasis><literal>) : </literal>
              <emphasis>ReturnType</emphasis></para></entry>

              <entry><para><literal>null</literal></para></entry>

              <entry><para><literal>function(</literal><emphasis>name</emphasis><literal>
              : </literal><emphasis>ParamType</emphasis><literal>,
              </literal><emphasis>...</emphasis><literal>) : </literal>
              <emphasis>ReturnType</emphasis></para></entry>

              <entry><para>0-1 Optional</para></entry>

              <entry><para><literal>function(x:Integer):String {" {x}
              "}</literal></para></entry>
            </row>

            <row>
              <entry><para><emphasis>sequence types</emphasis></para></entry>

              <entry><para><literal>:
              </literal><emphasis>ElementSpec</emphasis><literal>[]</literal></para></entry>

              <entry><para><literal>[]</literal></para></entry>

              <entry><para><emphasis>ElementSpec</emphasis></para></entry>

              <entry><para>0-n Sequence</para></entry>

              <entry><para><literal>[9, 14, 21, 4]</literal></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Expressions</title>

    <para>The miriad ways that expressions can be formed are described.</para>

    <sect1>
      <title>Operators</title>

      <para></para>

      <para></para>

      <table>
        <title>Binary Arithmetic Operators</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> Operator</entry>

              <entry align="center">Meaning </entry>

              <entry align="center">Operand Types</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="4"><command>+</command></entry>

              <entry morerows="4">Add</entry>

              <entry>Integer + Integer</entry>

              <entry>Integer</entry>
            </row>

            <row>
              <entry>Integer + Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number + Integer</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number + Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Duration + Duration</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry morerows="4"><command>-</command></entry>

              <entry morerows="4">Subtract</entry>

              <entry>Integer - Integer</entry>

              <entry>Integer</entry>
            </row>

            <row>
              <entry>Integer - Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number - Integer</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number - Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Duration - Duration</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry morerows="7"><command>*</command></entry>

              <entry morerows="7">Multiply</entry>

              <entry>Integer * Integer</entry>

              <entry>Integer</entry>
            </row>

            <row>
              <entry>Integer * Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number * Integer</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number * Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Integer * Duration</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry>Number * Duration</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry>Duration * Integer</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry>Duration * Number</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry morerows="5"><command>/</command></entry>

              <entry morerows="5">Divide</entry>

              <entry>Integer / Integer</entry>

              <entry>??? (under discussion -- see JFXC-1381)</entry>
            </row>

            <row>
              <entry>Integer / Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number / Integer</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Number / Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>Duration / Integer</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry>Duration / Number</entry>

              <entry>Duration</entry>
            </row>

            <row>
              <entry><command>mod</command></entry>

              <entry>Modulo (sign of result not defined for negative
              operands)</entry>

              <entry>Integer mod Integer</entry>

              <entry>Integer</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>These Operators operate over Integer and Number. If either
      operator is Number, the result is Number. Otherwise, the result is
      Integer. Note: + does not operate over String.</para>

      <para></para>

      <table>
        <title>Unary Arithmetic Operator</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">Operator</entry>

              <entry align="center">Meaning</entry>

              <entry align="center">Operand Type</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="2"><command>-</command></entry>

              <entry morerows="2">Negation</entry>

              <entry>- Integer</entry>

              <entry>Integer</entry>
            </row>

            <row>
              <entry>- Number</entry>

              <entry>Number</entry>
            </row>

            <row>
              <entry>- Duration</entry>

              <entry>Duration</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para></para>

      <table>
        <title>Relational Operators</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center">Operator</entry>

              <entry align="center">Meaning</entry>

              <entry align="center">Operand Types</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="4"><command>&lt;</command></entry>

              <entry morerows="4">Less than</entry>

              <entry>Integer &lt; Integer</entry>

              <entry morerows="4">Boolean</entry>
            </row>

            <row>
              <entry>Integer &lt; Number</entry>
            </row>

            <row>
              <entry>Number &lt; Integer</entry>
            </row>

            <row>
              <entry>Number &lt; Number</entry>
            </row>

            <row>
              <entry>Duration &lt; Duration</entry>
            </row>

            <row>
              <entry morerows="4"><command>&lt;=</command></entry>

              <entry morerows="4">Less than or equal</entry>

              <entry>Integer &lt;= Integer</entry>

              <entry morerows="4">Boolean</entry>
            </row>

            <row>
              <entry>Integer &lt;= Number</entry>
            </row>

            <row>
              <entry>Number &lt;= Integer</entry>
            </row>

            <row>
              <entry>Number &lt;= Number</entry>
            </row>

            <row>
              <entry>Duration &lt;= Duration</entry>
            </row>

            <row>
              <entry morerows="4"><command>&gt;</command></entry>

              <entry morerows="4">Greater than</entry>

              <entry>Integer &gt; Integer</entry>

              <entry morerows="4">Boolean</entry>
            </row>

            <row>
              <entry>Integer &gt; Number</entry>
            </row>

            <row>
              <entry>Number &gt; Integer</entry>
            </row>

            <row>
              <entry>Number &gt; Number</entry>
            </row>

            <row>
              <entry>Duration &gt; Duration</entry>
            </row>

            <row>
              <entry morerows="4"><command>&gt;=</command></entry>

              <entry morerows="4">Greater than or equal</entry>

              <entry>Integer &gt;= Integer</entry>

              <entry morerows="4">Boolean</entry>
            </row>

            <row>
              <entry>Integer &gt;= Number</entry>
            </row>

            <row>
              <entry>Number &gt;= Integer</entry>
            </row>

            <row>
              <entry>Number &gt;= Number</entry>
            </row>

            <row>
              <entry>Duration &gt;= Duration</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para></para>

      <table>
        <title>Equality Operators</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> Operator</entry>

              <entry align="center">Meaning </entry>

              <entry align="center">Operand Types</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>==</command></entry>

              <entry>Equals</entry>

              <entry>Object == Object</entry>

              <entry>Boolean</entry>
            </row>

            <row>
              <entry><command>!=</command></entry>

              <entry>Equals</entry>

              <entry>Object != Object</entry>

              <entry>Boolean</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Note: for relational and equality operators, when comparing
      Integer to Number, the Integer will first be converted to Number.</para>

      <para></para>

      <para></para>

      <table>
        <title>Binary Logical Operators</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> Operator</entry>

              <entry align="center">Meaning </entry>

              <entry align="center">Operand Types</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>and</command></entry>

              <entry>Logical and</entry>

              <entry>Boolean and Boolean</entry>

              <entry>Boolean</entry>
            </row>

            <row>
              <entry><command>or</command></entry>

              <entry>Logical or</entry>

              <entry>Boolean or Boolean</entry>

              <entry>Boolean</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para></para>

      <table>
        <title>Unary Logical Operator</title>

        <tgroup cols="4">
          <colspec align="center" />

          <thead>
            <row>
              <entry align="center"> Operator</entry>

              <entry align="center">Meaning </entry>

              <entry align="center">Operand Types</entry>

              <entry align="center">Result Type</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><command>not</command></entry>

              <entry>Logical not</entry>

              <entry>not Boolean</entry>

              <entry>Boolean</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>TO DO: assign, assign op, incr/decr, type, reverse, sizeof</para>
    </sect1>

    <sect1>
      <title>Function Invocation</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Member Access</title>

      <para></para>
    </sect1>

    <sect1>
      <title>String Expressions</title>

      <para></para>

      <sect2>
        <title>Translation Keys</title>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Object Literals</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Creation</title>

      <para></para>
    </sect1>

    <sect1>
      <title>This</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Blocks</title>

      <para></para>
    </sect1>

    <sect1>
      <title>If</title>

      <para></para>
    </sect1>

    <sect1>
      <title>While</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Return</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Break</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Continue</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Try-Catch-Finally</title>

      <para></para>
    </sect1>

    <sect1>
      <title>For</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Access</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Sequence Modification</title>

      <para></para>
    </sect1>

    <sect1>
      <title>Timelines</title>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Variables</title>

    <para>The declaration, use and scope of variables.</para>

    <sect1>
      <title>def and var</title>

      <para>Variables are declared with two keywords: def and var. Variables
      which are defined once and are never assigned to are defined with
      def.</para>

      <para><programlisting>def Z0 = 376.730313;</programlisting></para>

      <para>Note that a bound variable (without inverse) is defined once and
      can never be assigned. It to should be declared with def:</para>

      <para><programlisting>def x = bind y + z;</programlisting></para>

      <para>See the Binding chapter.</para>

      <para>Variables that will or can be assigned to should be declared with
      var:</para>

      <para><programlisting>var x = 0; 
++x;</programlisting></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Kinds of Variables</title>

      <para>Variables can be declared at the script level (script variable),
      inside a class (instance variable), or within blocks (local
      variable)</para>

      <para></para>

      <sect2>
        <title>Script Variables</title>

        <para>Script variables are declared at the top-level of a script, not
        inside a class definition. Script variables are visible through-out
        the entire script -- a member access expression is not needed.</para>

        <para><programlisting>var thing = "Thing"; 
class A { 
   function getThing() : String { thing } 
}</programlisting></para>

        <para>If access modifiers are added which make the script variable
        visible outside the script, they may be accessed as members of the
        script. For example, if this is script Foo.fx:</para>

        <para><programlisting>public def bohr = 0.529177e-10</programlisting></para>

        <para>Then script Bar.fx can access bohr:</para>

        <para><programlisting>println(Foo.bohr)</programlisting></para>

        <para>The lifetime of a script variable is from the time the script is
        loaded until the end of program execution.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Instance Variables</title>

        <para>Instance variables are declared at the top-level of a class.
        Instance variables are visible through-out the entire script -- a
        member access expression is not needed within the class but is needed
        outside of the class.</para>

        <para><programlisting>def anA = A{ rat: true }; 
println(anA.rat); 
class A { 
   var rat : Boolean; 
   function isIt() { rat }  
}  
class B { 
   function wellisIt() { anA.rat } 
}</programlisting></para>

        <para>The lifetime of an instance variable is the lifetime of the
        class instance.</para>
      </sect2>

      <sect2>
        <title>Local Variables</title>

        <para>Local variables are declared within blocks, including blocks
        which are the bodies of functions. Local variables are visible only
        within the inner-most block -- their scope includes the entire body of
        that block (not just below the variable declaration). Member access
        expressions are not applicable to local variables. Access modifiers
        must not be applied to local variable declarations.</para>

        <para>The lifetime of a local variable ends when the block is
        exited.</para>

        <para>Local variable declarations are both declarations and
        expressions, that is, they have type and value.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Parameters, Induction Variables, and other Expression
        Parameters</title>

        <para>Function parameters are visible only within the function body.
        For-expression induction variables are visible only within the
        for-expression body. The scope of other expression parameters is their
        expression.</para>

        <para>They must not be assigned to.</para>

        <para>See Function, the For section of expressions, and On Replace
        (below) for syntax.</para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Syntax of Variable Declarations</title>

      <para></para>

      <figure>
        <title>variableDeclaration</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="variableDeclaration.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure>
        <title>typeSpecifier</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="typeSpecifier.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>initializingExpression</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="initializingExpression.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>onReplaceClause</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="onReplaceClause.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>While syntactically optional, an
      <emphasis>initializingExpression</emphasis> is required with
      <command>def</command>.</para>

      <para>When <command>bind</command> is specified in the
      <emphasis>initializingExpression</emphasis> the variable is kept updated
      to the value of the <emphasis>expression</emphasis>. When <command>with
      inverse</command> is specified, the <emphasis>expression</emphasis> must
      be a simple variable reference and that variable is kept updated when
      the variable being declared is changed. See the Binding chapter for
      details.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>On Replace</title>

      <para>The <emphasis>onReplaceClause</emphasis>, if present, causes the
      block to be executed each time the value of the variable changes --
      including the assignment of its initial value.</para>

      <para>The optional parameters provide information about what is changed:
      <command>on replace</command> <emphasis>oldValue</emphasis>
      <command>[</command> <emphasis>firstIndex</emphasis>
      <command>..</command> <emphasis>lastIndex</emphasis><command> ]
      =</command> <emphasis>newElements</emphasis> <command>{</command> ...
      <command>}</command></para>

      <para>But these parameters are all optional, in the simplest form none
      of these are present:</para>

      <para><programlisting>var x = 0 on replace { println("x is now: {x}") }</programlisting></para>

      <para>The <emphasis>oldValue</emphasis> parameter provides the previous
      value.</para>

      <para><programlisting>var x = 0 on replace oldValue { println("x was {oldValue} and is now: {x}") }</programlisting></para>

      <para>The remaining parameters are useful with sequences.</para>

      <para><programlisting>var seq = ['A', 'B', 'C', 'D', 'E', 'F'] on replace oldValue[firstIdx .. lastIdx] = newElements { 
    println("replaced {oldValue}[{firstIdx}..{lastIdx}] by {newElements} yielding {seq}") 
} 
seq[3] = '$'; 
insert '#' into seq; 
delete '$' from seq; 
delete seq[2]; 
seq[1..4] = ['X', 'Y']; 
delete seq; </programlisting></para>

      <para>Which prints:</para>

      <screen>replaced [0..-1] by ABCDEF yielding ABCDEF
replaced ABCDEF[3..3] by $ yielding ABC$EF
replaced ABC$EF[6..5] by # yielding ABC$EF#
replaced ABC$EF#[3..3] by  yielding ABCEF#
replaced ABCEF#[2..2] by  yielding ABEF#
replaced ABEF#[1..4] by XY yielding AXY
replaced AXY[0..2] by  yielding</screen>

      <para>Note that <emphasis>firstIndex</emphasis>,
      <emphasis>lastIndex</emphasis> and <emphasis>newElements</emphasis>
      refer only to the portion of the sequence which has changed,</para>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Functions</title>

    <para></para>

    <para></para>

    <sect1>
      <title>Function Syntax</title>

      <para></para>

      <figure>
        <title>functionDefinition</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="functionDefinition.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>formalParameters</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameters.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>formalParameter</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="formalParameter.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <figure>
        <title>typeSpecifier</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="typeSpecifier.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </sect1>

    <sect1>
      <title>Kinds of Functions</title>

      <para>Functions can be declared at the script level (script function) or
      inside a class (instance function). Local functions are not yet
      supported.</para>

      <para></para>

      <sect2>
        <title>Script Functions</title>

        <para>Script functions are declared at the top-level of a script, not
        inside a class definition. Script functions are visible through-out
        the entire script -- a member access expression is not needed.</para>

        <para><programlisting>function square(x : Number) : Number { x * x }
println( square(7) )</programlisting></para>

        <para>If access modifiers are added which make the script function
        visible outside the script, they may be accessed as members of the
        script. For example, if this is script Foo.fx:</para>

        <para><programlisting>public function square(x : Number) : Number { x * x }</programlisting></para>

        <para>Then script Bar.fx can access bohr:</para>

        <para><programlisting>println(Foo.square(10))</programlisting></para>
      </sect2>

      <sect2>
        <title>Instance Functions</title>

        <para>Instance functions are declared at the top-level of a class.
        Instance functions are visible through-out the entire script -- a
        member access expression is not needed within the class but is needed
        outside of the class.</para>

        <para><programlisting>class Scale { 
   var factor : Number; 
   function transform(x : Number) : Number { factor * x } 
} 
var tf = Scale { factor: 25.0 } 
println(tf.transform(10.0))</programlisting></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Type Inference</title>

      <para>Type inferencing can generally determine the return type of a
      function. In most cases the parameter types can be determined by type
      inference as well.</para>

      <para>However, functions which, by virtue of their access modifiers, are
      visible outside the script should be explicitly typed.</para>
    </sect1>

    <sect1>
      <title>Bound Functions</title>

      <para>The modifier <command>bound</command> is only allowed on
      functions, such functions are called <emphasis>bound
      functions</emphasis>. Bound functions are covered in the Binding
      chapter.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>Parameter passing</title>

      <para>When called in a bound context, the parameters of a bound function
      are passed by reference and the return value is by reference as well. In
      all other cases, non-bound functions and bound functions called form
      non-bound contexts, parameters are passed by value and the the return
      value is by value.</para>

      <para></para>
    </sect1>

    <sect1>
      <title>Overriding Functions</title>

      <para></para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Classes</title>

    <para></para>

    <para></para>

    <sect1>
      <title>Syntax of Class Definition</title>

      <para></para>

      <figure>
        <title>classDefinition</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="classDefinition.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para></para>

      <figure>
        <title>superclasses</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="superclasses.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para></para>
    </sect1>

    <sect1>
      <title>Class Members</title>

      <para></para>

      <figure>
        <title>classMember</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="classMember.png"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para></para>

      <para><emphasis>functionDefinition</emphasis> and
      <emphasis>variableDeclaration</emphasis> are covered in their respective
      chapters. The remaining class members are covered below.</para>

      <para></para>

      <sect2>
        <title><command>init</command> Block</title>

        <para></para>

        <para></para>

        <figure>
          <title>initBlock</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="initDefinition.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>The <emphasis>initBlock</emphasis> is an optional block of code
        which is executed as the final step of class initialization.</para>
      </sect2>

      <sect2>
        <title><command>postinit</command> Block</title>

        <para></para>

        <para></para>

        <figure>
          <title>postinitBlock</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="postinitDefinition.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>The <emphasis>postInitBlock</emphasis> is an optional block of
        code which is executed after class initialization has
        completed.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Variable Override Declaration</title>

        <para></para>

        <para></para>

        <figure>
          <title>variableOverrideDeclaration</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="variableOverrideDeclaration.png"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para></para>

        <para>A <emphasis>variableOverrideDeclaration</emphasis> allows
        changing the default value of a subclass' instance
        <command>var</command> and/or adding an
        <emphasis>onReplaceClause</emphasis> for that <command>var</command>.
        Either an <emphasis>initializingExpression</emphasis> or an
        <emphasis>onReplaceClause</emphasis> or both must be present. Note
        that while an <emphasis>initializingExpression</emphasis> overrides
        the default value, an <emphasis>onReplaceClause</emphasis> adds a
        block to be executed on update -- any
        <emphasis>onReplaceClause</emphasis> defined in a subclass is also
        executed on change to the variable -- this is critical for maintaining
        subclass invariants..</para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Inheritance</title>

      <para>JavaFX classes may inherit from other JavaFX classes, from Java
      interfaces, and from Java classes. Multiple inheritance, inheriting from
      more than one class, is allowed, but with the restriction described
      below.</para>

      <para>Define an <emphasis>impure class</emphasis> as a Java class or a
      JavaFX class which inherits, directly or indirectly, from a Java class.
      Define a <emphasis>pure class</emphasis> a JavaFX class which only
      inherits from Java interfaces or pure classes (a JavaFX class with no
      supertypes is thus a pure class).</para>

      <para>A JavaFX class may inherit from any number of Java interfaces, any
      number of pure classes, and no more than one impure class.</para>

      <para>.</para>
    </sect1>

    <sect1>
      <title>Instance Variable Initialization</title>

      <para></para>

      <para></para>

      <sect2>
        <title>Instance Variable Initialization Avenues</title>

        <para></para>

        <para>The value of an instance variable at the end of initialization
        can be set in any of several ways: value provided in the object
        literal, the initial value specified in the variable declaration, an
        <emphasis>initializingExpression</emphasis> on a variable override
        declaration, or an assignment in an <emphasis>initBlock</emphasis>.
        These avenues are discussed below.</para>

        <para>Class instances are created with object literal expression (a
        newExpression can be considered, for these purposes as equivalent to
        an object literal that sets no instance variables). For
        example:</para>

        <para><programlisting>var fu = Foo { x: 14 }</programlisting></para>

        <para>Here the instance variable x in Foo is set in the object literal
        to 14 (note: x may be declared in a subclass of Foo).</para>

        <para>The declaration of an instance variable explicitly or implicitly
        sets a default value for the variable. For example it could be set
        explicitly:</para>

        <para><programlisting>class Foo {
   var x = 99;
}</programlisting></para>

        <para>Here x has an
        <emphasis>initializingExpression</emphasis>.</para>

        <para>If no <emphasis>initializingExpression</emphasis> is provided,
        the default value for the type is the default value of of the instance
        variable -- see the Types and Values chapter. For example:</para>

        <para><programlisting>class Answers {
   var ungulate : Boolean;
}</programlisting></para>

        <para>Since false is the default value for the Boolean type, the
        default value of ungulate is false.</para>

        <para>A <emphasis>variableOverrideDeclaration</emphasis> can override
        the default value. For example:</para>

        <programlisting>class Shed {
   var siding = "aluminum";
}

class FancyShed extends Shed {
   override var siding = "copper";
}</programlisting>

        <para>Here FancyShed overrides the default value of siding. Note that
        a <emphasis>variableOverrideDeclaration</emphasis> that does not have
        an <emphasis>initializingExpression</emphasis> will not override the
        default value.</para>

        <para>Exactly one of the above will set the initial value. If the
        value is provided in the object literal, that will be used. Otherwise,
        if an override for the variable provides an
        <emphasis>initializingExpression</emphasis> it will be used. If it is
        not overridden, an explicit
        <emphasis>initializingExpression</emphasis> will supply the initial
        value. Failing all that, the default value for the type will be
        used.</para>

        <para>After one of the above has set the instance variable, the
        <emphasis>initBlock</emphasis>, if present, is executed. This block
        can reset the instance variable.</para>

        <para></para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Initialization Order</title>

        <para></para>
      </sect2>

      <sect2>
        <title><command>isInitialized()</command> Built-In Function</title>

        <para></para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Scripts</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Binding</title>

    <para></para>

    <sect1>
      <title>Bind Update</title>

      <para></para>

      <sect2>
        <title>What does "bind" mean?</title>

        <para>When you write a bound expression:</para>

        <para><programlisting>def x = bind <emphasis>someExpression</emphasis>; </programlisting></para>

        <para>it means that when <emphasis>someExpression</emphasis> changes,
        x will be updated to match. That's it. In most cases that is all you
        need know. But in some cases you need to know how exactly the update
        occurs and in some cases, what is meant by
        <emphasis>someExpression</emphasis> changing. This is what is
        discussed below.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>What is recalculated on update?</title>

        <para>Within a bind, the minimal recalculation is done -- this only
        matters in limited circumstances, for example when object creation is
        done in a bind and if, because of object identity, it matters if a new
        object is created or not.</para>

        <para>Let's look at an example of bind:</para>

        <para><programlisting>def sum = bind <emphasis>expr1</emphasis> + <emphasis><emphasis><emphasis>expr2</emphasis></emphasis></emphasis>; </programlisting></para>

        <para>if <emphasis>expr2</emphasis> changes (more precisely, when its
        dependencies change -- more on that later) then the addition is redone
        but <emphasis>expr1</emphasis> is not recalculated, its value has been
        stored and it is simply re-fetched.</para>

        <para>Let's make this concrete:</para>

        <para><programlisting>var y = 3; 
function ten() : Integer { 
   println("Called ten");
   10 
} 
def sum = bind ten() + y; 
println(sum); 
y = 7; 
println(sum); </programlisting></para>

        <para>This prints:</para>

        <para><computeroutput>Called ten</computeroutput></para>

        <para><computeroutput>13 </computeroutput></para>

        <para><computeroutput>17 </computeroutput></para>

        <para>Note that the function ten() is called to compute the initial
        value of sum, but when y is set to 7, the function ten() is not called
        again (since it didn't change), its value has been remembered and
        reused.</para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Conditional Expressions</title>

        <para><programlisting>def x = bind if (<emphasis>condExpr</emphasis>) <emphasis>expr1</emphasis> else <emphasis>expr2</emphasis>;</programlisting></para>

        <para>if the value of <emphasis>condExpr</emphasis> changes, this
        switches which branch of the if-statement is to be evaluated thus
        causing a recalculation each time the value of
        <emphasis>condExpr</emphasis> changes (the previous value of a branch
        is not stored). If <emphasis>condExpr</emphasis> is true, a change to
        the dependencies of <emphasis>expr1</emphasis> will cause it to be
        recalculated but this will not cause a calculation of
        <emphasis>expr2</emphasis> nor will changes to the dependencies of
        <emphasis>expr2</emphasis>. Specifically, if
        <emphasis>condExpr</emphasis> is true, only <emphasis>expr1</emphasis>
        will calculated; <emphasis>expr2</emphasis> will not be. The inverse
        is, of course, also true.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>For Expressions</title>

        <para><programlisting>def newSeq = bind for (elem in seq) <emphasis>expr</emphasis>;</programlisting></para>

        <para>If seq changes, the elements in newSeq which corresponded to
        elements still in seq are not recalculated. That is, if an element is
        inserted into seq, the result of applying expr to that element are
        inserted into newSeq at the corresponding position and the other
        elements are not recalculated. Well, OK, there is an exception to that
        rule, if expr uses indexof elem then those elements whose index
        changed will need to be updated, but again, corresponding to the
        minimal update rules. For example:</para>

        <programlisting>    var min = 0;
    var max = 5;
    function square(x : Integer) : Integer { x*x }
    def values = bind for (x in [min..max]) square(x);
    println(values);
    max = 10;
    println(values);
    min = 1;
    println(values);
    max = 10;
    println(values);
    min = 0;
    println(values);
</programlisting>

        <para>The output is:</para>

        <para><computeroutput>[ 0, 1, 4, 9 ]</computeroutput></para>

        <para><computeroutput>[ 0, 1, 4, 9, 16, 25 ]</computeroutput></para>

        <para><computeroutput>[ 1, 4, 9, 16, 25 ]</computeroutput></para>

        <para><computeroutput>[ 0, 1, 4, 9, 16, 25 ]</computeroutput></para>

        <para>But what about recalculations? First the squares of 0 through 3
        are calculated, then the squares of 4 and 5 (0 through 3 are not
        recalculated when the max changes). Then the square of zero is deleted
        (without recalculating any values), and then the square of zero is
        added back (this does require it to be recalculated). The behavior is
        the same if insert and delete are used.</para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Block Expressions</title>

        <para>A block expression is a list of expressions enclosing in curly
        braces. And having the value of the final expression. Within a bind,
        the only expressions which can occur in the non-final position of a
        block-expression are variable declarations. Note that assignment
        (including increment and decrement) are prohibited within bind. Thus a
        bound block-expression has the form:</para>

        <para><programlisting>bind { 
   def a = expr;  
   def b = expr;  
   def c = expr;  
   expr 
} </programlisting></para>

        <para>Because any changes to the bound expression cause an update, and
        because that update is minimal, it is easy to see that the variables
        are effectively bound. Note also that <command>while</command>,
        <command>insert</command>, <command>delete</command>, etc cannot occur
        in a bound block expression since they are not variable declarations
        and thus cannot occur in the non-final positions, and they have Void
        type, thus have no value and cannot be bound; cannot be in the final
        posiiton.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Function and Method Calls</title>

        <para><programlisting>def val = bind foo(a, b);</programlisting></para>

        <para>A non-bound function is one that is not proceeded with the bound
        keyword. For calls to Java<superscript>TM</superscript> methods or
        non-bound JavaFX<superscript>TM</superscript> functions, the function
        is re-invoked if any of the arguments change. But the body of a
        function is a black-box, dependencies it might have beyond the
        parameters do not cause a recalculation. For example:</para>

        <programlisting>class Point {
  var x : Number;
  var y : Number;
}

var scale = 1.0;
function makePoint(x0 : Number, y0 : Number) : Point {
  Point {
    x: x0 * scale
    y: y0 * scale
  }
}

var myX = 3.0;
var myY = 3.0;
def pt = bind makePoint(myX, myY);
println(pt.x);
myX = 10.0;
println(pt.x);
scale = 2.0;
println(pt.x);</programlisting>

        <para>Will print:</para>

        <para><computeroutput>3.0 </computeroutput></para>

        <para><computeroutput>10.0 </computeroutput></para>

        <para><computeroutput>10.0</computeroutput></para>

        <para>Changing the argument myX causes makePoint to be called again.
        But, the function makePoint is a black-box. The change to scale won't
        cause an update. That's where bound functions come in.</para>

        <para></para>
      </sect2>

      <sect2>
        <title>Bound Functions</title>

        <para>Bound functions have as their body a block-expression which is
        bound (it thus has the above restrictions on bound block-expressions).
        When binding to a bound function, changes besides the arguments causes
        update, and argument changes are seen by the function. So, if the
        above function makePoint were instead a bound function:</para>

        <para><programlisting>bound function makePoint(x0 : Number, y0 : Number) : Point {</programlisting></para>

        <para>The scale change would cause an update (20.0). Note also, that
        if myX changed only x0 * scale would be recalculated, not y0 *
        scale.</para>

        <para>Calling a bound function from outside a bind is just like
        calling a non-bound function.</para>

        <para></para>

        <para></para>
      </sect2>

      <sect2>
        <title>Object Literals</title>

        <para>Object literals behave like simple operators (+, etc) and
        non-bound functions. That is, if one of the arguments to the object
        literal changes then it is re-executed (a new instance is
        created).</para>

        <para><programlisting>def pt = bind Point { 
   x: myX
   y: myY  
}</programlisting></para>

        <para>if myX changes a new Point object is built -- this is exactly
        what you want for immutable objects.</para>

        <para>What if you want the value of x to track the value of myX,
        without creating a new Point? Then you bind the instance variable
        initializers:</para>

        <programlisting>def pt = bind Point { 
   x: bind myX
   y: myY  
}</programlisting>

        <para>Now if myX changes, the x attribute of point will be updated,
        but the object literal's instance variable initializer hasn't changed
        (x is still, and will always be, bound to myX). Changes to myY will
        still cause a new Point to be created.</para>

        <para>So, what you would actually want for this example would
        be:</para>

        <programlisting>def pt = Point { 
   x: bind myX
   y: bind myY  
}</programlisting>

        <para>Here pt would always remain the same Point instance. Note that
        there is no longer a need for <command>bind</command> on the
        initializing expression of pt since there are no dependencies.</para>

        <para></para>

        <para></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Bind Definitions</title>

      <para>A bound expression is an expression whose value updates when its
      dependencies change. Dependencies, the update mechanism, and the
      creation of bound expressions are discussed below.</para>

      <para>Bound expressions are evaluated in bind context; all other
      evaluation is in a normal context. A bound expression may not contain
      assignment or iteration. Assignment includes increment and decrement.
      Iteration is the <command>while</command>-loop (not
      <command>for</command>-expression).</para>

      <para>A variable (instance, script, or local variable) can be bound to
      an expression. That expression, of course, is a bound expression.</para>

      <para>A local variable definition with an initializing expression
      creates a binding from the local variable to the expression if the
      definition is explicitly bound:</para>

      <para><programlisting>def <emphasis>varName</emphasis> = bind <emphasis>expression</emphasis></programlisting></para>

      <para>or if the definition is in a bind context.</para>

      <para>A script variable definition with an initializing expression
      creates a binding from the instance variable to the expression if the
      definition is explicitly bound.</para>

      <para>An instance variable definition with an initializing expression
      creates a binding from the instance variable to the expression if the
      definition is explicitly bound and is not overriden or superceded by an
      object literal initializing expression. Class definitions are not
      evaluated and thus do not have bind contexts, so instance variable
      initialization without an explicit <command>bind</command> cannot create
      a binding. An object literal component creates a binding from the
      instance variable to the expression if the component is explicitly
      bound:</para>

      <para><programlisting><emphasis>className</emphasis> { <emphasis>instanceVariableName</emphasis>: bind <emphasis>expression</emphasis> } </programlisting></para>

      <para>A binding between a variable and an expression means intuitively
      that the variable maintains the value of the expression. Specifically,
      this means the variable is updated when the dependencies of the
      expression change.</para>

      <para><remark>This paragraph needs to be revamped:</remark> A bound
      function has, as its body, an expression which may be bound. The body of
      a bound function invoked from a bind context is a bound expression, as
      is the value of a bound block expression. The dependencies of a bound
      expression are as follows: The dependencies of a variable reference is
      the variable. A literal has no dependencies. An object literal has its
      referenced unbound instance variables. The dependencies of an arithmetic
      or Boolean operation is the union of the dependencies of its components.
      For example, the dependencies of: a + b are the union of the
      dependencies of "a" and the dependencies of "b". The dependencies of a
      conditional are the union of the dependencies of its components
      (condition, true-part, and false-part). For example, the dependencies
      of: if (cond) a else b are the union of the dependencies of "cond", the
      dependencies of "a" and the dependencies of "b". It may or may not be
      desirable to optimize this to a conditional dynamic dependency. The
      dependencies of foreach aren't addressed here. The dependencies of a
      block expression are the dependencies of its value. Where its value is
      the terminal expression or the value of the terminal return statement.
      The dependencies of a bound function invocation are the dependencies of
      the body of the function (the body of a function is a block expression).
      That is, when invoking a function in a bind context, the body of the
      function (along with its arguments) is a bound expression -- the
      invocation's dependencies are the dependencies of the bound body. Note
      that the dependencies of the arguments are not directly dependencies of
      the invocation, but they will be included in the dependencies of the
      body unless the result of the function does not depend on the
      corresponding parameter.</para>

      <para>The dependencies of a non-bound function invocation are the
      dependencies of the arguments. When a bound expression is updated,
      expression evaluation is identical to normal expression evaluation for
      literals, variable references, arithmetic and Boolean operators,
      conditional expressions, and non-bound function invocation. An update
      does not cause the re-evaluation of a bound function invocation, rather
      the current value of this bound expression is used. Note that the update
      may occur in the opposite direction, that is, a change to the
      dependencies of a bound function body will trigger an update to the
      invoking bound expression.</para>

      <para></para>
    </sect1>
  </chapter>

  <chapter>
    <title>Error Handling and Exceptions</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Conversions</title>

    <para></para>
  </chapter>

  <chapter>
    <title>Access Modifiers</title>

    <para></para>
  </chapter>
</book>
