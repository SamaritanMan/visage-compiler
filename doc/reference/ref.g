/*
 * Copyright 2007-2009 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4 of the Visage parser grammar.
//
// @author Jim Idle
//
// Version 4 of the grammar reverts to a spearate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// JavafxTree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar ref;

options { 

	// Rather than embed parser oriented Java code in this grammar, just to override
	// methods in the ANTLR base recognizer and derviative classes, we
	// instruct ANTLR to generate a class which is dervied from our own
	// super class. The super class is where we embody any code that does
	// not require direct access to the methods generated 
	// to implement the parser. Hence for instance this is where the 
	// JavafxTreeMaker lives.
	//
	superClass 	= AbstractGeneratedParserV4; 

	// Import the token vocabulary, generated by the
	// lexer grammar analysis.
	//
	tokenVocab	= v4Lexer;
}

// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package org.visage.tools.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.javac.tree.*;
import org.visage.tools.tree.*;
import org.visage.api.tree.*;

import com.sun.tools.javac.util.*;
import org.visage.tools.util.MsgSym;

import com.sun.tools.javac.code.*;
import org.visage.tools.code.JavafxFlags;
import static com.sun.tools.javac.util.ListBuffer.lb;
import org.visage.api.JavafxBindStatus;

import static org.visage.api.JavafxBindStatus.*;

}


 

script

	:  pd=packageDecl si=scriptItems 
	
		{
			// Construct the Visage AST
			//
			$result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment);	// Add any detected documentation comment
            
   			// Set tree span and endpoint map (if required).
        	//
        	$result.pos = rPos;
        	endPos($result); 
        	
        	// Pass on the documentation comments and the endpos map
        	//
        	$result.docComments 	= docComments;
        	$result.endPositions	= endPositions;
		}

		EOF 	// Forces parser to consume entire token stream or error out
    ;
    

packageDecl
    : PACKAGE qualifiedName SEMI
    
    		{ $value = $qualifiedName.value; }
    		
    | // No package specified
    
    		{ $value = null; }
	;
	
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

	
	returns [ListBuffer<VisageTree> items = new ListBuffer<VisageTree>()] // This rule builds a list of VisageTree, which is used 
																	// by the caller to build the actual AST.
																	//
	:
		(
			  // Certain script members may be prefixed with modifiers
			  // such as 'public'. We allow the parser to first consume 
			  // all modifier keywords, regardless of whether this is a 
			  // valid modifier for the upcoming declaration. Whether it is
			  // valid or not is a matter for semantic checks to decide.
			  //
			  // Script level variable declarations can conflict with
			  // local variable declarations (which do not allow modifiers
			  // and are encapsulated in the expression rule, which is called
			  // by the statement rule. Hence we must special case it here
			  // unless we want to pass around status to all our rules.
			  // The predicate is a small one and passes or fails quickly.
			  //
			  (modifiers (VAR|DEF|ATTRIBUTE|CLASS|FUNCTION))=>
			  	m1=modifiers
				(
					  c=classDefinition			[$m1.mods]
					  
					 		{ 
								$items.append($c.value); 
							}
							
					| v=variableDeclaration 	[$m1.mods] 
					
							{ 
								$items.append($v.value); 
							}
							
					| f=functionDefinition    	[$m1.mods]
					

					 		{ 
								$items.append($f.value); 
							}
				)
				
			| i=importDecl
			
				{ 
					$items.append($i.value); 
				}
			
			| s=expression
			
				{ 
					$items.append($s.value); 
				}
			
			| SEMI
		)*
	;

// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the smeantics of the modifiers.
//
modifiers

	returns [VisageModifiers mods]	// Constructs and returns a specialized modifer node

@init {

	// The flags we build up for the AST
	//
	long	flags 	= 0;
	
	// The start character position for this AST
	//
	int   	cPos		= pos();
}

	: 	(	
			mf=modifierFlag
			
			{
				// Or in the newly discovered modifier
				//
				flags	|= $mf.flag;
			}
	
		)*
		
		{
			// Build the modifier flags (just as empty if we did not pick any up)
			//
			$mods = F.at(cPos).Modifiers(flags);
			
			// Tree span
			//
			endPos($mods);
		}
	;

// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

	returns [long flag]
	
	: ABSTRACT			{ $flag = Flags.ABSTRACT;				}
	| BOUND				{ $flag = JavafxFlags.BOUND;			}
	| OVERRIDE			{ $flag = JavafxFlags.OVERRIDE;			}
	| PACKAGE			{ $flag = JavafxFlags.PACKAGE_ACCESS;	}
	| PROTECTED			{ $flag = Flags.PROTECTED;				}
	| PUBLIC			{ $flag = Flags.PUBLIC;					}
	| PUBLIC_READ   	{ $flag = JavafxFlags.PUBLIC_READ;		}
	| PUBLIC_INIT		{ $flag = JavafxFlags.PUBLIC_INIT;		}
	;

// -----------------	
// Import statement.
// Include definitions from an external source
//
importDecl

	returns [VisageTree value] // The import declaration is built as a generic VisageTree

 	: IMPORT importId
 	
 		{
 			// AST construction
 			$value = F.at(pos($IMPORT)).Import($importId.pid);
 			
 			// AST span

 			//
			endPos($value);
 		}
	;
	
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

	returns [VisageExpression pid]	// Qualified names are built as expression trees

 	: i1=identifier
 		{
 			$pid = $i1.value;
 		}
		( 
			d1=DOT n2=name
		
				{
					$pid = F.at($n2.pos).Select($pid, $n2.value);
                    endPos($pid);
				}
		)* 
        ( 
        	DOT STAR
        	
        		{
					$pid = F.at($n2.pos).Select($pid, names.asterisk);
                    endPos($pid);
				}
        )?  
	;
	
classDefinition 
	: modifiers 'class' name superclasses 
		'{' 
			 (
		        classMember 
		      | ';'
	         )* 
		'}'
	;
	
superclasses 
	: 'extends' typeName
           ( 
           	',' typeName 
           )*
           
	| // Upsilon - this class inherits no other types so the list will be empty
	;
		  					
classMember
	: functionDefinition
	| variableDeclaration	
	| variableOverrideDeclaration	
	| initBlock
	| postinitBlock
	;


// ----------
// Functions.
// While funcitnos can be declared at any level, their syntax is the same.
// As always, the semantic pass of the Visage tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition 
	: modifiers 'function' name formalParameters typeSpecifier 
		(block)?

	;

variableOverrideDeclaration
	: 'override' 'var' name ('=' initializingExpression)? onReplaceClause?
	;

// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initBlock
	: 'init' block
	;

// Post initialization.
// Parse the post initialization block and produce the AST
//
postinitBlock
	: 'postinit' block
	;
	
variableDeclaration 
	: modifiers (('def' )   | ( 'var' ) ) name typeSpecifier 

        (
            '=' initializingExpression
        )? 
        
        (
            onReplaceClause
        )?
	;
	
// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters
	: '(' 
	
		(
			fp1=formalParameter 
	
			(
				',' fp2=formalParameter
			)*  
		)?
			
	  ')'
	;
	
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

	: name typeSpecifier
	;

block 
	: '{' 
	
		(
			expression
				
			| ';'
	   )*
	
	  '}'
	;

// -----------
// statements.
// Parse the set of elments that are viewed as programmig statements. Note
// that this includes expressions which are considered statements.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, whether this is optional, or whether this is just
// not required (such as if () {} ).
//
expression 
	: insert	
	| delete	
 	| while		
	| break
	| continue
    | throw	   
    | return 		
    | try			
    | valueExpression (';')?						
    ;
  
break
	:	'break'   ';'
	;
continue
	:	'continue'  	 ';'
	;
// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

	
	: 'on' 'replace' name? 
	
		(
			  ('[' name '..' name ']')?
			 
				 '=' name
		)? 
		block
		;
	
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

	returns [VisageVar var]	// Returns a VisageVar tree node

    : paramName
    	{
    		{ $var = $paramName.var; }
    	}
    	
    |	{ $var = null; }
    ;

// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

	returns [VisageVar var]	// Returns a VisageVar tree node

	: name
		{
    		{ 
    			$var = F.at($name.pos).Param($name.value, F.TypeUnknown()); 
    			endPos($var);
    		}
    	}
	;
	
    
// The ways in which a variable can be declared
//
variableLabel 
	
	returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
	
	: VAR			{ $modifiers = 0L; $pos = pos($VAR); }
	| DEF			{ $modifiers = JavafxFlags.IS_DEF; $pos = pos($DEF); }
	| ATTRIBUTE		{ $modifiers = 0L; $pos = pos($ATTRIBUTE); log.warning(pos($ATTRIBUTE), "visage.not.supported.attribute"); }
	;

// ------	
// Throw.
// Parse the standard exception throwing mechanism.
//
throw

	returns [VisageExpression value]	// Returns the Visage Expression tree representing what we must throw

	: THROW valueExpression ((SEMI)=>SEMI)?
	
		{ 
			// AST for the thrown expression
			//
			$value = F.at(pos($THROW)).Throw($valueExpression.value);
			
			// Tree span
			//
			endPos($value);
		}
	;

// ---------------
// While statement
//
while
	: 'while' '(' valueExpression ')' 
	expression
	;

// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insert  
	: 'insert' elem=valueExpression
		(
			  'into' eseq=valueExpression
			| 'before' isfi=indexedSequenceForInsert
			| 'after' isfi=indexedSequenceForInsert
		)	    
	    (';')?
	;
	
indexedSequenceForInsert
	: primaryExpression 			
	  '[' valueExpression ']'	
 	;
 
// -----------------	
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
delete  
	: 'delete' e1=valueExpression
	   ( 
	   		  'from' valueExpression	
	   		| /* indexed and whole cases */	
	   )
	   (';')?
	;

// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
return
	: 'return' 
		(
			  valueExpression		

			  	(';')?
			  	
			| ';'			// Can't have a SEMI be optional here as we must eitehr consume

		)
	
	;
	
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
try
	: 'try' block 			
		(
		 	  f1=finallyClause
	   		| (
	   				catchClause
	   				
	   				{
	   					// Accumulate the catch clauses
	   					//
	   					caught.append($catchClause.value);
	   				}
	   		  )+ 
	   			
	   			( 
	   				f1=finallyClause
	   			)?   
	   	)

	;
	
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//
finallyClause
	: 'finally' block
	;
	
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause
	: 'catch' '(' formalParameter ')' block
	;
	
initializingExpression 

	: 'bind' valueExpression 
	
			(
				'with' 'inverse'
			)?
	
	| valueExpression
	;
	
// -----------
// expression.
// General expression parse and AST build.
//
valueExpression
	: ifExpression	
	| forExpression   			
	| newExpression	
	| // Expressions can only declare local variables, hence we
	  	variableDeclaration 

	| assignmentExpression		
	;

// ------------------------
// FOR statement/expression
//
forExpression
	: 'for' 
		'(' 
		
			i1=inClause			
			(',' i2=inClause)* 
			
		')' 
		
		expression
				
			{
		 		$value = F.at(pos($FOR)).ForExpression(clauses.toList(), $expression.value);
			}
		
		{
			// Tree span
			//
			endPos($value);
		}
	;

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause
	: formalParameter 'in' se=valueExpression 
		(
			  'where' we=valueExpression	
			|
		)

	;
	
// -----------------------
// If Then Else expression
//
ifExpression 
	: 'if' '(' valueExpression  ')' 
	
		'then'?  expression 			
			(
				'else' expression	
			)?

	;
	
	

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  
	: lhs=assignmentOpExpression 
		(     
			  '=' valueExpression
			|	// Just an expression without an assignment
		)
	;
	
assignmentOpExpression
	: orExpression					
	  
		(     (('+=') | ('-=') | ('*=') | ('/=')) valueExpression
           	| '=>' such=orExpression ('tween' orExpression)?
	   		|
	   )
	;


// -----------------
// Assign operators
// All the operators that involve assignments.
//	
assignOp

	returns	[JavafxTag op]	// Returns the operation token that we find
	
	: PLUSEQ		{ $op = JavafxTag.PLUS_ASG; 			}
	| SUBEQ			{ $op = JavafxTag.MINUS_ASG;			}
	| STAREQ		{ $op = JavafxTag.MUL_ASG;              }
	| SLASHEQ		{ $op = JavafxTag.DIV_ASG;				}
	| PERCENTEQ
		{ 
			$op = JavafxTag.MOD_ASG;
			log.warning(pos($PERCENTEQ), MsgSym.MESSAGE_VISAGE_GENERALWARNING, "The operator \%= will not be supported in the Visage 1.0 release" );
		}
	;
	

orExpression

	returns [VisageExpression value] 	
		
	:	e1=andExpression
			
	  		( 
	  			'or' e2=andExpression
	  		)*
	;
	

andExpression

	returns [VisageExpression value] 	
		
	: e1=typeExpression
	  	( 
	  		'and' e2=typeExpression 
	  	)*
	;
	
// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

	returns [VisageExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: relationalExpression		

		(
			  INSTANCEOF itn=type
			
				{
					$value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
					endPos($value);
				}
				
			| AS atn=type
			
				{
					$value = F.at(pos($AS)).TypeCast($atn.rtype, $relationalExpression.value);
					endPos($value);
				}
			
			| 	{
					$value = $relationalExpression.value;
				}
	   )
	;

// -----------
// Relationals
// LL(k) precedence
//	
relationalExpression  

	returns [VisageExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: a1=additiveExpression	{ $value = $a1.value;	}
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			relOps   a2=additiveExpression
			  	
			  	{
			  		$value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
			  		endPos($value);
			  	}
		)* 
	;
	
// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

	: NOTEQ  { $relOp = JavafxTag.NE;	}
	| EQEQ   { $relOp = JavafxTag.EQ;	}
	| LTEQ   { $relOp = JavafxTag.LE;	}
	| GTEQ   { $relOp = JavafxTag.GE;	}
	| LT     { $relOp = JavafxTag.LT;	}
	| GT     { $relOp = JavafxTag.GT;	}
	;

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//	
additiveExpression 
	: m1=multiplicativeExpression	
		{ 
			$value = $m1.value; 
		}
		(
			
			
		    (arithOps)=>
		    
		    	{ rPos = pos(); }	// Use operator as position for AST
		    	
		    	arithOps   m2=multiplicativeExpression
		)* 
	;

// --------------------
// Arithmetic operators
//
arithOps
	: PLUS		{ $arithOp = JavafxTag.PLUS; 	}
	| SUB		{ $arithOp = JavafxTag.MINUS;	}
	;

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//	
multiplicativeExpression
	: u1=unaryExpression	{ $value = $u1.value; }
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			multOps u2=unaryExpression
				
				{
					$value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
					endPos($value);
				}
	   )* 
	;

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

	returns [JavafxTag multOp]	// Returns the Visage operator type
	
	: STAR    	{ $multOp = JavafxTag.MUL;	}
	| SLASH   	{ $multOp = JavafxTag.DIV;	}
	| PERCENT 	
			
		{
			$multOp = JavafxTag.MOD;
			log.warning(pos($PERCENT), MsgSym.MESSAGE_VISAGE_GENERALWARNING, "The remainder operator \% will be replaced by mod" );
		}	
             
	| MOD		{ $multOp = JavafxTag.MOD;	}
	;
	
// -----------------	
// Unary expressions
// LL(k) Precedence
//
unaryExpression
	: suffixedExpression
	| 'indexof'		identifier
	| ( ('-') | ('not') | ('sizeof') | ('++') | ('--') | ('reverse'))     	unaryExpression
	;
	
// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps
	: SUB			{ $unOp = JavafxTag.NEG; }
	| NOT			{ $unOp = JavafxTag.NOT; }
	| SIZEOF		{ $unOp = JavafxTag.SIZEOF; }
	| PLUSPLUS		{ $unOp = JavafxTag.PREINC; }
	| SUBSUB		{ $unOp = JavafxTag.PREDEC; }
	| REVERSE		{ $unOp = JavafxTag.REVERSE; }
	;

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 
	: postfixExpression
		( 
			  '++'
			  	
			| '--'
				
			| 
		)
	;
	
postfixExpressionPartialFunctionInvocation
	: pe=primaryExpression	
	
		(  ( '(' expressionList ')' )
	   	)
	;
	
otherPostfixExpressionForms
	:
	;

postfixExpression 
	: primaryExpression	
		( 
			  '.' name
			| '('  expressionList ')'
			| '[' name '|'  valueExpression  ']'
			| '[' valueExpression  ']'
			| '[' (
					 valueExpression
						(
	                    	 '..' 
	                    		(
									  ('<'  )? 
									  	(
									  		last=valueExpression
									  	)?
									  	
								)
                    	)
             	)
             	']'
	   	)* 
	;

memberAccess
	:	'.' name
	;

functionInvocation
	:	'('  expressionList ')'
	;

sequenceSelect
	:	'[' name '|'  valueExpression  ']'
	;

index
	: '[' valueExpression  ']'
	;
	

slice
	: '[' (
					 valueExpression
						(
	                    	 '..' 
	                    		(
									  ('<'  )? 
									  	(
									  		last=valueExpression
									  	)?
									  	
								)
                    	)
             	)
             	']'
	;

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//	
primaryExpression  
	: qualifiedName
	| objectLiteral
	| 'this'
	| stringExpression
	| explicitSequenceExpression		
	| rangeExpression
	| block
	| literal		
	| functionExpression
	| '(' valueExpression ')'
	| timelineExpression
	;
	
timelineExpression
	:	'at' 
		'(' 
			TIME_LITERAL
		')' 
		'{' 
			k=keyFrameLiteralPart 
		'}'
		;
// ------------
// Frame values
//  
keyFrameLiteralPart
	: k1=valueExpression 	
		(';'
		
			k2=valueExpression		
		)* ';'?
    ;

// -------------------
// Anonymous functions
//
functionExpression
	: 'function' formalParameters typeSpecifier block
	;
	
// ---
// NEW
//
newExpression
	: 'new' typeName ('(' expressionList ')')?
	;

// ---------------
// Object literals
//
objectLiteral
	:   qualifiedName
			'{'   

			((',')|(';'))*	
		(		
			objectLiteralPart 
			((',')|(';'))*	// Separators are optional and just syntactic sugar
			
			
		)*		// May be no elements in the object literal, just {}
	
		'}'	
	;

// Individual components of an object literal
//
objectLiteralPart
	: variableOverrideDeclaration
	| variableDeclaration 
	| functionDefinition	
	| objectLiteralInit
    ;
  
// --------------------------     	
// Object literal initializer
//	
objectLiteralInit
	: name ':'  initializingExpression
	;

// -------	
// Strings
// Visage string expresoins are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time
//    over which the script author then has unambiguous control over
//    leading spaces, can explictly insert new lines, and can comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leades to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Individual compound parts cannot be translated individually;
//
stringExpression 
	: (
		  (
			// Translation key is optional
		  	//
		  	TRANSLATION_KEY	{ translationKey = $TRANSLATION_KEY.text; } 
		  )?
	
			// We must find at least one compund element to the string
			//
			strCompoundElement [ strexp ]
			
			(
				// After the first element, there may be any number of additional
				// elements, including zero. We must force the parser to take
				// the righteous path for syntactically correct constructs, then
				// error out semantically on anything else.
				//
				   strCompoundElement [ strexp ]
			)*
	  )
	;
	
// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<VisageExpression> strexp ]
	
	: STRING_LITERAL		
	| qlsl 			[ strexp ]
	;
	
	
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<VisageExpression> strexp]
	: 	//QUOTE_LBRACE_STRING_LITERAL	
		QUOTE
	  	( STRING '{'
		FORMAT_STRING_LITERAL? valueExpression '}'  )+
	  
	  	// The last component of the {} enclosing string literal
	  	//
	  	//RBRACE_QUOTE_STRING_LITERAL
	  	STRING QUOTE
	;
QUOTE 
	:	 ;
STRING 
	:	 ;	
// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<VisageExpression> strexp]
	: //RBRACE_LBRACE_STRING_LITERAL 
		'}' STRING '{'
		formattedExpression
	;
	
formattedExpression 
	: FORMAT_STRING_LITERAL? valueExpression
	;
	
explicitSequenceExpression
	: '['   
		( 	e1=valueExpression
		     		(','
		     		  valueExpression
		     		  )*
		     				','?
		     |  // Empty sequence 
	    )
	  ']'
	;

rangeExpression
	: '['   
		( 	e1=valueExpression
		     	 '..'
		     			('<' )? 
		     			dd=valueExpression
		     	    	( 'step' st=valueExpression  )?
	    )
	  ']'
	;

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList
	: e1=valueExpression
		(
			',' 	(
						e2=valueExpression
					)
		)*
	|
	;

// -----
// Types
//
type

	returns [VisageType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: typeName cardinality
	
		{
			$rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
			endPos($rtype);
		}
		
 	| FUNCTION 
 		LPAREN 
 			typeArgList
		RPAREN 
		
			ret=typeSpecifier 
          	cardinality	//TODO: this introduces an ambiguity: return cardinality vs type cardinality
          	
		{
			$rtype = F.at(rPos).TypeFunctional($typeArgList.ptypes.toList(), $ret.rtype, $cardinality.ary);
			endPos($rtype);
		}

 	| STAR cardinality
 	
 		{
 			$rtype = F.at(rPos).TypeAny($cardinality.ary);
 			endPos($rtype);
 		}
 	;

// ----------------------------
// A list of types as arguments
//
typeArgList
 	
 returns [ListBuffer<VisageType> ptypes = ListBuffer.<VisageType>lb(); ]
 
 	: t1=typeArg
 	
 		{
 			ptypes.append($t1.rtype);
 		}
 		 
 		(
 			COMMA 
 			(
 				t2=typeArg
 				
 				{
 					ptypes.append($t2.rtype);
 				}
 			)?
 		)*
 	|
	;

// -------------------------
// Individual typed argument
//
typeArg 

	returns [VisageType rtype]

 	: (
 		(
 			name	// TODO: Check this, it is currently ignored for AST and does not
 					//       look quite right.
 		)? 
 			COLON
 	  )?
 	  
 	  type
 	
 		{
 			$rtype = $type.rtype;
 		}
 	;
 	
 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeSpecifier	
 	: ':' type
 	| // Untyped element, the AST needs to reflect that

 	;
 	
// -------------------------
// Array indicator for types
//
cardinality
	: '[]'
	
	|	
	;

// ----------
// Named type

// Possibly a generic
//
typeName

	returns [VisageExpression value]

@init
{
	// Accumulate any generic arguments
	//
	ListBuffer<VisageExpression> exprbuff = ListBuffer.<VisageExpression>lb();
}

	: qualifiedName 		
		(
			  LT ga1=genericArgument 	{ exprbuff.append($ga1.value); }
			  	
			  		(
			  			COMMA
			  				(
			  					ga2=genericArgument
			  				
			  							{ exprbuff.append($ga2.value); }
			  				)?
			  		)* 
			  GT
			  
			  {
			  	// AST for generic
			  	//
			  	// TODO: Implement this?
			  	//
			  	log.error(pos($LT), "visage.generalerror", "Java generic type declarations are not currently supported");
			  }
			  
			|	// Non generic
				{
					$value = $qualifiedName.value;
				}
		)
	;
	
genericArgument
	: typeName	{ $value = $typeName.value; }
	
	| QUES 
		(  
			( 
				  EXTENDS 		{ bk = BoundKind.EXTENDS; 	}
		  		| SUPER			{ bk = BoundKind.SUPER; 	}
		  	) 
		 	typeName			{ texpr = $typeName.value; }
		)?
	;

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal
	: 
			 (DECIMAL_LITERAL	)	
			| (OCTAL_LITERAL	)	
			| (HEX_LITERAL		)	
		    | (TIME_LITERAL	)	
			| (FLOATING_POINT_LITERAL	)		
			| ('true'	)	
			| ('false'	)	
			| ('null'	)	
	;

// -------------------------	
// Qualified (possibly) name
//
qualifiedName
	: name
		( 
			'.' name
		)*  
	;

// -----------------------
// ID
// Basic identifier parse
//
identifier

	returns [VisageIdent value]

	: n1=name
		{
			$value = F.at($n1.pos).Ident($n1.value);
						endPos($value, $n1.pos + $n1.value.length());
		}
	;

// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it coudl just be a tag or function name etc.
//
name 

	returns [Name value, int pos]
	
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = pos($IDENTIFIER); 
		}
						
	;
