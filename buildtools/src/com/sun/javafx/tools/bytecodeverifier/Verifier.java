/*
 * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

package com.sun.javafx.tools.bytecodeverifier;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;
import org.objectweb.asm.tree.analysis.*;
import org.objectweb.asm.util.CheckClassAdapter;

/**
 * This class verifies bytecode in .class files, .jar files and
 * in directories (recursively) using Objectweb's ASM library.
 *
 * This is intendend to be used to verify class files generated by 
 * javafxc and the mangler tool.
 *
 * @author A. Sundararajan
 */
public class Verifier {
    // do not create me!
    private Verifier() {}

    private static void verify(ClassReader reader, final PrintWriter err) {
        ClassNode classNode = new ClassNode();
        reader.accept(new CheckClassAdapter(classNode), ClassReader.SKIP_DEBUG);

        Type syperType = classNode.superName == null
                ? null : Type.getObjectType(classNode.superName);
        List<Type> interfaces = new ArrayList<Type>();
        for (Object iface : classNode.interfaces) {
            interfaces.add(Type.getObjectType(iface.toString()));
        }

        List<MethodNode> methods = classNode.methods;
        for (int i = 0; i < methods.size(); i++) {
            MethodNode method = methods.get(i);
            SimpleVerifier verifier = new SimpleVerifier(
                    Type.getObjectType(classNode.name),
                    syperType, interfaces, false) {
                @Override
                protected boolean isAssignableFrom(Type t, Type u) {
                    // FIXME: Assignment check in the superclass implementation uses
                    // Class.forName to check currently loaded classes. We don't want 
                    // to use loaded Class objects in the test. We leave the reference 
                    // assignment compatibility checks for now.
                    return true;
                }
            };

            Analyzer analyzer = new Analyzer(verifier);
            try {
                analyzer.analyze(classNode.name, method);
            } catch (Exception exp) {
                exp.printStackTrace(err);
            }
        }
        err.flush();
    }

    private static void verifyClass(InputStream is, PrintWriter err) 
            throws IOException {
        ClassReader cr = new ClassReader(is);
        ClassWriter cw = new ClassWriter(cr, ClassWriter.COMPUTE_MAXS);
        ClassVisitor cv = new CheckClassAdapter(cw);
        cr.accept(cv, 0);
        verify(new ClassReader(cw.toByteArray()), err);
    }

    private static void verifyZip(ZipInputStream zis, PrintWriter err) 
            throws IOException {
        try {
            ZipEntry ze = zis.getNextEntry();
            while (ze != null) {
                if (! ze.isDirectory()) {
                    String zname = ze.getName();
                    if (zname.endsWith(".class")) {
                        err.println("Verifying " + ze.getName());
                        verifyClass(zis, err); 
                    }
                }
                zis.closeEntry();
                ze = zis.getNextEntry();
            }
        } catch (ZipException ex) {
            err.println(ex);
            ex.printStackTrace(err);
        }
    }

    public static void verifyFile(File f, PrintWriter err) throws IOException {
        if (! f.exists()) {
            err.println(f.getAbsolutePath() + " does not exist!");
        }
        if (f.isDirectory()) {
            File[] contents = f.listFiles();
            for (File c : contents) {
                verifyFile(c, err);
            }
        } else {
            String path = f.getAbsolutePath();
            InputStream is = new BufferedInputStream(new FileInputStream(f));
            if (path.endsWith(".jar") || path.endsWith(".zip")) {
                ZipInputStream zis = null;
                try {
                    err.println("Verifying " + path);
                    zis = new ZipInputStream(is);
                    verifyZip(zis, err);
                } finally {
                    if (zis != null) zis.close();
                    if (is != null) is.close();
                }
            } else if (path.endsWith(".class")) {
                // verify single .class
                try {
                    err.println("Verifying " + path);
                    verifyClass(is, err);
                } finally {
                    if (is != null) is.close();
                }
            }
        }
    }

    public static void verifyPath(String path, PrintWriter err) throws IOException {
        String[] files = path.split(File.pathSeparator);
        for (String file : files) {
            verifyFile(new File(file), err);
        }
    }

    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java " + Verifier.class + " <path>");
            System.exit(1);
        }
        try {
            verifyPath(args[0], new PrintWriter(System.out));
        } catch (IOException exp) {
            exp.printStackTrace();
        }
    }
}
