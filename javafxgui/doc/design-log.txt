
[04/21/2008 - Hans]  Revised what Node bounds mean

After talking this over with Jim, the minimalist interpretation of
bounds seems too non-intuitive.   So now, the bounds of this:

    Rectangle { width:10 height:20 translateX:45 }

Will be x,y width,height 45,0 10,20 - which is what most people
would probably expect.  




[04/21/2008 - Hans]  Added support for Node bounds binding

The current Node getX,Y,Width,Height() methods return a Node's
intrinsic bounds.  For example if you define a rectangle like this:

    Rectangle { width:10 height:20 }

It's x,y width,height bounds would be 0,0 10,20.   Note that that's 
also the case if any of the transform attributes were specified.
For example the bounds of 

    Rectangle { width:10 height:20 rotation:45 }

is still 0,0 10,20.  

Until this morning, binding to the getX,Y,Width,Height() functions
didn't work (despite the deceptive "bound" qualifier).  They now do
work correctly, albeit with a small compromise for efficiency's sake.
The internal state that the four bounds functions depend on is only
updated after the scene's Canvas#doLayout() method runs.  Whenever the
bounds of any node changes the Node calls the (currently internal)
requestLayout function, which marks all of the node's Group ancestors
as in need of layout.  This method also calls JComponent#revalidate on
the Canvas, which queues a request to "validate the layout" on the
EDT, if one hasn't been queued already.  When this request is handled,
Canvas#doLayout() updates all of the VBox and HBox groups' children
and then updates the private currentBounds java.awt.Rectangle
attribute that the getX,Y,Width,Height() functions depend on.





[04/11/2008 - Shannon]

Consider List selection, and other attributes like it
(TextField.text, ComboBox.selection, etc...)

Do we really want to get into the business of providing function attributes
such as: onSelectionChange(), onType(), etc? The answer is no. For things like
this where there's already a public attribute, why add more attributes to
confuse the API? The need to do so simply illustrates that the language
doesn't provide a nice enough way to attach code to state changes in these
attributes. I've filed the following bug on the issue:

http://openjfx.java.sun.com/jira/browse/JFXC-1083

For the time being, you can use:

List {
    override attribute selection on replace { ...... }
}

Hopefully, in the future, we'll get something like:

List {
    selection: on replace { ... }
}


[04/09/2008 - Shannon] Preferred Size attribute

Made the decision tonight between the following:

preferredSize: [800, 600]
  VS.
preferredSize: Dimension{width: 800 height: 600}

Solicited input from a few sources. Both ways have merit. It feels
that adding a class, Dimension, just for this is too heavy when
all we really want is a tuple. The former is also simpler to write.
And it has the benefit in that it simulates mutability: Dimensions
would be immutable, and to make a change you'd need to set a new
Dimension for the attribute (or we'd need to see Chris Oliver's
value types proposal fully come to light). But using a sequence,
you CAN modify it and have the Component respond, since it gets
a trigger.


[04/08/2008 - Hans] More gratuitous name changes 

Changed the Arc API to match SGArc.  Instead of defining the 
arc with a "framing rectangle" as in Java2D, the arc's geometry
is defined with attributes like the ones used for Circle and 
Ellipse: centerX,Y and radiusX,Y.

- Made some (hopefully) minor incompatible name changes in the 
curve shape classes: 

  In QuadCurve: ctrlx, ctrly => ctrlX, ctrlY
  Similarly, in CubicCurve: ctrlx1,2, ctrly1,2 => ctrlX1,2, ctrlY1,2

These names match the ones in SGQuadCurve and SGCubicCurve and they're
consistent with the overall logical capitalization pattern we've followed 



[04/08/2008 - Hans] The "initializing" flag in Node subclasses

Most of the Node subclasses use the same simple pattern for keeping
an encapsulated SGNode in sync:

    private attribute initializing:Boolean = true;

    init { initializing = false; u(); }

    private function u():Void {  
        if (initializing) { return; }
        // ... update encapsulated SGNode based
        // on ALL of the public attributes
    }

    public attribute foo on replace { u(); } 
    // ...

Since the class's init trigger runs *after* all of this class's
attributes have been initialized and all of their 'on replace'
triggers have run, we're basically deferring sync'ing.

Without this hack, the "u()" update function would be called
before all of the attributes had their initial values.  Sometimes
that causes errors, and sometimes it's just wasteful.


[04/04/2008 - Shannon]

I've discussed separately with both Hans Muller and Chris Oliver. We're
making a decision that we absolutely don't care about dynamic look and
feel switching at runtime. As such, we'll not make any heroic efforts to
make it work.


[03/27/2008 - Shannon]

After discussion with, and on the request of, Chris Oliver:
I've decided to change the names of the onAction and onVerify function
attributes to action and verify respectively. Makes more sense from
an English language point of view.

When we're dealing with function attributes that represent a response to
a particular event, we should continue with the "on" prefix.


[3/20/2008 - Hans] Keyboard Input

I've added Node callback attributes for keyPressed,Released,Typed, a
KeyEvent class, support for requesting the focus, and for notification
when it's granted.  All of this stuff closely mirrors the corresponding
APIs in Scenario and is fairly close to what's in the the compiler
runtime now.  

The Node API looks like this:

    public function requestFocus():Void
    public bound function hasFocus():Boolean 
    public bound function isFocusable():Boolean

    public attribute onKeyPressed: function(e:KeyEvent):Void
    public attribute onKeyReleased: function(e:KeyEvent):Void 
    public attribute onKeyTyped: function(e:KeyEvent):Void

The isFocusable() method is true if one of the onKeyFoo attributes
has been set and the node is visible.  The hasFocus function
is true if a requestFocus succeeds.


The KeyEvent class looks like this:

public class KeyEvent {
    public attribute node:Node;
    public function getKeyChar():String // for keyPressed
    public function getKeyText():String // for keyTyped

    public function isShiftDown():Boolean
    public function isControlDown():Boolean
    public function isAltDown():Boolean
    public function isMetaDown():Boolean
}

KeyText avoids the need for a huge list of key-code constants 
however perhaps that's what we really need.   


[3/11/2008 - Hans] Gratuitous name change: CompositeNode => CustomNode

I thought that the base class for custom nodes would be a little more 
recognizable if it were called "CustomNode" and its factory method called
"create" instead of "composeNode".  Other than that, CustomNode provides
the same feature that CompositeNode did, albeit with very little code.

Note that the semantics of CustomNode are a bit confusing since it's 
a Group but it's type is Node.  So Node#getParent() may return a Node
(not a Group) if it's applied to a Node that's an immediate descendant
of a CustomNode.  



[3/11/2008 - Hans] More static attribute pain, Cursor.fx

In javafx.gui.Cursor.fx, I wanted to define a function that created a
blank cursor.  Ideally I wanted to lazily bind a static attribute to
the function lazily, since the attribute was unlikely to be used and
the value was slightly expensive to compute:

    private function createBlankAWTCursor():java.awt.Cursor {
        var toolkit:Toolkit = Toolkit.getDefaultToolkit();
        var d:Dimension = toolkit.getBestCursorSize(1, 1);
        if (d.width <> 0 and d.height <> 0) {
            var image:java.awt.Image = new BufferedImage(d.width, d.height, BufferedImage.TYPE_INT_ARGB);
            return toolkit.createCustomCursor(image, new Point(0, 0), "NONE");
        }
        else {
            return null;
        }
    }

The static attribute uses this function like so:

    public static attribute NONE = Cursor { 
          awtType: java.awt.Cursor.CUSTOM_CURSOR 
        awtCursor: createBlankAWTCursor()
    };

Unfortunately this produces an error about "symbol : variable
receiver$" not being defined.  Putting the body of the function (less
the "return" calls) on the value side of the awtCursor: initarg,
does work.   But yech.

Note also: in theory (per the spec) creating a custom AWT cursor with
an "invalid image" also yields a blank cursor.  Relying on this seemed
perilous, so I didn't.

I've filed a bug: static attribute's value can't refer to function
http://openjfx.java.sun.com/jira/browse/JFXC-903


[2/28/2008 - Shannon]

At some point, I'd like to add something called FocusGroup, with buttons having
a FocusGroup attribute. FocusGroup will allow navigation via arrow buttons
between buttons in the same group (probably left to right, top to bottom).
In addition, I think that by default, buttons with the same ToggleGroup should
automatically be treated as being in the same FocusGroup.


[2/26/2008 - Hans] More "I can't see myself" scoping problems

I'd wanted to implement an example ChrisO had suggested where a
scenegraph button's mouse behavior was defined like this:

  Rectangle {
      onMouseReleased: function(e) { if (isMouseOver()) { ... run an action callback }
      fill: bind if (isMouseButtonDown(1) and isMouseOver()) green else red 
      ...
  }

Rectangle.fx inherits functions isMouseOver and isMouseButtonDown from
Node.fx.

This fails to compile because of (I assume) bug JFXC-569.  Rats.

I tried making the implicit references to this, explicit:

  Rectangle {
      onMouseReleased: function(e) { if (this.isMouseOver()) { ... run an action callback }
      fill: bind if (this.isMouseButtonDown(1) and this.isMouseOver()) green else red 
      ...
  }

This fails for what I assume is the same reason, however now the
compiler reports that the methods (methods?) I'm referring aren't
defined.  It doesn't complain about the "this" variables. Huh?


Desparate to get some variation of this to work I tried this oddity:

  Rectangle {
      var self = this;  // NICE
      onMouseReleased: function(e) { if (self.isMouseOver()) { ... run an action callback }
      fill: bind if (self.isMouseButtonDown(1) and self.isMouseOver()) green else red 
      ...
  }

The compiler swallows the odd "self = this" variable definition and
then reports the same error as before.  Not to be beaten, I just used
the MouseEvent node attribute to overcome the first problem, and tried
moving the bind of fill to a function:

  function computeFillColor(r:Rectangle) {
      if (r.isMouseButtonDown(1) and r.isMouseOver()) green else red
  }

  Rectangle {
      onMouseReleased: function(e) { if (e.node.isMouseOver()) { System.out.println("action") }}
      fill: bind computeFillColor(this)
      ...
  }

This generated a new kind of error:

  computeFillColor(javafx.gui.Rectangle) in demo.tester.Main cannot be applied to ()

This doesn't make sense to me, clearly I've provided an argument.  So
with tears in my eyes I tried one more hack:

  var r:Rectangle;
  r = Rectangle {
          onMouseReleased: function(e) { if (r.isMouseOver()) { System.out.println("action") }}
          fill: bind if (r.isMouseButtonDown(1) and r.isMouseOver()) { green } else { red }
          ...
  };

This caused the compiler to throw an AssertionError.        

  An exception has occurred in the OpenJavafx compiler
  (1.0-internal). Please file a bug at the Openjfx-compiler issues home
  (https://openjfx-compiler.dev.java.net/Issues) after checking for
  duplicates. Include the following diagnostic in your report and, if
  possible, the source code which triggered this problem.  Thank you.

  java.lang.AssertionError: unexpected type: ()java.lang.Object
  ...

I give up.  


[2/25/2008 - Shannon] Hack alert, hack alert

In ScrollableComponent, I have the line:

jScrollPane.setBorder((new JScrollPane()).getBorder());

The goal is to reset the scrollpane's border to what the UI provides.
We could pull it from the UIManager, but I'm not sure that that approach is
acceptable for all UIs. Need to investigate more, and talk to Rich/Jasper.

[2/25/2008 - Hans]  More gratuitous renaming

Renamed the F3 Path "d" attribute, whose value is a sequence of
PathElements, to "elements".

Used centerX,Y instead of cx,cy.  We've been using complete names for
most other attributes, like radiusX,Y (ellipse), startX,Y and
endX,Y for LinearGradient, etc.

Renamed Transform Matrix to Affine, since Matrix sounds like a base
class for a Linear Algebra library.


[2/25/2008 - Shannon]

After surveying a few different sources, including Chris Oliver's original
design and Flex, we've decided that some components will have scrolling support
built in, and turned on by default. One example of such is List.

ScrollableComponent will be kept simple, and have only a single attribute which
allows the built-in scroll support to be turned off or on. People wanting to
control additional aspects of the enclosing JScrollPane can add their component
to a ScrollPane.


[2/22/2008 - Hans] More SGNodeListener pain

Making the nodeListener attribute not static meant that it
was posible to just refer to the currentX,Y... attributes
directly.  Sadly, this also failed to compile:

http://openjfx.java.sun.com/jira/browse/JFXC-749
Attribute's anonymous inner class value can't refer to enclosing class's attributes

Defining the SGNodeListener as the value of a function, instead
of an attribute, does work.


[2/22/2008 - Hans] No static SGNodeListener for now

The SGNodeListner added by Node.fx to keep currentX,Y,Width,Height in
sync with the SGNode's bounds, is supposed to be static.  There's a
small savings in this, since instead of creating a SGListener object
per Node, we create a HashMap entry (the SGNode attribute property)
that points to the Node.  Actually it's possible that there's no
savings at all, since the presently we're not using the SGNode
attribute property for anything else; so setting the first time
allocates a HashMap too.

Making the private attribute whose value was the SGNodeListener
static tickled a compiler bug: 

Static attribute's anonymous inner class value can't refer to enclosing class's attributes
http://openjfx.java.sun.com/jira/browse/JFXC-748

So it's not static for now.  For the record the original code
was:

    private static attribute nodeListener:SGNodeListener = SGNodeListener {
        public function boundsChanged(e:SGNodeEvent):Void {
            if (e.isConsumed() or e.getNode() == null) { 
                return; 
            }
            var node:Node = e.getNode().getAttribute("FX") as Node;
            if (node <> null) {
                var r = e.getNode().getBounds();
                node.currentX = r.getX();
                node.currentY = r.getY();
                node.currentWidth = r.getWidth();
                node.currentHeight = r.getHeight();
            }
        }
    }

    function getFXNode():FXNode {
        if (fxNode == null) {
            fxNode = new FXNode(createSGNode());
            fxNode.putAttribute("FX", this);  // back pointer
            fxNode.addNodeListener(nodeListener);
        }
        fxNode
    }



[2/20/2008 - Hans] How we've been defining enums

We've defined a bunch of classes that serve as enums.  They're really
just a cheap imitation, but they're probably better than just relying 
on static final int constants and runtime checks.  In most cases they're 
an encapsulation of a Java enum, or an older set of Java constants
that serve as an enum.

The pattern we've adopted looks like this:

public class MyEnum {
    private attribute toolkitValue:Integer = javax.swing.MyEnum.DEFAULT;
    private attribute name:String = "DEFAULT";

    public static attribute DEFAULT = MyEnum { };

    public static attribute FOO = MyEnum {
        toolkitValue: javax.swing.MyEnum.FOO
                name: "FOO"
    }

    public static attribute Bar = MyEnum {
        ...
    }
    ...

    static function fromToolkitValue(value:Integer):MyEnum {
         if (value == DEFAULT.toolkitValue) DEFAULT
         else if (value == Foo.toolkitVlaue) FOO
         ..
    }
    function getToolkitValue(): Integer { toolkitValue }
    public function getName(): String { name }
}

The basic idea is to create read-only constants.  Although developers
can instantiate their own MyEnum instances, they'll only ever get
the default value.

This would be considerably simpler without the name attribute (which I
suspect we don't need) and without the support for mapping to/from an
underlying "toolkit value".  This mapping is essential for our
implementation but wouldn't be needed in a generic FX Script
enum.

Currently we've got about 10 of these:
HorizontalAlignment, VerticalAlignment, TextOrigin, StrokeLineCap,
StrokeLineJoin, CycleMethod, Cursor, FillRule, FontStyle, Orientation.

Among the many problems with this, is the fact that an "enum" typed 
attribute can still be legally set to null.  So runtime checking is 
still needed (and we're not doing so yet).



[2/20/2008 - Shannon]

We do not currently support using ListItems in Multiple lists at the same time.
If you're going to add it to another List, remove it first.


[2/19/2008 - Hans] 1.6 Path2D, GeneralPath incompatibilities

In JDK6 Path2D and Path2D.{Double,Float} replaced GeneralPath, which now
extends Path2D.Float.  This appears to have had a destructive side effect: 
now it's not possible to figure out which GeneralPath methods existed
in 1.5 or earlier, since they're all now marked "Since 1.6".

Comparing the current docs with JDK 1.5 docs works of course.


[2/14/2008 - Hans] Distinguishing mouse buttons: other platforms

Here's the page for Flash MouseEvents:

http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/flash/events/MouseEvent.html

There's also a Flex MouseEvent class however it doesn't seem to add
anything:

    http://livedocs.adobe.com/flex/201/langref/mx/events/FlexMouseEvent.html

As far as I can tell, the only thing you're notified about is when the
"primary" mouse button goes up/down.

Mouse event processing in JavaScript appears to be insane.  Here's an
example of the kind of nonsense developers put up with:

   http://www.quirksmode.org/js/events_properties.html#button


Silverlight provides very limited mouse support, see: 

   http://msdn2.microsoft.com/en-us/library/bb979681.aspx

They only provided MouseLeftButton{Up,Down} methods which I guess puts them
in the same camp as Macromedia.


Mike Swingler provided this info per detecting mouse buttons in Java 
on OSX:

We always send 1 for regular clicks and control clicks. We only send 3
if the mouse really has a physical right button.

We do set isPopupTrigger for both ctrl-click and physical right-click,
but only on the mouse-down event. We don't set it for the mouse-up or
mouse-clicked event, because popup triggers are only on mouse-down on
our platform (unlike Windows where it's usually on mouse-up, except
for say, PowerPoint where it's on mouse-down...go figure).

Technically, we don't sniff if the control key is down, and we have
not changed the SwingUtilities implementation.

When we get the native mouse down from the OS, we actually create a
new MouseEvent right there, and set the isPopupTrigger instance
variable to true if the OS tells us "this is some kind of popup
trigger" in Objective-C/AppKit terms. It is simply coincidence that
AppKit considers a ctrl-click to be a kind of popup trigger.

If the control key is down, SwingUtilities.isRightMouseButtonDown()
returns false, unless you have pressed a real physical "right mouse
button". The only thing the control key changes is the
"isPopupTrigger" on the MouseEvent.



[2/14/2008 - Hans] Color,Font getAWTFoo() method public

Perhaps these method shouldn't be public in Color,Font.  Are 
we making them public so that a developer could do something like:

  var awtColor = anotherComponent.background.getAWTColor();
  button.getJComponent().setBackground(awtColor);

Since they can already do this kind of thing, e.g.:

  var awtColor = anotherComponent.getJComponent().getBackground();
  button.getJComponent().setBackground(awtColor);


--- After discussing this with Shannon

The reason for providing public access to the AWT objects is to 
simplify using the Color/Font methods that generate new colors
and fonts, like Color#darker() or Font#deriveFont().  Although 
we could include cover methods for all of this stuff directly, 
starting minimalist seems like a better idea.




[2/14/2008 - Hans] initial mouse processing code

The existing code that maps from java.awt.MouseEvents to FX
CanvasMouseEvents seems to do too much.

    // javafx\ui\canvas\CanvasMouseEvent.fx
    protected function makeCanvasMouseEvent(e:MouseEvent) {
        var info = MouseInfo.getPointerInfo();
        var pt = new java.awt.geom.Point2D.Double(e.getX(), e.getY());
        var result = CanvasMouseEvent {
            modifiers: [if (e.isAltDown()) then KeyModifier.ALT else null,
                        if (e.isControlDown()) then KeyModifier.CTRL else null, 
                        if (e.isMetaDown()) then KeyModifier.META else null,
                        if (e.isShiftDown()) then KeyModifier.SHIFT else null]
            button: if (SwingUtilities.isLeftMouseButton(e)) then 1 
                    else if (SwingUtilities.isRightMouseButton(e)) then 3 else 2
            clickCount: e.getClickCount()
            localX: pt.getX()
            localY: pt.getY()
            x: e.getX()
            y: e.getY()
            screenx: info.getLocation().getX()
            screeny: info.getLocation().getY()
            //percolate: e.percolate // TODO: percolate not implemented
            percolate: false
            source: e
        };
        return result;
    }

All of the coordinates - localX,Y x,y, and screenX,Y - are public
Number (Double) attributes.  So localX,Y and x,y are just the
MouseEvent coordinates, i.e. the coordinates of the event are just
relative to the Canvas (JSGPanel).  That certainly matches the name of
the FX class, but one would think that either x,y or localX,Y would be
node relative?

The screenX,Y attributes could equally well be initialized (on 1.6)
with event.getXOnScreen(), event.getYOnScreen() however on 1.5
we have to use MouseInfo.getPointerInfo().getLocation() which means
that the screen coordinates will be slightly out of sync (since 
they're looked up slightly later) than the event's coordinates.

The clunky mapping from button to 1,2,3, which is already the value of
MouseEvent.getButton() may help deliver consistent results on OSX
vs Windows (or Linux) [doesn't look like that's the case, see
"Distinguishing mouse buttons: other platforms" above.

The mapping from keyboard modifiers to a sequence of constants doesn't
seem to be worth the trouble.

Perhaps all of the MouseEvent state should just be exposed 
as functions.  That makes it all explicitly read-only,
it makes event construction cheaper, and it makes them 
smaller.  

The current API already does expose a bunch of the state 
with functions, e.g:

    public function isControlDown():Boolean{
        var result:Boolean;
        for(m in modifiers) {
            if(m == KeyModifier.CTRL) {
                result = true;
                break;
            }
        }
        return result;
    }

Which seems pretty silly compared to: 

    public function isControlDown():Boolean { 
        awtEvent.isControlDown() 
    }




[2/13/2008 - Hans] initial mouse processing code

I've added 7 methods like onMouseClicked to Node and a MouseEvent
class.  A great deal remains to be done, this is just an initial
cut at hooking a little bit of the machinery up.  Several issues
need to be resolved:

- How to handle cursors?  The current code attempts to keep JSGPanel's
cursor set based on the cursor attribute of the Node the mouse is
over.  It doesn't seem to handle press-drag-release gestures
correctly; probably certainly not if the PDR cursor is supposed to be
defined by the node where the mouse-pressed event occured.  I think it
would make sense for Scenario to deal with this.  We'll probably also
want to let the devleoper set the JSGPanel's (Canvas) cursor.

- How to handle AWT MouseEvent.consume()?  The current Node
class automatically consumes the entire PDR gesture     
if any of the PDR onMouseFoo callbacks are defined.

- The current Node class as a selectionRoot boolean attribute
that causes all mouse events to be consumed, handled or not.

- How to handle keyboard focus?  The current runtime doesn't 
appear to be using the Scenario support for managing the keyboard
focus.

More consideration needs to be given to the existing mouse 
event dispatching code, there's quite a bit of additional
state being pushed around there.



[2/13/2008] Note from David Kaspar per layout

from 2/12/2008 email, Subject:
Meeting with David Kaspar from the FX Tools team, Action Items

In Visual Library I have implemented a simple layout mechanics. See
"Layout" and "Validation Process" sections at:

http://bits.netbeans.org/dev/javadoc/org-netbeans-api-visual/org/netbeans/api/visual/widget/doc-files/documentation.html#Layout

You can see the mechanics in the source code as well:
  hg clone http://hg.netbeans.org/main/
  hg update

In the "main" directory there is a "api.visual" directory with the
source code of the library.

Look at "src/org/netbeans/api/visual/layout/Layout.java" - layout interface.
Look at "src/org/netbeans/api/visual/widget/Widget.java" - "revalidate",

"revalidateUptoRoot", "layout", "rejustify", "rejustifyUptoRoot",
"justify" methods. They take care of invalidation, validation and
justifying the widgets tree.
Look at "src/org/netbeans/api/visual/widget/Scene.java" -
"revalidateWidget", "layoutScene", "validate" methods.


[2/13/2008 - Hans]  Mapping Node.fx to scenario.fx.FXNode


I've defined a simple mapping between Reprise Node.fx and
scenario.fx.FXNode.  All FX nodes (Rectangle, Image, Group, etc) now
include the following public attributes:

    visible
    opacity
    translateX
    translateY
    scaleX
    scaleY
    shearX
    shearY
    anchorX
    anchorY
    rotation
    horizontalAlignment
    verticalAlignment
    cache

Clip, effect, and (affine) transform attributes are TBD.  The
transform attributes correspond to an implicit fixed sequence of
affine transforms:

    Alignment -> Translate -> AT+ -> Rotation -> AT- Scale -> Shear

Where:
AT+ - Translate to rotation anchor point
AT- - Revert translation to rotation anchor point

[Actually the FXNode code seems to have AT- at the end?]

This represents the first big departure from the existing FX Script
runtime library API.  In the current API one assembles a sequence of
transforms like:

    transform: [Transform.translate(10.0, 20.0)]  

or
    transform: [Transform.scale(2.0, 2.0)
                       Transform.rotate(cx: 0.5 cy: 0.5 angle: 45)]

Although we may still support this style of transform composition,
with the TBD transform attribute, in most cases developers should
be able to define transforms using the fixed sequence.  For example:

   translateX: 10.0  
   translateY: 20.0

or
   scaleX: 2.0  
   scaleY: 2.0
   anchorX: 0.5
   anchorY: 0.5
   rotation: 45*

Note: at the moment rotation values are radians, not degrees.  

The implementation of these attributes is trivial, for example:

    public attribute translateX:Number on replace {
        getFXNode().setTranslateX(translateX);
    }

I found it simplest to just use the scenario.fx.FXNode class, so I
made FXNode's constructor and getLeaf methods public.
   
There are potential inefficiencies in the implementation.  If the
underlying AffineTransform is eagerly recreated, then the second
example, where five attibutes are initialized, would cause the
underlying AffineTransform to be recreated five times.

The boolean cache attribute maps to the FXNode cacheAsBitmap property
which maps to the SGRenderCache SGNode class.  I didn't expose either
name directly because, renderCache or cacheRendering or whatever
seemed clunky and the "bitmap" in cacheAsBitmap isn't a term we
use in our APIs.  MS and Macromedia do.


[2/12/2008 - Hans]  The problem with proportional gradients

If you fill a shape node with a gradient it's very useful to be able
to define the gradients path in a unit coordinate system that maps to
the shape's bounds.  That way, if the shape's bounds change, the
gradient's stops will retain the same proportions relative to the
shape.  A boolean LinearGradient attribute called proportional
specifes that the gradient's end points are defined in terms of the
unit square.

Supporting proportional LinearGradients means that the underlying
java.awt.LinearGradientPaint must be recreated whenever it's used to
fill a shape whose bounds don't match the bounds of the shape it was
last used to fill.  Since a single FX LinearGradient might be used as
the "fill:" value for an abrbitrary number of shape nodes, the
underyling LinearGradientPaint could be recreated quite a lot.

For now, we'll unconditionally recreate the LinearGradientPaint object
LinearGradient.getAWTPaint() is called.  Note that this puts
LinearGradient in the same category as javafx.gui.Color: they're both
effectively immutable classes.  To make it possible to reflect changes
in a LinearGradient's attributes in all of the nodes that use it, the
LinearGradient object would have to maintain a list of those nodes.

The current code does no caching and it doesn't special-case
proportional=false.   It would be fairly easy to improve that.



[2/12/2008 - Shannon]

We have a problem. Consider:

public class Component {
    public attribute background = Color.fromAWTColor(component.getBackground()) on replace {
        component.setBackground(background);
    }

    postinit {
        jComponent.addPropertyChangeListener(PropertyChangeListener {
            public function propertyChange(e: PropertyChangeEvent): Void {
                if ("background".equals(e.getPropertyName())) {
                    background = Color.fromAWTColor(component.getBackground());
                 }
             }
         });
    }

Component {background: bind getColorFunction(r, g, b)}

This sets up a tight binding between the component's background and the return
value of getColorFunction(). When the background attribute is set from
the function, we apply it to the underlying JComponent. We then get a property
change notification and try to apply the value to the background attribute.
Oops! This causes an exception, because the background attribute may only be
set by the binding. So how are we going to deal with this?

We'll want to set a flag to ignore property change events that come
as a result of our class setting values on the underlying component.

But what about developers dorking around with the underlying properties
directly? Sorry! If you've bound an attribute in Java FX, you shouldn't
expect that you can change it directly. Of course, a better error message
from the compiler/runtime will make this better.

But what about if the change comes from the Look and Feel. Aha! Look and
feels *should* only replace values that are not instances of UIResource. So,
for the most part, this won't be a problem.

HOWEVER, there is still one case where a problem remains:

componentA.background = bind componentB.background

We've bound componentA's background to another component's background, where
the default value is a UIResource. On a look and feel switch, this would continue
to try to update the componentA background directly, resulting in exception.

What's the solution? Don't know yet - but could be that we stop wrapping
the real source AWT color in the FX Color class.

*** Update on February 28, 2008 - I've been hit with a brainwave:
The last problem can be solved by stripping out UIResource only. I've done this
for Color/Font. However, I've had to comment it out pending a fix to our pattern
for syncing properties with components. For the time being, our initialization
code sets values that it receives from the component back on the component.
If we stripped out UIResources, we'd lock down the color/font. To avoid this,
the pattern needs to be updated to only set values that come from the developer
- this requires compiler support for checking to see if the value has come from
a literal.

[2/12/2008 - Shannon]

We have a small problem:

Consider:

public class Component {
    public attribute background = Color.fromAWTColor(component.getBackground()) on replace {
        component.setBackground(background);
    }
}

For a small set of primitive attributes, this pattern won't work. The act of setting
the attribute back on the component causes a bit to be set which indicates that the
developer has set the attribute. We don't want that. To solve this, during
initialization we only want to fire the trigger logic for object literal values
being set. Awaiting compiler support for this...

Additionally, we'll not want to run the triggers when the set comes from
the component sending us property change notification. This will require a flag.

[2/12/2008 - Shannon]

We've decided that it's *against the rules* for a developer to directly modify
the underlying Swing hierarchy of a JavaFX created component tree (if they
expect to continue using the hierarchy in JavaFX). It poses too many problems
with trying to keep things in sync. Developers can, however, create their own
component (or hierarchy) in pure Swing, and embed it by converting it to a
JavaFX Component via Component.fromJComponent(). Note that we will treat this as
a leaf, and not re-create it's hierarchy in JavaFX.

Considering the above simplification, dealing with menus still posed some
problems (which will likely come up again when we deal with containers). First,
we use a sequence to store children, but to satisfy Swing we can't have
duplicates in the sequence. We've solved this by letting Swing remove the
duplicates, and then we re-sync from Swing when appropriate.

One further step that I took was to make the menu code robust enough to deal
with developers adding/removing their own items directly through pure Swing.
The goal was to prevent the Java FX menu code from breaking down as soon as an
unexpected item is added. Our rule above may or may not cover this case
(is simply adding/removing your own components breaking the rule?). This
should be revisited when we implement containers. If it's not necessary, the
code can be simplified.

[2/11/2008]

* Gratuitous rename: [Gradient] SpreadMethod => CycleMethod
This is consistent with java.awt.MultipleGradientPaint.CycleMethod



[2/10/2008]

I'd wanted to construct a java.awt.LinearGradientPaint instance directly
from FX Script.  One of the constructor's signature looks like this:

  LinearGradientPaint(Point2D start, Point2D end, float[] fractions, Color[] colors)

I don't know of a way to convert FX sequences to arrays without dipping
into Java, so I created and popuplated them with java.lang.reflect.Array
and tried passing the Object typed arrays to the LinearGradientPaint 
constructor.  This fails because because of type mismatch between the
Array objects and the formal parameter types.  So I decided to call the
constructor via reflection, which required looking up the constructor:

import java.lang.Class;
var point2DClass = Class.forName("java.awt.Point2D");
var floatArrayClass = Class.forName("[F");
var colorArrayClass = Class.forName("[Ljava.awt.Color;");
var lgpClass = Class.forName("java.awt.LinearGradientPaint");
var ctor = lgpClass.getConstructor(point2DClass, point2DClass, floatArrayClass, colorArrayClass);

Compiling this causes and exception in the compiler.   No doubt
this sort of thing can be avoided by calling a stub Java method
instead.

An exception has occurred in the OpenJavafx compiler (1.0-internal). Please file a bug at the Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)  after checking for duplicates. Include the following diagnostic in your report and, if possible, the source code which triggered this problem.  Thank you.
java.lang.NullPointerException
        at com.sun.tools.javafx.comp.JavafxToJava.translate(JavafxToJava.java:284)
        at com.sun.tools.javafx.comp.JavafxToJava$2.determineArgs(JavafxToJava.java:2728)
...

http://openjfx.java.sun.com/jira/browse/JFXC-680


[2/6/2008]

* Image width, height, and size attributes

They're all considered to be read-only but can be set with object
literal initargs.

If size is specified then the image is scaled so that the maximum
dimension is equal to size and the original aspect ratio is 
preserved.

If width and height are specified the image is scaled to match.

If only width is specified the image is scaled to match and the
original aspect ratio is preserved.  

If only height is specified the image is scaled to match and the
original aspect ratio is preserved.  


* Removed URL icon attribute in favor of (just) image.

Doing so should simplify centralizing image loading and caching 
in the future.


[2/6/2008]

* Adding attribute type quailfier causes 'on replace' trigger to run?

In the following example, I would only expect the bar2 attribute's 'on
replace' trigger to run.  If I don't provide types for the attributes
then that's what happens.  If I include the type qualifiers then both
'on replace' triggers run (in fact that's true even if no object
literal initargs are provided).  That's not what I expected and I was
surprised that just defining the types of the attributes would have
this effect.  Note also that if I initialize both (String typed)
attributes to null then the 'bar1' trigger does not run.

This example comes from the Icon.fx class in the revised version
of the runtime.  The Icon class has both url:String and image:Image 
attributes with 'on replace' triggers which update a private 
javax.Swing.Icon type attribute.  In that case, having both 'on replace'
triggers run ends up clearing the private attribute.

I was able to work around the problem by initializing Icon's url and
image attributes to null.


class Foo {
    attribute bar1:String on replace {
        java.lang.System.out.println("bar1 on replace trigger");
    }

    attribute bar2:String on replace {
        java.lang.System.out.println("bar2 on replace trigger");
    }
}

var foo = Foo { bar2:"bar2" };  

Filed a bug: http://openjfx.java.sun.com/jira/browse/JFXC-652


* Removed IIOReadProgressListener from Image.fx for now

        var progressListener = IIOReadProgressListener {
            public function imageStarted(r:ImageReader, imageIndex:Integer):Void {
            }
            public function imageProgress(r:ImageReader, percentageDone:Number):Void {
            }
            public function imageComplete(r:ImageReader):Void {
            }
            public function readAborted(r:ImageReader):Void {
            }
            public function sequenceStarted(r:ImageReader, minIndex:Integer):Void { }
            public function sequenceComplete(r:ImageReader):Void { }
            public function thumbnailStarted(r:ImageReader, imageIndex:Integer, thumbIndex:Integer):Void { }
            public function thumbnailProgress(r:ImageReader, percentageDone):Void { }
            public function thumbnailComplete(r:ImageReader):Void { }
        };

        ... reader.addIIOReadProgressListener(progressListener);

Filed a bug: http://openjfx.java.sun.com/jira/browse/JFXC-644


[2/5/2008]

* Flash ActionScript doc - http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/
* Flex doc http://livedocs.adobe.com/flex/201/langref/index.html


Image Loading options:

- Eager, as in javax.swing.ImageIcon.  This is somewhat perilous, if
the image isn't small and it's not in an already loaded jar file.
It has worked fine for small images in Swing appliations forever.

- Eager (when the Image is created), but in the background.  Safer if
the the image's path leads to the disk or the network.  Gives us the
option of timing out.  Doing the work asynchronously means that the
app must either specify the image's dimensions or bind to them.

- Lazy, i.e. when the app asks for it.   This has the same problem as
eager vis hitting the disk/network but might lead to better startup
performance.

- Lazy and in the background.  This seems like the most desirable way
to do the job although it has the same requirement for the image's 
size as eager/background.


* Can't implement IIOReadProgressListener in FX Script

Is there a way to implement method bar in a Java interface like this:


public interface Foo { void bar(float f); }

I've tried

 Foo { public function bar(f:Number):Void {} }

and

 Foo { public function bar(f:java.lang.Float):Void {} }

and (just for good measure):
   Foo { public function bar(f):Void {} }


The interface I'm really trying to implement is
javax.imageio.event.IIOReadProgressListener.  Naturally I could insert
a stub written in Java however, so far, I haven't needed any Java code
at all.

Filed a bug: JFXC-644,
http://openjfx.java.sun.com/jira/browse/JFXC-644



[1/31/2008]

* Current public ImageView attributes

image:Image - javafx.ui.Image is roughly a Swing ImageIcon
animated:Boolean
imageOpacity:Number = 1.0
loaded:Boolean
size:Dimension
stretch:Stretch
stretchDirection:StretchDirection
preload:Boolean
antialias:Boolean
accelerate:Boolean
drawImmediately:Boolean

function downloadPercentage():Number
function getImage()
function resizeImage(img:java.awt.Image)
function updateInterpolationHint()


* The Node currentX,Y,Width,Height attributes

If the node isn't being clipped then these attributes just correspond
to the node's bounding box (perhaps they should be called boundsX...).

> Per CO's email ["freeze for 0.5" @3:52]

If the node is being clipped, then the currentX,Y... attributes are
computed like this: "take the node's unclipped bounding box, intersect
it with the clip shape, return the bounding box of that".

That's the bounding box of the node's bounding box after it's been
clipped.  I assume that events are only dispatched to an FX Node
if currentWidth,Height are both > 0



[1/29/2008]

* Gratuitous rename: ArcClosure => ArcType

And the Arc "closure" attribute (which sounded like it referred to a
closure) is now called "type".


* BasicStroke (in Shape) strokeDashArray attribute fails

    public attribute strokeDashArray:Number[] = [1.0]

In theory, the default value of this attribute implies "no dashes",
however what you get instead is length 1 dashes, separated by 1.
At least that's what it looks like.  Perhaps there's a problem 
converting from a Number array to an array of floats?  For the moment
I've commented out the use of this attribute.


* Problem with the (ported) F3 Canvas class

The on insert trigger for the attribute content ignores the index
argument; it always appends its node:

    public attribute content: Node[]
        on insert [indx] (newValue) {
            newValue.parentCanvasElement = this as CanvasElement;
            if (root <> null) {
                root.add(newValue.getNode());
            }
        }
        ...
    }

Fixed that in the new version.


* Text verticalAlignment property => textOrigin

The implementation of the the (ported) F3 Canvas class is:

    public attribute verticalAlignment: Alignment = Alignment.LEADING on replace {
        updateVerticalAlignment();
    };

    private function updateVerticalAlignment() {
        if (sgtext <> null) {
            if (verticalAlignment == Alignment.BASELINE) {
                sgtext.setVerticalAlignment(VAlign.BASELINE);
            } else if (verticalAlignment == Alignment.LEADING) {
                sgtext.setVerticalAlignment(VAlign.TOP);
            } else {
                sgtext.setVerticalAlignment(VAlign.BOTTOM);
            }
        }
    };


The default value of the property, LEADING, is really a horizontal
alignment term.  It's mapped to VAlign.TOP which doesn't really make
much sense.

Unfortunately, one can't cleanly use the VerticalAlignment type we
defined for Swing in the same way, because it doesn't include a
BASELINE constant.

The value of the underlying SGText verticalAlignment property
specifies how the text's x,y origin is to be interpreted.  To 
avoid colliding with the VerticalAlignment constant class we've
already defined for Swing, I've defined an enum called TextOrigin
that trivially maps to SGText.VAlign.

So we've got a minor name change: the Text verticalAlignment
attribute is now called "textOrigin".



[1/28/2008]

* Compiler can't deal with static inner class reference

The import seems to work:
import java.awt.geom.RoundRectangle2D.Double;

But the reference to the class does not:

Rectangle.fx:9: package RoundRectangle2D does not exist
    private attribute rectangle2D = new RoundRectangle2D.Double();


* First look at the javafx.ui.canvas classes

AbstractVisualNode subclasses must override updateStroke to init
their internal java.awt.BasicStroke attributes.   This seems like a 
waste of time, since only VisualNode extends AbstractVisualNode.


In VisualNode.fx there are a bunch of attributes defines like this:

    public attribute stroke: Paint on replace {
        if(stroke <> null) {
            awtStroke = stroke.getPaint();
        }
    };

This means that if you do something like myRect.stroke = null
the awtStroke attribute will not be updated.  Which means the
corresponding SGShape mode property will not be set correctly:

   private  function updateMode() {
        if (sgvisualnode <> null) {
            if (awtFill <> null and awtStroke <> null) {
                sgvisualnode.setMode(SGAbstractShape.Mode.STROKE_FILL);
            } else ... etc
        }
   }


* Added abstract FX class Paint, now Color extends that

The scene graph classes use Paint rather than Color attributes 
for fill/stroke, so I've added the same Paint superclass to our 
code as in javafx.ui.



* Resetting JTextField.text fails if called from within DocumentListener

Without the "not ...getText().equals(text)" guard, the on replace
trigger fails:

    public attribute text: String = getJTextField().getText() on replace {
        if (not getJTextField().getText().equals(text)) {
            getJTextField().setText(text);
        }
    }

Resetting the JTextField text property from within a DocumentListener
throws a runtime exception.  Since we're only resetting the text
attribute to the value of getText() in the DocumentListener, this
should fine.


[1/27/2008]

* Abstract "value" for cut and paste, DND

The original FX API includes an attempt at simplifying the way a
component's value is defined for the sake of cut and paste and DND.
This stuff was commented out of the original TextField.fx class.


* Other Swing properties that aren't being kept in sync

The onAction attribute in AbstractButton and TextField doesn't reflect
the underlying ActionListener listener list.

The onVerify attribute in TextField doesn't reflect the underlying
inputVerifier property.

The Frame icon attribute doesn't reflect the underlying iconImage property.


* Are we calling callbacks onFoo?

You defined onAction in AbstractButton and I've just called the 
text field's input verifier "onVerify".  Are we following some
pattern that's been established by JavaScript?


* Original FX TextField API includes odd default button hack

The original FX TextField code included the following hack to run the
default button:

    ActionListener {
        public function actionPerformed(e:ActionEvent):Void {
            // ...
            if (action <> null) {
                (action)();
            } else {
                var root = textField.getRootPane();      
                var but = root.getDefaultButton();
                if (but <> null) {
                    but.doClick(0);
                }
            }
        }       
    }

I would hope that this isn't really needed?



[1/25/2008]

* Selected text TextField API

We've reconsidered the first cut at the API for the limits of the
selection, which was nearly identical to the existing FX Script
TextField class: 

    public attribute selectionStart: Integer = 0 on replace {
        if (getJTextField().getSelectionStart() <> selectionStart) {
            getJTextField().setSelectionStart(selectionStart);
        }
    }

    public attribute selectionEnd: Integer = 0 on replace  {
        if (getJTextField().getSelectionEnd() <> selectionEnd) {
            getJTextField().setSelectionEnd(selectionEnd);
        }
    }

The problem with exposing the selection with two attributes is 
that most changes to the selection's limits involve changing
both attributes.  And that leads to a meaningless intermediate 
state, after just one of the two attributes has been updated.

Note also: the guard in the origial code was needed because
JTextComponent inexplicably doesn't do so itself.

So we've decided to just expose two read-only properties instead,
along with a method that sets both:

    private attribute selectionStart:Integer = 0;
    private attribute selectionEnd:Integer = 0;

    public function getSelectionStart(): Integer { selectionStart }
    public function getSelectionEnd(): Integer { selectionEnd }

    public function select(start:Integer end:Integer): Void {
        getJTextField().select(start, end);
    }

    postinit {
        var jTextField = getJTextField();
        var caretListener = CaretListener {
            public function caretUpdate(e:CaretEvent): Void {
                selectionStart = jTextField.getSelectionStart();
                selectionEnd = jTextField.getSelectionEnd();
            }
        };
        jTextField.addCaretListener(caretListener);
    }

The getSelectionStart/End methods just return the value of private
attributes, rather than getting the corresponding JTextField
properties, so that bindings update when the CaretListener runs.


* PCL pattern

A PCL is used in each class, to keep attributes in sync with their
properties, when it's practical to do so.  Here's a typical 
PCL clause:

    public function propertyChange(e:PropertyChangeEvent): Void {
        var name = e.getPropertyName();
        if ("horizontalAlignment".equals(name)) {
            var value = jTextField.getHorizontalAlignment();
            horizontalAlignment = HorizontalAlignment.fromToolkitValue(value);
        }
        ...
    }

We use equals to compare property names to guard against the (small)
chance that a propertyName isn't an interned string and we reset the
attribute to the current value of the property, rather than casting
the PropertyChangeEvent's newValue property.

We do not support the documented convention for property-name == null.
It's supposed to mean that more than one property's value has changed.
We don't believe this convention has been adopted anywhere.


* Swing default values

The JComponent base class specifies that documented default values for
properties may be overidden by the L&F when the object is constructed.
See the JComponent class javadoc paragraph that begins: "JComponent
and its subclasses document default values for certain properties".

For that reason, the initial value of all attributes are loaded from
the underlying component.  Here's a typical attribute:

    public attribute editable: Boolean = getJTextField().isEditable() on replace {
        getJTextField().setEditable(editable);
    }

In a few cases, like JFrame.iconImage, it's impractical to accurately
reflect the underlying value, so we just use the documented default
instead.


[1/24/2008]

* Patterns we've mostly adopted

I think we've adopted two distinct patterns for the encapsulation (so
far).  The first is the one for mapping between toolkit constants and
faux FX Script constants and the other is the two connection between
encapsulated component properties and public attributes:

- Attribute default value comes from the corresponding property if a
default value for the property isn't specified.  This is typically
because the property's value is computed by the L&F.

- Attribute's on replace trigger updates the underlying property.

- PCL installed at postinit time updates attributes.

- Simplification of this aspect of the FX Script API comes from
omitting some of the underlying properties (not exposing them
as attributes), rather than renaming or recasting to a fundamentally
different property type.


* Component.fromToolkitValue()? 

I added a Label.labelFor attribute and realized that to handle updates
to the underlying JLabel, we'd have to be able to map from a
JComponent back to a Component.   We could leave a backpointer
around as a client property however in some cases - to make this
really work - we'd have to create Component given a random JComponent
for which there was no FX Object.  That could become rather
complicated, since we'd have to match the JComponent subclass with 
the closest matching FX Component class, or we could just punt
and use a Component.  

For now, I've punted dealing with property change notifications
for Label.labelFor altogether.


* Why not factor our the common parts of Label/AbstractButton?

The AbstractButton and Label text/icon and four alignment attributes,
as well as the associated PCL code, are nearly identical.  It seems
like it would be useful to factor them into a separate LabelIntrinsics
class that could be multiply inherited by AbstractButton and Label.

The biggest problem with doing so is that javax.swing.AbstractButton
and JLabel don't share this stuff, so all of the attribute default
value and on replace triggers would have to do something horrible
like:

    public attribute icon: Icon = null on replace {
        var c = getToolkitValue();  // JLabel or javax.swing.AbstractButton
        if (c instanceof JLabel) {
            (c as JLabel).setIcon(icon.getToolkitIcon())
        }
        else {
            (c as javax.swing.AbstractButton).setIcon(icon.getToolkitIcon())
        }
    }

If we don't bother with this factoring, there's an extra 50 lines of 
code to pay.   It's all trivial boilerplate and so long as it stays
that way, factoring it into a shared superclass doesn't seem to be
worth the mess.


* JTextField CaretListener

When my JTextField's CaretListener reports changes to the selection,
I had to guard against looping like this:

    public attribute selectionStart: Integer = 0 on replace {
        if (getJTextField().getSelectionStart() <> selectionStart) {
            getJTextField().setSelectionStart(selectionStart);
        }
    }

    public attribute selectionEnd: Integer = 0 on replace  {
        if (getJTextField().getSelectionEnd() <> selectionEnd) {
            getJTextField().setSelectionEnd(selectionEnd);
        }
    }

    postinit {
        var jTextField = getJTextField();
        var caretListener = CaretListener {
            public function caretUpdate(e:CaretEvent): Void {
                selectionStart = jTextField.getSelectionStart();
                selectionEnd = jTextField.getSelectionEnd();
            }

        };
        jTextField.addCaretListener(caretListener);
    }

CO had done something similar.  Any idea why resetting
selectionStart/End would cause something to happen (the
CaretListener to be fired recursively I assume)?  I would
have thought that JTextField would have had such a guard
internally.  As far as I can tell it doesn't; however a quick
review of the code doesn't reveal why my guard is needed.
Have you heard of this before?


* JTextField spec problems

Note: JTextField spec doesn't require horizontalAlignment to default
to LEADING, although that's what the implementation does.  It should
be the spec.  Likewise JTextComponent.editable is true by default,
but not covered by the spec.


* Existing FX TextField class

Not clear exactly what the difference between TextField.value and
TextField.text attributes are in the old API.   The original code
installed a PCL that listened for changes to "value" and did this:

    if (e.getPropertyName().equals("value")) {
        value = textField.getText();
        if(onChange <> null) onChange(textField.getText());
    }



[1/22/2008]

* The trouble with Window/Dialog owners

The owner property of a Window/Dialog can only be set when the object
is constructed.  The code that creates a Window (Dialog is similar) looks
like this:

    public attribute owner : Window = null;

    protected function createWindow() : java.awt.Window {
        if (owner <> null) {
            new JWindow(owner.getWindow())
        }
        else {
            new JWindow();
        }
    }

    public function getWindow(): java.awt.Window {
        if (window == null) {
            window = createWindow();
        }
        window
    }

This relies upon the fact that if the owner attribute is specified as
part of a Window "object literal", it will be initialized *before* any
of the default values or "on replace" triggers that are defined for
many of the other Window attributes run.  In other words, so long as
the owner is specified like this:

   var window = Window { owner: myWindowOwner };

And not like this:

   var window = Window { };
   window.owner = myWindowOwner; // doesn't work, too late

The createWindow method will be called after the owner attribute has
been initialized and all will be well.  Attributes like font cause the
underlying java.awt.Window to be created when their default value is 
computed:

    public attribute font: Font = Font.fromAWTFont(getWindow().getFont()) on replace {
        getWindow().setFont(font.getAWTFont());
    }

Others do so when "on replace" triggers run.  So long as we're
guaranteed that all of this stuff executes *after* object literal
attribute initializations happen, then the owner will be set before
it's used.

[Shannon: I wrote the following based on our conversation.  When I checked,
a test case, it turned out that the title attribute *is* initialized
before Window#createWindow() is called.  So apparently all literal
attributes are initialized before any defaults or "on replace" triggers
are run.]

One further complication, and a potential failure mode, is that
(apparently) all of the work to initialize a superclass happens
before its subclass is initialized.   So an override of createWindow()
that similarly depended on attributes defined in the subclass, would
fail.  For example:

public class Frame extends Window {
    public attribute title: String = null on replace {
        getJFrame().setTitle(title);
    }

    protected function createWindow(): java.awt.Window {
        new JFrame(title); // title attribute not yet set!
    }

    public function getJFrame(): JFrame {
        getWindow() as JFrame;
    }

}

In this example, even if the title attribute is specified as part of the 
Frame object literal: Frame { title: "hello" }, it will not appear
to have been initialized when the createWindow() override is called.
Fortunately, properties that must be specified as constructor parameters
are unusual in the Swing API.  [Not true right now!]



[1/17/2008]

* boolean Frame.iconfied attribute, no maximized attribute

I decided to use the WindowState listener to track the Frame's iconfied 
and maximized states, per the java.awt.Frame extendedState property.
FX Script doesn't appear to support bit arithmetic so I had to 
do that with BigIntegers, e.g.

    var oldState = BigInteger.valueOf(getJFrame().getExtendedState());
    var newState = if (iconified) oldState.setBit(0) else oldState.clearBit(0);

I would have liked to include a similar maximized property, since
modern apps often choose a special layout for that case.  Mapping
Frame.MAXIMIZED_HORIZ and Frame.MAXIMIZED_VERT to a single boolean is
messy because setting the maximized attribute would correspond to
setting both bits (aka Frame.MAXIMIZED.BOTH) but the AWT WindowState
notification would report both (at least on Linux/Solaris, maybe OSX?).

So I think that means I'd have to have a private attribute that stayed
in sync with the AWT bits, and then bind public maximized attribute
to that.


[1/16/2008]

* Why postinit, and the automatic Frame pack/show hack

One reason I wanted it was to restore the F3 hack for Frames: they
automatically do pack/show after you've created them (this didn't work 
perfectly in F3).  This doesn't work with the current definition
of the init trigger because init runs *before* all of the other triggers.
So given something like this:

    Frame { content: button; }

the underlying JFrame's content pane would not have had the button 
added to it until after the Frame's init trigger ran.  So calling
pack at that point just lays out an empty JFrame.

The problem with this is that if you create a Frame subclass, then
you'd want to wait until the subclass's postinit method before
calling pack.  That will not happen with this scheme.  This is 
really just a hack to make trivial apps look trivial. 

On additional problem with all of this is that if you write:

    Frame { content: button; visible: true}

then the Window.visible attribute's replace trigger runs *before* 
Frame's postinit calls pack(), and that causes the Frame to 
briefly appear at 0,0, before relocating to its final position
in the middle of the screen, thanks to getJFrame().setLocationRelativeTo(null)
in the Frame.postinit trigger.


* Revised automatic Frame pack/show hack

I've moved the code that initializes a Frame/Window's bounds to 
the Window postinit trigger:

        var w = getWindow();
        if (not w.isValid() or (width == 0) or (height == 0)) {
            w.pack();
        }
        if (not w.isLocationByPlatform() and (w.getX() == 0) and (w.getY() == 0)) {
            w.setLocationRelativeTo(if (owner <> null) owner.getWindow() else null);
        }

So long as the Frame's postinit trigger doesn't do anything that will affect the
initial packed bounds of the Frame (and likewise for Frame subclasses), this 
should safely and automatically do the job. 


I've also revised the way that the initial Frame/Window.setVisible(true) 
call is handled.  

    public attribute visible: Boolean on replace {
        if (isWindowInitialized) {
            getWindow().setVisible(visible);
        }
    }

The private isWindowInitialized flat is set after Window's postinit block
finishes its work.  That way the window will not be made visible until
its initial bounds have been computed.




[12/4/2007]

I want to set the font on a Label (JLabel) so I've got look up the
mapping from the Font constructor parameters to FX Script attribute
names.  This reminds of some things I find annoying about the FX Script
encapsulation:

- The mapping from the underlying Java type to the wrapper type is
arbitrary.  So what you already know about the Java type may just be
confusing.  In this case the font's style is an (old) int constant
like Font.BOLD in Java.  In FX Script it's a list of strings in the
constructor argument, and a list of FontStyle objects which appear to
be the String and the corresponding int constant.  


- The small wrapper types, like Color and Font, aren't particularly
helpful.  That is, they don't substantially simplify typical use
cases, and they complicate use-cases where the user has to resort to
configuring the underlying Java object.  By the time you've written
myFXFont.getFont().getBaseLineFor('X') you're in hell.  I suppose
that's unlikely to happen very often, and when it does, you're
probably already in hell.


- The wrappers are all defined in terms of read/write public
attributes.  For types like Color and Font, that's a departure from
the underlying type.  That also puts the (undocumented) Color
constants at a disadvantage:

var c:Color = blue;
c.blue = 0.0;
c.red = 1.0;  // Now blue is red!

For some reason you can't effect this change by just writing blue.red = 0.0.
However the above does tube the blue Color constant.


On the first page of the overview of the new compiled FX Script
language (http://blogs.sun.com/chrisoliver/resource/lang/javafx.html),
there's an example that's supposed to show how much simpler the FX
Script version of the Swing "Hello World" app is.  Never mind that
the FX Script version omits all of those ugly imports.  What surprised
me was that the initial JFrame.pack() layout fails to initialize the
frame's size correctly in the FX Script version.  

This led to a funny result.  Here's the app:

package fxtest;
import javafx.ui.*;

Frame {
    visible: true
    content: Label {
        text: "Hello World"
        font: Font { faceName: "Helvetica" size: 64 }
    }
};


Here's the result:
[images\hell.PNG]



* Class Counts


javafx.ui - 152 classes
javafx.ui.canvas - 66 classes
javafx.ui.filter - 23 classes

241 classes total



* Color

I started out looking through the Widget API.  There a million criticisms
one could offer for all of the attributes and methods and what not, and
I started to write them down.  And then I grew weary of that because it
was clear that we're going to have to consider this whole review at a higher
level or it will never end.  One higher level question that's bothering 
me is: what's the value of FX Script classes that only slightly refine the 
API of underlying Java class?

So I took a look at the Color API.  Structurally, this is relatively simple.  
You've got the Paint class which appears to be abstract and just offers a
reference to a java.awt.Paint:

  import java.awt.Paint as AWTPaint;

  public class Paint {
      public operation getPaint(): AWTPaint;
      ...
  }

And then there's AbstractColor:

  import java.awt.Color as AWTColor;

  public class AbstractColor extends Paint {
      public operation getColor(): AWTColor;
      ...
  }

Which just adds a method that's likely to return exactly the same
thing as getPaint(), i.e. a java.awt.Color.   And then finally we have
the Color class itself (public API):

  public class Color extends AbstractColor {
      public attribute red: Number;
      public attribute green: Number;
      public attribute blue: Number;
      public attribute opacity: Number;

      public operation Color(r:Number, g:Number, b:Number, a:Number);
      public operation interpolate(nextValue:Color, t: Number): Color;

      public attribute factor: Number;
      public operation darker():Color;
      public operation brighter():Color;
      public operation moreTransparent():Color;
      public operation lessTransparent():Color;

      public function htmlRef(): String;
  }

It has a private java.awt.Color atttribute and the expected overrides
for getPaint,Color, and a binding to the public attributes:

  function Color.getPaint() { return awtColor; }
  function Color.getColor() { return awtColor; }
  attribute Color.awtColor = bind lazy new AWTColor(red, green, blue, opacity);

Mostly this is exactly the same API as java.awt.Color, less the
support for color spaces,and with the addition of the htmlRef and
interpoloate ops, a larger set of named colors and the addition of
more/lessTransparent operations, and the factor attribute, which
more/less and darker/brighter methods use to compute a new value.

The additions aren't terribly significant.  The lack of support 
for color spaces (notably color space conversions), is likely to
be restored as developers begin to use the API.  

The fundamental difference between the FX and AWT color classes is 
that the FX version is mutable.   The ARGB attributes are public
and read/write.  This seems to be very much in the spirit of the 
FX Script language and it implies that, in this case, one can not
simply view FX Script as a way to script our existing classes.

To simplify documenting and support the FX Script classes, I think
we'll want to find a way to define them as if they were fundamentally
the same as their Java counterparts.  At least that's what I thought
when I started looking this stuff over.  Now I'm not so sure.



* Widget

- public attributes alignmentX,Y

Can be difficult to work with.  Often what's really needed is support
for aligning components along their text baselines.  Baseline
alignment is relatively complicated to support. It was only added to
Swing/AWT in 1.6 Based on its importance to good automatic layouts, it
should have been there much earlier.


- public attribute sizeToFitColumn: Boolean?
- public attribute sizeToFitRow: Boolean?

These are hints to GroupLayout to make this component's width equal to
others in the same column.  This seems like rather limited advice. 
What if I'd like my component to take most of the available extra space?
If we're committing to GroupLayout as the layout manager for all
Widgets (CenterPanel, BorderPanel, etc, imply that we're not) then 
a comprehensive way to provide "hints" is warranted.  


- public attribute x: Number?
- public attribute y: Number?
- public attribute width: Number?
- public attribute height: Number?

These attributes appear to effect the Widget's bounds, but only "when 
the widget is "contained in a Panel".  Not entirely clear what that
means (are the values discarded if there's no Panel ancestor?).  Are 
these attributes automatically set by layout managers like BorderPanel?

- public attribute preferredSize: java.awt.Dimension?
- public attribute miniumSize: java.awt.Dimension?
- public attribute maximumSize: java.awt.Dimension?

I would assume that these attributes just mirror the corresponding
Component properties.  Do they belong on Nodes too?


- protected attribute awtBackground: java.awt.Color?
- protected attribute awtFont: java.awt.Font?
- protected attribute awtForeground: java.awt.Color?

I assume that these attributes are protected so that subclasses
can monitor dynamic changes caused by Swing L&F or theme changes.

- public attribute visible: Boolean?
Needs to define the widget's semantics in terms of layout, event dispatching,
keyboard focus, and rendering.
