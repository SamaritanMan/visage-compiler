#
# Copyright 1999-2007 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#

compiler.err.javafx.generalerror=\
    {0}.
compiler.err.javafx.lexer.literal.range=\
    Integer number too {0}: {1}.
compiler.err.javafx.range.start.int.or.number=\
    range start must be Integer or Number.
compiler.err.javafx.range.end.int.or.number=\
    range end must be Integer or Number.
compiler.err.javafx.range.step.int.or.number=\
    range step must be Integer or Number.
compiler.warn.javafx.range.literal.empty=\
    empty sequence range literal, probably not what you meant.
compiler.err.javafx.reserved.top.level.script.member=\
    reserved top-level script member {0}.
compiler.err.javafx.indexof.not.found=\
    cannot find \'for\' clause variable named {0}.
compiler.err.javafx.cannot.infer.return.type=\
    Non-final return requires explicit return type.
compiler.note.javafx.type.infer.cycle.fun.decl=\
    Need explicit type for {0} because of cycle in definition.
compiler.note.javafx.type.infer.cycle.var.decl=\
    Need explicit type for {0} because of cycle in initialization.
compiler.err.javafx.type.infer.cycle.var.ref=\
    This is the cyclic reference to {0} that prevents type inference. 
compiler.err.javafx.function.type.infer.cycle=\
    Need explicit return type for {0} because it is recursive.
compiler.err.javafx.void.sequence.not.allowed=\
    Sequence of Void not allowed.
compiler.err.javafx.only.one.base.java.class.allowed=\
    More than one Java class extended. Extended class {0}.
compiler.err.javafx.not.allowed.in.bind.context=\
    Not allowed in bind context {0}
compiler.err.javafx.expr.unsupported.for.bidi.bind=\
    Expression not supported for bind with inverse.
compiler.err.javafx.wrong.type.for.bidi.bind=\
    Type mismatch for bind with inverse\n\
    found: {0}\n\
    required: {1}
compiler.err.javafx.bound.override.meth=\
    Bound function cannot override non-bound function -- {0}
compiler.err.javafx.non.bound.override.meth=\
    Non-bound function cannot override bound function -- {0}
compiler.err.plugin.cannot.find.plugin=\
    Cannot find platform plugin for specified platform: {0}
compiler.warn.plugin.cannot.load.plugin=\
    Cannot load platform plugin from file: {0}
compiler.err.javafx.base.java.class.non.papar.ctor=\
    Base Java class {0} does not have a default constructor.
compiler.err.javafx.must.be.an.attribute=\
    {0} must be an attribute.
compiler.err.javafx.bound.function.must.not.be.void=\
    Bound function must not be void.
compiler.err.neither.conditional.subtype=\
incompatible types for ''if'' - neither is a subtype of the other\n\
second operand: {0}\n\
third operand : {1}
compiler.err.javafx.invalid.assignment=\
    Invalid assignment
compiler.err.javafx.def.must.have.init=\
    The def {0} must have an initializing expression
compiler.err.javafx.cannot.assign.to.def=\
    You cannot change the value(s) of ''{0}'' because it was declared as a ''def'', perhaps it should be a ''var''?
compiler.err.javafx.cannot.assign.to.parameter=\
    You cannot change the value(s) of ''{0}'' because it is a parameter.
compiler.err.javafx.function.declared.overrride.does.not.override=\
    Function {0} declared ''override'' but does not override another function.
compiler.err.javafx.var.not.supported.here=\
    ''{0}'' not currently supported in this location -- move {1} to the block level.
compiler.err.javafx.string.concatenation=\
+ cannot be applied to strings. Use a string expression "{0}"
compiler.err.javafx.loose.expressions=\
Loose expressions are not permitted in scripts with exported (''public'', etc) members.\n\
Move the expressions to be run on script invocation into a ''run'' function.
compiler.err.javafx.run.function.single=\
    There must be no more than one ''run'' function.
compiler.err.javafx.run.function.param=\
    ''run'' function must either have no parameters or one parameter of type ''String[]''.\n\
    Use:     function run()    or\n\
    Or use:  function run(args : String[])
compiler.err.javafx.report.write.access=\
    {0} has {1} write access in {2}
compiler.err.javafx.report.var.query.access=\
    {0} has {1} isInitiailized() access in {2}
compiler.err.javafx.report.bind.access=\
    {0} has {1} bind access in {2}
compiler.err.javafx.report.init.access=\
    {0} has {1} initialization access in {2}
compiler.err.javafx.not.supported.readable=\
    The ''readable'' keyword is no longer supported.  Please use ''public-readable'' to indicate that a variable can be read by the world.
compiler.err.javafx.not.supported.attribute=\
    The ''attribute'' keyword is no longer supported.  Please use ''def'' or ''var'' to declare class variables.
compiler.err.javafx.not.supported.private=\
    The ''private'' keyword is no longer supported.  The default access is script-private, so you can simply remove ''private''.
compiler.warn.javafx.generalwarning=\
    {0}.
compiler.warn.javafx.function.overrides.another.should.be.declared.override=\
    Function {0} overrides another, it should be declared ''override''.
compiler.warn.javafx.static.deprecated=\
''static'' is no longer supported.  \
It will be removed from the language soon. \
Use script-level declarations for {0}.
compiler.warn.javafx.ambiguous.param.type.from.super=\
Ambiguous parameter type in potentially overridden methods.
compiler.warn.javafx.ambiguous.return.type.from.super=\
Ambiguous return type in potentially overridden methods.
compiler.warn.javafx.iterating.non.sequence=\
    iterating over a non-sequence
compiler.warn.javafx.explicit.thread=\
    explicit use of threads is not supported
compiler.note.javafx.internal.error=\
    Sorry, compiler has crashed while looking at this.
compiler.err.javafx.not.a.function=\
  cannot apply a non-function (of type {0}) to {1}({2})
compiler.err.javafx.cant.apply.function=\
  cannot apply a function which expects ({0}) to ({1})
compiler.err.javafx.applied.to.instance.var=\
The argument to the function {0} must be a reference to an instance ''var''.
compiler.err.javafx.mod.not.allowed.on.local=\
    modifiers (in this case {0}) not allowed on a local {1}
compiler.err.javafx.mod.not.allowed.on.script=\
    modifier {0} not allowed on a script level {1}
compiler.err.javafx.mod.not.allowed.on.instance=\
    modifier {0} not allowed on an instance {1}
compiler.err.javafx.mod.not.allowed.on=\
    modifier {0} not allowed on a {1}
compiler.warn.javafx.redundant.access.modifiers=\
The access modifier {0} includes the access of {1}.
compiler.warn.illegal.forward.ref=\
Illegal forward reference: {0} {1} might not have been initialized.
javafx.msg.bug=\
An exception has occurred in the OpenJavafx compiler ({0}). \
Please file a bug at the Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)  \
after checking for duplicates. \
Include the following diagnostic in your report and, if possible, the source code which triggered this problem.  Thank you.
compiler.note.javafx.internal.error=\
The following error is an internal error in the OpenJFX compiler ({0}). \n\
Please file a bug at the Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)  \
after checking for duplicates. \
Include the following diagnostic in your report and, if possible, the source code which triggered this problem.  Thank you. \n\
---------- \n{1}\n----------
javafx.opt.arg.name=<platform>
javafx.opt.platform=Platform translator plug-in
javafx.opt.classpath=\
    Specify where to find user class files
opt.arg.path=\
    <path>
compiler.err.javafx.too.many.parameters=\
    sorry, not implemented: functions with more than 8 parameters
compiler.err.javafx.bad.str.compound=\
    Compound strings may only contain literals strings for compile time evaluation, not expressions (such as say variables) that must be evaluated at run time.
compiler.err.javafx.cannot.modify.localvar=\
    Local variables cannot be declared with access modifiers such as 'publc', 'public-read' and so on.
compiler.err.javafx.bad.character=\
    Sorry, but the character ''{0}'' does not mean anything to me, at least on its own. Is this a Typo?
compiler.err.javafx.hex.malformed=\
    Hexadecimal literals can only contain characters '0' to '9' and 'a' to 'f' or 'A' to 'F'. Is this a typo?
compiler.err.javafx.hex.float=\
    Hexdecimal numbers cannot form floating point literals. Is this a typo?
compiler.err.javafx.hex.missing=\
    Hexadecimal numbers must have at least one hex character following the '0x'. Is this a typo?
compiler.err.javafx.octal.malformed=\
    Numbers starting with a leading '0' are assumed to be octal, but this one contains characters other than '0' to '7'.
compiler.err.javafx.octal.float=\
    Octal numbers (numbers with a leading '0') cannot be used to form floating point literals. Is this a typo?
compiler.err.javafx.exponent.malformed=\
    Numbers in scientific E notation must specify an exponent as 'E', optionally followed by '-' or '+', then a numeric exponent.
compiler.err.javafx.unterminated.string=\
    Unterminated string literal - missing '' or ".
compiler.err.javafx.unterminated.string.expression=\
    Unterminated embedded string expression - missing ''}''.
compiler.err.javafx.unescaped.rbrace=\
    The character ''\}'' should be escaped in a string literal to avoid confusion with embedded expressions such as "'{' variable '}'".
compiler.err.javafx.semi.required=\
    You have forgotten the '';'', which is needed to separate one expression from the next.
compiler.err.javafx.incomplete.qual=\
    You have missed out a part of the qualified name.
compiler.err.javafx.import.bad.name=\
    The ''.*'' part of an import can only be the last part of the sequence, as in aaa.bbbb.*
compiler.err.javafx.import.bad.star=\
    The ''.*'' part of an import can only be given once, and it must be the last part of the qualified name, as in aaa.bbb.*
compiler.err.javafx.func.unnamed=\
    A declared function must be given a function name.
compiler.err.javafx.typed.override=\
    An override variable cannot be given a type as that comes from the variable you override.
compiler.err.javafx.finally.toomany=\
    You have too many ''finally'' clauses for the associated ''try'' block; there can be only one.
compiler.err.javafx.finally.notlast=\
    You must declare a finally block as the last part of a ''try''...''catch''...''finally'' construct. This one comes before subseqeunt ''catch'' clauses.
compiler.err.javafx.bad.try=\
    A ''try''...''catch''...''finally'' construct must have at least one ''catch'' clause or a ''finally'' clause, or both. This one has neither.
compiler.err.javafx.orphaned.finally=\
    This ''finally'' block has been orphaned and has no ''try'' to which it belongs.
compiler.err.javafx.orphaned.catch=\
    This ''catch'' block has been orphaned and has no ''try'' to which it belongs.
compiler.err.javafx.garbled.expression=\
    There is a garbled expression starting here, I have tried to ignore it.
compiler.err.javafx.orphaned.else=\
    This ''else'' expression does not belong to any previous ''if'' expression.
compiler.err.javafx.garbled.declaration=\
    There is a garbled class member definition starting here, I have tried to ignore it. Class members can be ''var'', ''def'', ''function'', ''init'' or ''postinit'' only.
compiler.note.javafx.optimization.statistic=\
    Optimization statistic: {0}: {1}
compiler.err.javafx.bad.def=\
    The ''def'' of ''{0}'' must be intialized with a value here. Perhaps you meant to use ''var''?
compiler.err.javafx.bad.percent=\
    The operator ''%'' is not valid in JavaFX. If you need to calculate a modulo, use the ''mod'' binary operator instead. Note that there is no direct equivalent to '%='.
compiler.err.javafx.not.ne=\
    The operator ''<>'' is not valid in JavaFX. If you are trying to say ''not equal to'', use the operator ''!=''.
compiler.err.javafx.generics.unsupported=\
    Java style generics are not currently supported in JavaFX, so you cannot use them here.
compiler.err.javafx.bad.empty.sequence=\
    An empty sequence is not a valid expression for this operation, I am looking for an expression that yields ''{0}''
compiler.err.javafx.bad.sequence=\
    A sequence is not a valid expression for this operation, I am looking for an expression that yields ''{0}''
compiler.err.javafx.var.overrides.member=\
    ''var'' overrides member {0} in {1}; use ''override''.
compiler.err.javafx.def.overrides.member=\
    ''def'' overrides member {0} in {1}.

# temporary messages to pass test
#
compiler.misc.version.resource.missing=\
    Resource bundle missing for version {0}.
compiler.misc.version.unknown=\
    Unknown version {0}.
