#
# Copyright 1999-2007 Sun Microsystems, Inc.  All Rights Reserved.
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.  
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, write to the Free Software Foundation,
# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
# CA 95054 USA or visit www.sun.com if you need additional information or
# have any questions.
#

compiler.err.javafx.generalerror=\
    {0}.
compiler.err.javafx.lexer.literal.range=\
    Integer number too {0}: {1}.
compiler.err.javafx.range.start.int.or.number=\
    range start must be Integer or Number.
compiler.err.javafx.range.end.int.or.number=\
    range end must be Integer or Number.
compiler.err.javafx.range.step.int.or.number=\
    range step must be Integer or Number.
compiler.warn.javafx.range.literal.empty=\
    empty sequence range literal, probably not what you meant.
compiler.err.javafx.reserved.top.level.script.member=\
    reserved top-level script member {0}.
compiler.err.javafx.indexof.not.found=\
    cannot find \'for\' clause variable named {0}.
compiler.err.javafx.cannot.infer.return.type=\
    Non-final return requires explicit return type.
compiler.err.javafx.can.not.import.integer.primitive.type=\
    Integer is primitive type. This type can not be imported.
compiler.err.javafx.can.not.import.boolean.primitive.type=\
    Boolean is primitive type. This type can not be imported.
compiler.err.javafx.can.not.import.number.primitive.type=\
    Number is primitive type. This type can not be imported.
compiler.err.javafx.can.not.import.string.primitive.type=\
    String is primitive type. This type can not be imported.
compiler.note.javafx.type.infer.cycle.fun.decl=\
    Need explicit type for {0} because of cycle in definition.
compiler.note.javafx.type.infer.cycle.var.decl=\
    Need explicit type for {0} because of cycle in initialization.
compiler.err.javafx.type.infer.cycle.var.ref=\
    This is the cyclic reference to {0} that prevents type inference. 
compiler.err.javafx.function.type.infer.cycle=\
    Need explicit return type for {0} because it is recursive.
compiler.err.javafx.void.sequence.not.allowed=\
    Sequence of Void not allowed.
compiler.err.javafx.only.one.base.java.class.allowed=\
    More than one Java class extended. Extended class {0}.
compiler.err.javafx.cannot.override.default.initializer=\
    Cannot override {1}.{0} default initializer in {2} subclass.
compiler.err.javafx.not.allowed.in.bind.context=\
    Not allowed in bind context {0}
compiler.err.javafx.expr.unsupported.for.bidi.bind=\
    Expression not supported for bind with inverse.
compiler.err.javafx.bound.override.meth=\
    Bound function cannot override non-bound function -- {0}
compiler.err.javafx.non.bound.override.meth=\
    Non-bound function cannot override bound function -- {0}
compiler.err.plugin.cannot.find.plugin=\
    Cannot find platform plugin for specified platform: {0}
compiler.warn.plugin.cannot.load.plugin=\
    Cannot load platform plugin from file: {0}
compiler.err.javafx.base.java.class.non.papar.ctor=\
    Base Java class {0} does not have a default constructor.
compiler.err.javafx.must.be.an.attribute=\
    {0} must be an attribute.
compiler.err.javafx.bound.function.must.not.be.void=\
    Bound function must not be void.
compiler.err.neither.conditional.subtype=\
incompatible types for ''if'' - neither is a subtype of the other\n\
second operand: {0}\n\
third operand : {1}
compiler.err.javafx.invalid.assignment=\
    Invalid assignment
compiler.err.javafx.def.must.have.init=\
    The def {0} must have an initializing expression
compiler.err.javafx.cannot.assign.to.def=\
    Cannot assign to def ''{0}''
compiler.err.javafx.cannot.assign.to.parameter=\
    Cannot assign to parameter ''{0}''
compiler.err.javafx.function.declared.overrride.does.not.override=\
    Function {0} declared ''override'' but does not override another function.
compiler.err.javafx.var.not.supported.here=\
    ''{0}'' not currently supported in this location -- move {1} to the block level.
compiler.err.javafx.string.concatenation=\
+ cannot be applied to strings. Use a string expression "{0}"
compiler.err.javafx.loose.expressions=\
Loose expressions are not permitted in scripts with exported (''public'', etc) members.\n\
Move the expressions to be run on script invocation into a ''main'' function.
compiler.err.javafx.run.function.single=\
    There must be no more than one ''run'' function.
compiler.err.javafx.run.function.param=\
    ''run'' function must either have no parameters or one parameter of type ''String[]''.\n\
    Use:     function run()    or\n\
    Or use:  function run(args : String[])
compiler.err.javafx.report.write.access=\
    {0} has {1} write access in {2}
compiler.err.javafx.report.init.access=\
    {0} has {1} initialization access in {2}
compiler.err.javafx.not.supported.readable=\
    The ''readable'' keyword is no longer supported.  Please use ''public-readable'' to indicate that a variable can be read by the world.
compiler.warn.javafx.not.supported.attribute=\
    The ''attribute'' keyword is no longer supported.  Please use ''def'' or ''var'' to declare class variables.
compiler.warn.javafx.not.supported.private=\
    The ''private'' keyword is no longer supported.  The default access is script-private, so you can simply remove ''private''.
compiler.warn.javafx.generalwarning=\
    {0}.
compiler.warn.javafx.function.overrides.another.should.be.declared.override=\
    Function {0} overrides another, it should be declared ''override''.
compiler.warn.javafx.static.deprecated=\
''static'' is no longer supported.  \
It will be removed from the language soon. \
Use script-level declarations for {0}.
compiler.warn.javafx.ambiguous.param.type.from.super=\
Ambiguous parameter type in potentially overridden methods.
compiler.warn.javafx.ambiguous.return.type.from.super=\
Ambiguous return type in potentially overridden methods.
compiler.warn.javafx.iterating.non.sequence=\
    iterating over a non-sequence
compiler.err.javafx.not.a.function=\
  cannot apply a non-function (of type {0}) to {1}({2})
compiler.err.javafx.cant.apply.function=\
  cannot apply a function which expects ({0}) to ({1})
javafx.msg.bug=\
An exception has occurred in the OpenJavafx compiler ({0}). \
Please file a bug at the Openjfx-compiler issues home (https://openjfx-compiler.dev.java.net/Issues)  \
after checking for duplicates. \
Include the following diagnostic in your report and, if possible, the source code which triggered this problem.  Thank you.
javafx.opt.arg.name=<platform>
javafx.opt.platform=Platform translator plug-in
javafx.opt.classpath=\
    Specify where to find user class files
opt.arg.path=\
    <path>
compiler.err.javafx.too.many.parameters=\
    sorry, not implemented: functions with more than 8 parameters
compiler.err.javafx.bad.str.compound=\
    Compound strings may only contain literals strings for compile time evaluation, not expressions (such as say variables) that must be evaluated at run time.
compiler.err.javafx.cannot.modify.localvar=\
    Local variables cannot be declared with access modifiers such as 'publc', 'public-read' and so on.
compiler.err.javafx.bad.character=\
    The character '{0}' is invalid. Is this a Typo?
compiler.err.javafx.hex.malformed=\
    Hexadecimal literals can only contain characters '0' to '9' and 'a' to 'f' or 'A' to 'F'. Is this a typo?
compiler.err.javafx.hex.float=\
    Hexdecimal numbers cannot form floating point literals. Is this a typo?
compiler.err.javafx.hex.missing=\
    Hexadecimal numbers must have at least one hex character following the '0x'. Is this a typo?
compiler.err.javafx.octal.malformed=\
    Numbers starting with a leading '0' are assumed to be octal, but this one contains characters other than '0' to '7'.
compiler.err.javafx.octal.float=\
    Octal numbers (numbers with a leading '0') cannot be used to form floating point literals. Is this a typo?
compiler.err.javafx.exponent.malformed=\
    Numbers in scientific E notation must specify an exponent as 'E', optionally followed by '-' or '+', then a numeric exponent.
# temporary messages to pass test
compiler.misc.version.resource.missing=\
    Resource bundle missing for version {0}.
compiler.misc.version.unknown=\
    Unknown version {0}.
