/*
 * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4 of the JavaFX parser grammar.
//
// @author Jim Idle
//
// Version 4 of the grammar reverts to a separate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// JavafxTree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar v4Parser;

options { 

	// Rather than embed parser oriented Java code in this grammar, just to override
	// methods in the ANTLR base recognizer and derviative classes, we
	// instruct ANTLR to generate a class which is dervied from our own
	// super class. The super class is where we embody any code that does
	// not require direct access to the methods generated 
	// to implement the parser. Hence for instance this is where the 
	// JavafxTreeMaker lives.
	//
	superClass 	= AbstractGeneratedParserV4; 

	// Import the token vocabulary, generated by the
	// lexer grammar analysis.
	//
	tokenVocab	= v4Lexer;
}

tokens
{
	LAST_TOKEN;
}

// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package com.sun.tools.javafx.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.javac.tree.*;
import com.sun.tools.javafx.tree.*;
import com.sun.javafx.api.tree.*;

import com.sun.tools.javac.util.*;
import com.sun.tools.javafx.util.MsgSym;

import com.sun.tools.javac.code.*;
import com.sun.tools.javafx.code.JavafxFlags;
import static com.sun.tools.javac.util.ListBuffer.lb;
import com.sun.javafx.api.JavafxBindStatus;

import static com.sun.javafx.api.JavafxBindStatus.*;

}
 
// ------------------------------------------------------------------    	
// ------------------------------------------------------------------
// PARSER RULES
//
// The parser consumes the token stream created by calling the lexer until
// we see EOF. When the parser starts, the entire token stream is created.
// We cannot do syntax directed parsing as it means you cannot use LL(*)
// algorithms for grammar analysis and code generation.
//
// The parsers job is to produce the JavaFX specialized AST, which
// is the basis for all the rest of the tool chain, including symbol table and code 
// generation as well as code completion for editors and so on.
// ------------------------------------------------------------------

/**
 * The usual entry point for the JavaFX parser, this will parse a complete
 * script body and manufacture the JavaFX AST.
 *
 * A script, like many other syntactical elements, can have an associated
 * comment. When the parse is complete, we scan the tokens that are normally
 * hidden from the parser looking for comments and associate them with
 * AST node for the script.
 */
script

	returns	[JFXScript result]
	
@init
{
	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// AST start position
	//
	int	rPos = pos();
	
	// Initialize the tree map if we are creating the AST end position
	// map.
	//
	endPositions = genEndPos ? new HashMap<JCTree,Integer>() : null;
	
	// Initialize document comment collection
	//
	docComments	= null;
}

	:  pd=packageDecl si=scriptItems 
	
		{
			// Construct the JavFX AST
			//
			$result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment);	// Add any detected documentation comment
            
   			// Set tree span and endpoint map (if required).
        	//
        	$result.pos = rPos;
        	endPos($result); 
        	
        	// Pass on the documentation comments and the endpos map
        	//
        	$result.docComments 	= docComments;
        	$result.endPositions	= endPositions;
		}

		EOF 	// Forces parser to consume entire token stream or error out
    ;
    
// ----------------------    
// Package specification.
// The package declaration is optional. It qualifes the namespace/location
// of all subsequent delcarations in the script.
//
packageDecl

	returns [JFXExpression value] 	// Package declaration builds a JFXExpression tree

@init
{
	// AST start position
	//
	int	rPos = pos();
}
    : PACKAGE qualname possiblyOptSemi
    
    		{ 
    			$value = $qualname.value;
    		}
    		
    | // No package specified
    
    		{ $value = null; }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Error node for AST
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

	
	returns [ListBuffer<JFXTree> items = new ListBuffer<JFXTree>()] // This rule builds a list of JFXTree, which is used 
																	// by the caller to build the actual AST.
																	//
@init
{
	// AST start position
	//
	int	rPos = pos();
}
	:	(scriptItem[$items] possiblyOptSemi)*
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Error node for AST
	//
	JFXErroneous value = F.at(rPos).Erroneous();
	endPos(value);
	$items.append(value);
	
 }
 
scriptItem  [ListBuffer<JFXTree> items] // This rule builds a list of JFXTree, which is used 
										// by the caller to build the actual AST.
										//
@init
{
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
}
	:
			  // Certain script members may be prefixed with modifiers
			  // such as 'public'. We allow the parser to first consume 
			  // all modifier keywords, regardless of whether this is a 
			  // valid modifier for the upcoming declaration. Whether it is
			  // valid or not is a matter for semantic checks to decide.
			  //
			  // Script level variable declarations can conflict with
			  // local variable declarations (which do not allow modifiers
			  // and are encapsulated in the expression rule, which is called
			  // by the statement rule. Hence we must special case it here
			  // unless we want to pass around status to all our rules.
			  // The predicate is a small one and passes or fails quickly.
			  //
			  	m1=modifiers { errNodes.append($m1.mods); }
				(
					  c=classDefinition			[$m1.mods, $m1.pos]
					  
					 		{ 	errNodes.append($c.value);
								$items.append($c.value); 
							}
							
					| f=functionDefinition    	[$m1.mods, $m1.pos]
					

					 		{ 
					 			errNodes.append($f.value);
								$items.append($f.value); 
							}
				)
				
			| i=importDecl
			
				{ 
					errNodes.append($i.value);
					$items.append($i.value); 
				}
			
			| s=statement
			
				{ 
					errNodes.append($s.value);
					$items.append($s.value); 
				}
			
			| SEMI
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input. If we receive an exception here
// it is because whatever token was next in the input stream did not predict
// any of the alts. So, we recover the input stream up to the next token
// in the followset (standard ANTLR recovery), then build an erroneous node
// that contains no sub trees, but identifies the start and end of the
// error
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Now construct an Erroneous node to span the error nodes
	// 
	JFXErroneous errors = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errors);
	
	// And add this in to the script item list
	//
	$items.append(errors);
 }
 
// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the smeantics of the modifiers.
//
modifiers

	returns [JFXModifiers mods, int pos]	// Constructs and returns a specialized modifer node

@init {

	// The flags we build up for the AST
	//
	long	flags 	= 0;
	
	// The start character position for this AST
	//
	$pos		= pos();
}

	: 	(	
			mf=modifierFlag
			
			{
				// Or in the newly discovered modifier
				//
				flags	|= $mf.flag;
			}
	
		)*
		
		{
			// Build the modifier flags (just as empty if we did not pick any up)
			//
			$mods = F.at($pos).Modifiers(flags);

			// Tree span
			//
			endPos($mods);
		}
	;

 
// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

	returns [long flag]
	
	: ABSTRACT			{ $flag = Flags.ABSTRACT;				}
	| BOUND				{ $flag = JavafxFlags.BOUND;			}
	| OVERRIDE			{ $flag = JavafxFlags.OVERRIDE;			}
	| PACKAGE			{ $flag = JavafxFlags.PACKAGE_ACCESS;	}
	| PROTECTED			{ $flag = Flags.PROTECTED;				}
	| PUBLIC			{ $flag = Flags.PUBLIC;					}
	| PUBLIC_READ   	{ $flag = JavafxFlags.PUBLIC_READ;		}
	| PUBLIC_INIT		{ $flag = JavafxFlags.PUBLIC_INIT;		}
        
	
	//TODO: deprecated -- remove these at some point
	//                    For now, warn about their deprecation
	//
	| PRIVATE			{ log.warning(pos($PRIVATE), "javafx.not.supported.private"); }
	| STATIC			{ $flag = Flags.STATIC;      			}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
 }
 
// -----------------	
// Import statement.
// Include definitions from an external source
//
importDecl

	returns [JFXTree value] // The import declaration is built as a generic JFXTree

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	

}
	
 	: IMPORT importId
 	
 		{
 			// AST construction
 			$value = F.at(rPos).Import($importId.pid);
 			
 			// AST span
 			//
			endPos($value);
 		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Error node for AST, note that if we found an importId then we would
	// not be in the exception handler, so no need to accumulate it for
	// error.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);

 }
 
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

	returns [JFXExpression pid]	// Qualified names are built as expression trees

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Record the start position of this rule, in case of errors
	//
	int rPos = pos();
	
	// Flag indicates that the token sequence was in error
	//
	boolean	inError = false;
	
	// Flag indicates that we have seen .'*' already
	//
	boolean haveStar = false;
	
	// Record the posiotn of any START we find, in case we want to error upon it
	//
	int	starP = 0;
}
 	: i1=identifier
 		{
 			$pid = $i1.value;
 			
 			// Accumulate in case of error, and flag if the indentifer was not thre
 			//
 			errNodes.append($i1.value);
 			inError = $i1.inError;
 		}
		( 
			(
				  DOT 
				| DOTDOT
					{
						// If the programmer accidentally typed import X..y; then the
						// lexer will see that as a range operator, but here, that tells
						// us there was a missing qualifer
						//
						inError = true;		// Signal that this is malformed
						log.error(pos($DOTDOT)+1, MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
					}
			)
				(
					(IDENTIFIER)=> n2=name
					{
						// Check for errors
						//
						if	($n2.inError)
						{
							// We shoudl not be able to get this, as the follow set
							// will not allow error recovery to insert a token as
							// it is not singular - which one should it insert? However
							// future improvements may make this happen, so code for it anyway
							//
							inError = true;		// Signal that this is malformed
							log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
						}
						
						$pid = F.at($n2.pos).Select($pid, $n2.value);
                	    endPos($pid);
                    
                	    // Build up new node in case of error
						//
						JFXExpression part = F.at($n2.pos).Ident($n2.value);
						errNodes.append(part);
						endPos(part);

						// If we already had a '.*' part, then this makes no sense
						//
						if	(haveStar) {
						
							inError = true;		// Signal that this is malformed
							log.error(starP, MsgSym.MESSAGE_JAVAFX_IMPORT_BAD_NAME);
						}
					}

				| 	(STAR)=>STAR
        	
        			{
						$pid = F.at($n2.pos).Select($pid, names.asterisk);
                	  	endPos($pid);

                	  	// Build up new node in case of error
						//
						starP = pos($STAR);
						JFXExpression part = F.at(starP).Ident(names.asterisk);
						errNodes.append(part);
						endPos(part);
						
						// If we already had a '.*' part, then this makes no sense
						//
						if	(haveStar) {
						
							inError = true;		// Signal that this is malformed
							log.error(starP, MsgSym.MESSAGE_JAVAFX_IMPORT_BAD_STAR);
						}
						
						// Signal that we have a star now
						//
						haveStar = true;
					}
					
				|	// Erroneous
				
					{
						inError = true;		// Signal that this is malformed
						log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
					}
					
				)

        )*
        
        {
        	// Was the seqeunce in error?
        	//
        	if	(inError) {
        		$pid=F.at(rPos).Erroneous(errNodes.elems);
        		endPos($pid);
        	}
        }
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// And we need to return an erroneous node
	//
	$pid=F.at(rPos).Erroneous(errNodes.elems);
    endPos($pid);  	
 }
 
// Class definition.
// Parses a complete class definition and builds up the JFX AST
// that represents this.
//
// param mods The previously built modifier flags
//
classDefinition [ JFXModifiers mods, int pos ]

	returns [JFXTree value]	// The class definition has its own JFXTree type, but we might need Erroneous here
	
@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

	// List of all super classes
	//
	ListBuffer<JFXExpression> ids	= null;
	
	// List of all members
	//
	ListBuffer<JFXTree> mems		= null;
}

	: CLASS 
	
			n1=name 		
				{ 
					// Build up new node in case of error
					//
					JFXExpression part = F.at($n1.pos).Ident($n1.value);
					endPos(part);
					errNodes.append(part);
				}
				
			supers
			
				{
					// Accumulate in case of error
					//
					ids = $supers.ids;
					for ( JFXExpression ex : ids)
					{
						errNodes.append(ex);
					}
				}
			 
		LBRACE 
			classMembers 
			
				{
					// Accumulate in case of error
					//
					mems = $classMembers.mems;
					for (JFXTree m : mems)
					{
						errNodes.append(m);
					}
				}
		RBRACE
		
		{ 
			$value = F.at($pos).ClassDeclaration
				(
	  						  
					$mods,	
					$name.value,
					ids.toList(),
					mems.toList()
				);
				setDocComment($value, docComment);	// Add any detected documentation comment
				endPos($value, pos($RBRACE)); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// However, we need to collect the nodes we found into an Erroneous class
	// definition, as if the got an error in this rule, it was a pretty high
	// up problem, syntactically. Something like "public class" and nothing else
	// which can of course come in from IDEs/Editors, all the time.
	//
	$value = F.at($pos).Erroneous(errNodes.elems);
	endPos($value);
	
 }
 
// -----------------
// Super class spec.
// Parses a list of super classes for a class definition and builds the
// associated JFX AST.
//
supers 

	returns [ListBuffer<JFXExpression> ids = new ListBuffer<JFXExpression>()]	// The return is a list of JFX expressions representing one
																				// or more super class type name.
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start position in case of error
	//
	int	rPos = pos();
}
	: EXTENDS t1=typeName
			{
				$ids.append($t1.value);			// First type name in list
				errNodes.append($t1.value);		// Accumulate in case of error
			}
           ( 
           	COMMA t2=typeName 
           	
           		{ 
           			$ids.append($t2.value); 
           			errNodes.append($t2.value);
           		}
           )*
           
	| // Upsilon - this class inherits no other types so the list will be empty
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Produce the ERRONEOUS node
	//
	$ids = new ListBuffer<JFXExpression>();
	JFXErroneous errnode = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errnode);
	$ids.append(errnode);
 }
 		
// --------------
// Class members.
// Parses all the possible elements of a class definition and produces the
// Java FX AST nodes that represent them
//
classMembers 

	returns [ListBuffer<JFXTree> mems = new ListBuffer<JFXTree>()]		// Returns a list of the class members, ready for the caller to produce the
																		// class defintion AST.
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start position, in case of error
	//
	int	rPos = pos();
}
	: (classMemberSemi[$mems] possiblyOptSemi)*
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Though it should be impossible to find an error within this rule, we have
	// coded against the impossible out of respect for Douglas Adams.
	//
	for	( JFXTree t : $mems) {
		errNodes.append(t);
	}
	
	// Reset what we accumulated so far
	//
	$mems = new ListBuffer<JFXTree>();
	JFXErroneous errnode = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errnode);
	$mems.append(errnode);
	
 }
 
classMemberSemi [ListBuffer<JFXTree> mems]
	: classMember 
	
		{ 
			$mems.append($classMember.member); 
		}
		
	| SEMI
	;
 
// --------------
// Class members.
// Parses all constructs that can be a member of a class and returns
// the JAva FX AST that represents it.
//
classMember

 	returns [JFXTree member]		// A class member has a specialized JFX tree node, which is what
									// we return from this rule.

 @init {

	// The start character position for this AST
	//
	int rPos		= pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	: initDefinition				{ $member = $initDefinition.value; 		}
	| postInitDefinition			{ $member = $postInitDefinition.value; 	}
	| m=modifiers
		(
			  variableDeclaration		[$m.mods, $m.pos] 		{ $member = $variableDeclaration.value; }
			| functionDefinition		[$m.mods, $m.pos]		{ $member = $functionDefinition.value; 	}
		)
	;

// Catch an error when looking for a class member. We create an erroneous node
// for anything that was at the start up to wher
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform custom resyncing for class members
	//
	member = resyncClassMember(rPos, re);
	
 }

// ----------
// Functions.
// While funcitnos can be declared at any level, their syntax is the same.
// As always, the semantic pass of the JFX tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition [ JFXModifiers mods, int pos ]

	returns [JFXTree value]		// A function defintion has a specialized node in the JavaFX AST

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: FUNCTION 
		
		(
			n1=name 
				{
					if	($n1.inError) {
					
						// Function cannot be anonymous here
						//
						log.error($n1.pos, MsgSym.MESSAGE_JAVAFX_FUNC_UNNAMED);
					}
					
					// Accumulate a node in case of error
					//			
					JFXIdent id = F.at($n1.pos).Ident($n1.value);
					endPos(id);
				
					// Accumulate in case of error
					//
					errNodes.append(id);
				}
		)
		formalParameters
			{
				// Accumulate the parameter nodes in case of error
				//
				for	(JFXTree t : $formalParameters.params) {
					errNodes.append(t);
				}
			}
			
		typeReference 
			{
				// Accumulate in case of error
				//
				errNodes.append($typeReference.rtype);
			}
	
		// The function block is optional if this is an abstract funtino definition
		// but in that case a semi colon is required. If this is not an abstract function
		// we let the attributioin function report that there is no function body defined
		// as this may be coming from an IDE.
		//
		(	  (LBRACE)=>block 
		
				{
					// Accumulate in case of error
					//
					errNodes.append($block.value);
				}
			
			| 	// This alt is selected only if the functino declaration is not abstract
				// and there was no function body. If there is a SEMI at this point, it does not
				// matter as it will be eaten by the enclosing rule as if it were an empty statement.
				//
		)
	
		{
			// Create the function defintion AST
			//
			$value = F.at($pos).FunctionDefinition
							(
								$mods,
								$n1.value, 
								$typeReference.rtype,
								$formalParameters.params.toList(), 
								$block.value
							);
							
			// Documentation comment (if any)
			//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Produce an error node rather than a function definition node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
 }
 
 
// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initDefinition

	returns [JFXTree value]	// The initialisation block has a specialized JFX tree node

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: INIT block
	
		{
			// Build the AST
			//
			$value = F.at(pos($INIT)).InitDefinition($block.value);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// If we took an exception, then there will not be a block to construct
	//
	$value = F.at(rPos).Erroneous();
 }
 
// Post initialization.
// Parse the post initialization block and produce the AST
//
postInitDefinition

	returns [JFXTree value]	// Post initialization has its own specialized JFX tree node

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: POSTINIT block
		{ 
			// Build the AST
			//
			$value = F.at(pos($POSTINIT)).PostInitDefinition($block.value);

			// Tree span
			//
			endPos($value); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// If we took an exception, then there will not be a block to construct
	//
	$value = F.at(rPos).Erroneous();
 }
 
//triggerDefinition
//	: WITH name onReplaceClause		-> ^(WITH name onReplaceClause)
//	;


// Variables.
// While they can be defined at different levels (script, member, local) the syntax
// for declaring variables, and the modifiers and so on are all exactly
// the same (syntactically) at all levels.
// Parser a variable declaration and return the resultant JFX expression tree.
//
variableDeclaration [ JFXModifiers mods, int pos ]

	returns [JFXExpression value]

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

    // Bind status if present
    //
    JavafxBindStatus bStatus = null;

    // Bind value expression, if present
    //
    JFXExpression bValue = null;

    // ONReplace clause if present
    //
    JFXOnReplace  oValue = null;
 
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
   
   	// Used by error accumulation and override construction
   	//
   	JFXIdent part = null;
   
}
	: variableLabel  
	
		n=name
		
			{ 
				// Build up new node in case of error
				//
				part = F.at($n.pos).Ident($n.value);
				endPos(part, $n.pos);	// Was not really there
				errNodes.append(part);
			}
			
		tr=typeReference 	{ errNodes.append($tr.rtype); }  // Accumulate for errors

        (
            (EQ)=>EQ boundExpression
                {
                    bValue  = $boundExpression.value;
                    bStatus = $boundExpression.status;
                    errNodes.append($boundExpression.value);
                }
        )? 
        
        (
            (ON)=>onReplaceClause
                {
                    oValue = $onReplaceClause.value;
                    errNodes.append($onReplaceClause.value);
                }
        )?
	
		{
			// Add in the modifier flags accumulated by the label type
			// Note that syntactically, we allow all label types at all levels and must throw
			// out any invalid ones at the semantic checking phase
			//
			$mods.flags |= $variableLabel.modifiers;
	    	
	    	// Construct the variable JFXTree, unless it was in error
	    	//
	    	if	($n.inError) {
	    	
	    		$value = F.at($pos).Erroneous(errNodes.elems);
	    		
	    	} else {
	    	
	    		// Here, we can have either an OVERRIDE or a striaght
	    		// declaration, but the AST nodes are different.
	    		//
	    		if	(($mods.flags & JavafxFlags.OVERRIDE) == JavafxFlags.OVERRIDE) {
	    		
	    			// Build the AST for OVERRIDE var
					//
					$value = F.at($pos).OverrideClassVar
						(
							part,
							bValue,
							bStatus,
							oValue
						);
						
					// Need to check that the override did not specify at type as
					// the type comes from whatever you are overriding
					//
					if	(!($typeReference.rtype instanceof JFXTypeUnknown)) {
					
						log.error($typeReference.rtype.pos, MsgSym.MESSAGE_JAVAFX_TYPED_OVERRIDE);
					}
			
	    		} else {
			    
			    	$value = F.at($pos).Var
			    				(
			    					$name.value,
			    					$typeReference.rtype,
			    					$mods,
			    					bValue,
			    					bStatus,
			    					oValue
			    				);
			    }
	    	}
	    	// Documentation comment (if any)
	    	//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}	
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Enter into AST as an erroneous node
	//
	$value = F.at($pos).Erroneous(errNodes.elems);
	endPos($value);
	
 }
 
// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters

	returns [ListBuffer<JFXVar> params = new ListBuffer<JFXVar>()]		// Return type is a list of all the AST nodes that represent a 
																		// formal parameter, this is used to generate the AST for the
																		// funciton definition itself.
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: LPAREN 
	
		(
			fp1=formalParameter 
	
			{
				// Capture the first parameter
				//
				params.append($fp1.var); 
			}
			(
				COMMA fp2=formalParameter
				
					{ 
						// Second and subsequent parameter ASTs
						//
						params.append($fp2.var); 
					} 
			)*  
		)?
			
	  RPAREN
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Because we have raised the error, we won't perform codegen, but we can
	// leave the list in tact so that the IDE has something to work with. The list
	// is optional, so even if we have gathered none, we are still good.
	//
 }
 
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

	returns [JFXVar var]	// Formal parameters are contained in a JFX tree var node.
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: name typeReference
	
		{ 
			if ($name.inError) {
			
				// Looks like the name was missing, create an erroneous var instead
				// Build up new node in case of error
				//
				JFXExpression part = F.at($name.pos).Ident($name.value);
				errNodes.append(part);
				endPos(part);
				errNodes.append($typeReference.rtype);
				
			} else {
			
				$var = F.at($name.pos).Param($name.value, $typeReference.rtype);
			}
			endPos($var); 
		}
	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Because both name and typeReference will recover with something
	// sensible, we don't ned to create anything here. In theory, we can't
	// even get here.
	//
 }
 
// ------
// block.
// A block component is actually a unit that returns a value, it is an expression.
// In certain contexts the braces are more lexigraphically significant, such as the
// boundaires of if blocks. Hence those contexts specify the block directly rather than
// leaving the expression statement to pick it up.
//
// This means that a statement such as:
//
// if (x) { y} -z
//
// Does not consume the { y } -z as a complete expression but does
// what a programmer intuitively expects and uses only {y } as the
// subject of the if, with -z being a separate expression statement.
//
// A programmer can treat the above construct as a single expression
// by enclosing it in braces:
//
// if (x) { { y } -z }
//
// Which is then obvious. This also improves error recovery possibilities,
// which is a requirement for code completion utilities and so forth.
//
block 

	returns [JFXBlock value]	// The block expression has a specialized node inthe JFX tree

@init { 

	// A list of all the statement ASTs that make up the block expression
	//
	ListBuffer<JFXExpression> stats = new ListBuffer<JFXExpression>(); 
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	
	: LBRACE syncBlock[stats]
		(
			  blkValue=blockElement[$blkValue.value, stats]
													{errNodes.append($blkValue.value);}
			  syncBlock[stats]
	   )*
	
	  RBRACE
	  
	  	{
		  	$value = F.at(pos($LBRACE)).Block(0L, stats.toList(), $blkValue.value);
	  		endPos($value);
	  	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an erroneousBlock, which is basically an Erroneous node
	// masquerading as a JFXBlock.
	//
	$value = F.at(rPos).ErroneousBlock(errNodes.elems);
	endPos($value);
 }

// ---------------------------- 
// Statement/Expression resync.
// If left to itself, the block rule cannot easilly resync to the start of a statement
// because we will throw an exception on trying to work out if we can insert or
// delete a token.
//
// If we use this rule after the open '{' and at the end of every complete/recoverable
// statement contained in a block, then it will be called unconditionally (it always
// matches the next token because it is the upsilon set). Most importantly, the followset
// stack will contain the follow set that is allowed to start a new statement. Hence our
// init rule just uses the trick of syncing to the next good statement, and throwing out
// any garbled expressions with a neat error. 
// 
// We record the token stream start position on rule entry, and upon rule exit
// if we consumed any tokens, then we add an Erroneous node to the AST and everyone is
// happy.
//
syncBlock[ListBuffer<JFXExpression> stats]
@init
{
	// Start of rule for error node production
	//
	int	rPos	= pos();
	
	// Consume any garbled tokens that come before the next statement
	// or the end of the block. The only slight risk here is that the
	// block becomes MORE inclusive than it should but as the script is
	// in error, this is a better course than throwing out the block
	// when the error occurs and screwing up the whole meaning of
	// the rest of the token stream.
	//
	syncToGoodToken();
}
@after
{
	// If we consume any tokens at this point then we create
	// an ERRONEOUS AST node for the IDE to monitor and add it
	// in to the staement list.
	//
	if	(rPos != pos()) {
	
		// Span all the tokesn we had to consume.
		//
		JFXErroneous errNode = F.at(rPos).Erroneous();
		endPos(errNode);
		$stats.append(errNode);
		
		// Tell the script author where we think there is a screwed up expression
		//
		log.error(rPos, MsgSym.MESSAGE_JAVAFX_GARBLED_EXPRESSION);
	}
}
	:	// Deliberately match nothing, causing this rule always to be 
		// entered.
	;
	
// -----------------
// Block expression
// A single element (statement/expression etc) of a block, separated
// into it's own rule so that erroneous statements do not abort the
// entire block.
//
blockElement [JFXExpression val, ListBuffer<JFXExpression> stats]

returns [JFXExpression value] // All statements return an expression tree

@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
}
	: s=statement 
		{
			// If the current statement is not the first one
			// then append it to the list. This logic leaves us with 
			// the AST for the last statement in the block
			// in our val variable, which we need to build the
			// AST for the block.
			//
			if	($val != null) {
				$stats.append($val);
			}
					
			// Pick up the AST for the statement we just parsed.
			//
			if	(! ($s.value instanceof JFXErroneous)) {
					
				// Only make the result of the block be this statement
				// if it was not erroneous, then when the IDE Attributes
				// the AST, the result of the block will be null or some
				// value that can be typed, and the AST will not throw NPE
				// when typing the block
				//
				$value = $s.value;
					 
			} else {
					
				stats.append($s.value);	// Ensure we include Erroneous
				$value = null;
			}
					
			errNodes.append($s.value);	// In case of error
			
		}
			possiblyOptSemi

	| SEMI	// Empty statements are just ignored

	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an erroneousBlock, which is basically an Erroneous node
	// masquerading as a JFXBlock.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -----------
// statements.
// Parse the set of elements that are viewed as programming statements. Note
// that this includes expressions, which are considered statements, or perhaps
// more accurately, statements are just other expressions.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, or whether this is optional, or whether this is
// conditionally optional, such as the last statement of the script or
// brace block.
//
statement 


	returns [JFXExpression value] // All statements return an expression tree
	
@init
{	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: insertStatement		{ $value = $insertStatement.value; 								}
	| deleteStatement		{ $value = $deleteStatement.value; 								}
 	| whileStatement		{ $value = $whileStatement.value; 								}
	| BREAK    				{ $value = F.at(pos($BREAK)).Break(null); 		endPos($value); }
	| CONTINUE  	 	 	{ $value = F.at(pos($CONTINUE)).Continue(null);	endPos($value); }
    | throwStatement	   	{ $value = $throwStatement.value; 								}
    | returnStatement 		{ $value = $returnStatement.value; 								}
    | tryStatement			{ $value = $tryStatement.value; 								}
    | expression			{ $value = $expression.value;									}
    ;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Here, we can only have got junk, as badly formed statement elements
	// will be caught in their own rules.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }

// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

	returns [JFXOnReplace value]	// onReplace has its own JFX Tree node type

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: ON REPLACE oldv=paramNameOpt 
						{ 
							if	($oldv.var != null)
							{
								errNodes.append($oldv.var);
							}
						}
	
		(
			  (
			  	LBRACKET 
			  		first=paramName 
						{ 
							errNodes.append($first.var);
						}
			  		DOTDOT 
			  		last=paramName 
						{ 
							errNodes.append($last.var);
						}
			  	RBRACKET
			  )?
			 
				 EQ newElements=paramName
						{ 
							errNodes.append($newElements.var);
						}
		)? 
		
	
		block
		
		{ 
			// Build the appropriate AST
			//
			$value = F.at(pos($ON)).OnReplace($oldv.var, $first.var, $last.var, $newElements.var, $block.value);
			endPos($value); 
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Construct an erroneous version of the expected class
	//
	$value = F.at(rPos).ErroneousOnReplace(errNodes.elems);
	endPos($value);
	
}
 
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

	returns [JFXVar var]	// Returns a JFXVar tree node

    : paramName
    	{
    		{ $var = $paramName.var; }
    	}
    
    |	{ $var = null; }
    ;
 
// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

	returns [JFXVar var]	// Returns a JFXVar tree node

	: pn=IDENTIFIER
	 	{
    		Name name;
    		
    		// The recovery mechanisms will auto generate the IDENTIFIER
			// token, in the case that it can predict that it was just a single
			// token that the programmer forgot to use. Hence we must
			// pick up on that and generate a different node for a Missing
			// identifier.
			//
			if ($IDENTIFIER instanceof MissingCommonToken) {
			
			    name = Name.fromString(names, $IDENTIFIER.text);
			    $var = F.at(pos($IDENTIFIER)).Param(name, F.TypeUnknown()); 
			    endPos($var, pos());
			    
			} else {
			
			    name = Name.fromString(names, $IDENTIFIER.text);
			    $var = F.at(pos($IDENTIFIER)).Param(name, F.TypeUnknown()); 
			    endPos($var, pos($IDENTIFIER) + name.length());
			}
    	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
 }
    
// The ways in which a variable can be declared
//
variableLabel 
	
	returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
	
	: VAR			{ $modifiers = 0L; $pos = pos($VAR); }
	| DEF			{ $modifiers = JavafxFlags.IS_DEF; $pos = pos($DEF); }
	| ATTRIBUTE		{ $modifiers = 0L; $pos = pos($ATTRIBUTE); log.warning(pos($ATTRIBUTE), "javafx.not.supported.attribute"); }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	$modifiers = 0L;
	$pos = semiPos();
 }
 
// ------	
// Throw.
// Parse the standard exception throwing mechanism.
//
throwStatement

	returns [JFXExpression value]	// Returns the JFX Expression tree representing what we must throw
	
@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: THROW expression
	
		{ 
			// AST for the thrown expression
			//
			$value = F.at(pos($THROW)).Throw($expression.value);
			
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Now we need an error node
	//	
	$value = F.at(rPos).ErroneousThrow();
	endPos($value);
 }
 
// ---------------
// While statement
//
whileStatement
	
	returns [JFXExpression value]	// Returns the JFX Expression tree representing the WHILE
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: WHILE 
		LPAREN 
			expression 
				{
					errNodes.append($expression.value);
				}
		RPAREN 
	
		 loopVal=statement
			
		{
	
			// The AST for the WHILE, using either the block or statement
			//
			$value = F.at(pos($WHILE)).WhileLoop($expression.value, $loopVal.value);
			
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
 }
 
// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insertStatement  
	
	returns [JFXExpression value]	// All steatemetns return a JFX expression tree
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
}
	: INSERT elem=expression	{ errNodes.append($elem.value); }
	
		(
			  INTO eseq=expression
			  
			  	{
			  		errNodes.append($eseq.value);
			  		
			  		// Form 1, INTO
			  		//
					$value = F.at(pos($INSERT)).SequenceInsert($eseq.value, $elem.value, null, false);
			  	}
			  	
			| BEFORE isfi=indexedSequenceForInsert
			
				{
					if ($isfi.seq != null) errNodes.append($isfi.seq);
					if ($isfi.idx != null) errNodes.append($isfi.idx);
										
					// Form 2, BEFORE
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, false);
				}
				
			| AFTER isfi=indexedSequenceForInsert
			
				{
					if ($isfi.seq != null) errNodes.append($isfi.seq);
					if ($isfi.idx != null) errNodes.append($isfi.idx);
					
					// Form 3, AFTER
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, true);
				}
		)

		{
			// Tree span
			//
			endPos($value);
		}  
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
 }
 
// ----------------
// Insert seqeunce.
// Parse the syntax for an insert sequence specified by the 
// INSERT BEFORE and INSERT AFTER variants.
//
indexedSequenceForInsert

	returns [JFXExpression seq, JFXExpression idx]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: primaryExpression 			
	
		{
			// Sequence expression
			//
			$seq = $primaryExpression.value;
		}
		
	  LBRACKET expression 
	  
	  	{
	  		// Index expressions
	  		//
	  		$idx = $expression.value;
	  		errNodes.append($expression.value);
	  	}
	  	
	  RBRACKET
	  		
 	;

// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Only index can throw us out here really
	// Create the erroneous node
	//
	$idx = F.at(rPos).Erroneous(errNodes.elems);
	endPos($idx);
 }
 
// -----------------	
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
deleteStatement  

	returns [JFXExpression value]	// Delete returns a JFX Expression tree
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: DELETE e1=expression
	
		{
			errNodes.append($e1.value);
		}

	   ( 
	   		  (FROM)=>FROM e2=expression
	   		  	
	   		  	{
	   		  		$value = F.at(pos($DELETE)).SequenceDelete($e2.value,$e1.value);
	   		  	}
	   		  	
	   		| /* indexed and whole cases */
	   		
	   			{
	   				$value = F.at(pos($DELETE)).SequenceDelete($e1.value);
	   			}
	   			
	   )
	   
	   {
	   		// Tree span
	   		//
	   		endPos($value);
	   }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
 }
 
// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
returnStatement

	returns [JFXExpression value]	// RETURN returns a JFX Expression tree
@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: RETURN 
		
		(
			  expression		
			  
			  	{	
			  		$value = F.at(pos($RETURN)).Return($expression.value);	
			  	}
			  	
			| (possiblyOptSemi)=>possiblyOptSemi	// Can't have a SEMI be optional here as we must eitehr consume
													// the next expression or not.
				{	
					$value = F.at(pos($RETURN)).Return(null);				
				}
				
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
//
tryStatement

	returns [JFXExpression value]	// returns a JFX Expression tree
	
@init
{
	// AST for any catch clauses
	//
	ListBuffer<JFXCatch> caught = ListBuffer.lb();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

	// Start of rule for error node production/
	//
	int	rPos	= pos();
	
	// Count the number of finally clauses
	//
	int	finallyCount = 0;
	
	// Count the number of catch clauses
	//
	int catchCount = 0;
	
	// Only error out on finally/catch out of sequence fo rthe first out
	// of sequence error.
	//
	boolean showSequenceErr = true;
	
	// Record start postion of finally clauses for correct error
	// position.
	//
	int fPos = 0;
	
}
	: TRY block 			
			{ 
				errNodes.append($block.value); 
			}
		( 
		
			// Predicate is neccessary to disambiguate associated catch and finally
			// blocks from orphaned blocks handled in alts 2 and 3 of the main rule
			//
			(CATCH|FINALLY)=>
		
			(
				  { 
					// Record input positoni in case of error.
					//
					fPos = pos();
				  }
		 	  		f1=finallyClause	
		 	  		
		 	  		{ 
		 	  			errNodes.append($f1.value); 
		 	  		
		 	  			if	(finallyCount != 0) {
		 	  		
		 	  				// Can only have one finally clause, so log an error
		 	  				//
			   				log.error(fPos, MsgSym.MESSAGE_JAVAFX_FINALLY_TOOMANY);
		 	  			}
		 	  			finallyCount++; 
		 	  		}
		 	  
	   			| (
	   				catchClause
	   				
	   				{
	   					if	(finallyCount != 0 && showSequenceErr)	{
	   					
	   						// We came across a catchClause, but we have already seen the finally clause.
	   						// We only error out the first time we detect the error so we don't throw
	   						// the same error for each catch clause that is out of order.
	   						//
	   						showSequenceErr = false;
				   			log.error(fPos, MsgSym.MESSAGE_JAVAFX_FINALLY_NOTLAST);
	   					}
	   					// Accumulate the catch clauses
	   					//
	   					caught.append($catchClause.value);
	   					errNodes.append($catchClause.value);
	   					catchCount++;
	   				}
	   		  	  )					
	   		) 
	   	)*
	   	
	   	{
	   		// Now - check for malformed constructs and make the AST node or the
	   		// erroneous node as appropriate
	   		//
	   		if	(catchCount == 0 && finallyCount == 0)
	   		{
	   			// We must see at least one catch or one finally, or we can't build
	   			// the AST
	   			//
	   			log.error(pos($TRY), MsgSym.MESSAGE_JAVAFX_BAD_TRY);
	   			$value = F.at(pos($TRY)).Erroneous(errNodes.elems);
	   			endPos($value);
	   			
	   		} else {
	   		
		   		// Build the AST
		   		//
		   		$value = F.at(pos($TRY)).Try($block.value, caught.toList(), $f1.value);
	   		
	   			// Tree span
	   			//
	   			endPos($value);
	   		}
	   	}
	
		// Erroneouds constructs
		//
	|	fe=finallyClause
	
			{
				// Dangling finally clause belongs to no try block
				//
				errNodes.append($fe.value);
	   			$value = F.at(rPos).Erroneous(errNodes.elems);
	   			endPos($value);
	   			log.error(rPos, MsgSym.MESSAGE_JAVAFX_ORPHANED_FINALLY);
			}
			
	|	ce=catchClause

			{
				// Dangling catch clause belongs to no try block
				//
				errNodes.append($ce.value);
	   			$value = F.at(rPos).Erroneous(errNodes.elems);
	   			endPos($value);
	   			log.error(rPos, MsgSym.MESSAGE_JAVAFX_ORPHANED_CATCH);
			}

	;
	
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
 }
 
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//

finallyClause

	returns [JFXBlock value] // returns a JFX Expression tree

@init
{
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: FINALLY block
	
		{
			$value = $block.value;
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// The only thing we can have happen is that there was no block, so there
	// can be no nodes to catch
	//
	$value = F.at(rPos).ErroneousBlock();
	endPos($value);
}
 
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause

	returns [JFXCatch value]	// Catch has its own JFX tree node type

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}
	: CATCH 
		LPAREN 
			formalParameter 
				{
					errNodes.append($formalParameter.var);
				}
		RPAREN 
			block
	
		{
			$value = F.at(pos($CATCH)).Catch($formalParameter.var, $block.value);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Errnoeous node
	//
	$value = F.at(rPos).ErroneousCatch(errNodes.elems);
	endPos($value);
}
 
// ---------------------
// Boundable expression.
// Used to parse expressions that can be bound to a variable.
//
boundExpression 

	returns [JavafxBindStatus status, JFXExpression value] 	// We nede to return a status flag to say how and if the
															// expression is bound, and the AST for the expression itself.

@init 
{ 
	boolean isBidirectional	= false; 	// Signals presence of INVERSE

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of rule for error node production/
	//
	int	rPos	= pos();
}

	: BIND e1=expression 
	
		{
			errNodes.append($e1.value);	// For erroneous node
		}
	
			(
				(WITH)=>WITH 
				
					// Future syntax: (expression AS)?
				
					 INVERSE
				
				{
					// Update status
					//
					isBidirectional = true;
				}
			)?
			
			{
				// Set up the bound expression
				//
				$value	= $e1.value;
				
				// Update the status
				//
				$status	= isBidirectional? BIDIBIND : UNIDIBIND;
			}
	
	| e2=expression
	
		{
			// Unbound expression AST
			//
			$value 	= $e2.value;
			
			// Update the status
			//
			$status	= UNBOUND;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
   	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Signal as if unbound
	//
	$status	= UNBOUND;
	
	// Create the erroneous node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	
	// We discovered nothing in the list and so the endpos
	// is the same as the rule start position.
	endPos($value);
}

// -----------
// expression.
// General expression parse and AST build.
//
expression

	returns [JFXExpression value]	// Expression has its own dedicated JFX tree node type
 
 @init
 {
 	// Used for error reporting
 	//
 	int rPos = pos();
 }
	: ifExpression

		{
			$value = $ifExpression.value;
		}
				
	| forExpression   	

		{
			$value = $forExpression.value;
		}
		
	| newExpression

		{
			$value = $newExpression.value;
		}
		
	| assignmentExpression

		{
			$value = $assignmentExpression.value;
		}
		
	| // Expressions can parse varaible declarations at all levels
	  // both local, script, class etc. It is up to the attribution phase
	  // to throw out modifiers where they are not allowed such as on 
	  // local variable declarations.
	  //
	  m=modifiers 
	   	
	  	variableDeclaration [$m.mods, $m.pos]
	
		{
			$value = $variableDeclaration.value;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// An error at this point in the expression tree means we
	// will not have anythig to accumulate for an erroneous node
	// so we span from the start to the recovery point.
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
}

// ------------------------
// FOR statement/expression
//
forExpression

	returns [JFXExpression value]	// All statements are expressions

@init
{
	// In clause accumulator
	//
	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

 	// Used for error reporting
 	//
 	int rPos = pos();

}
	: FOR 
		LPAREN 
		
			i1=inClause			
				{  
					clauses.append($i1.value); 
					errNodes.append($i1.value); // For erroneous node
				}
			(COMMA i2=inClause	
					{  
						clauses.append($i2.value); 
						errNodes.append($i2.value); // For erroneous node
					} 
			)* 
			
		RPAREN 
		
		statement
				
			{
				errNodes.append($statement.value); 
		 		$value = F.at(pos($FOR)).ForExpression(clauses.toList(), $statement.value);
			}
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Though we seemed to start out down a FOR statement, there was an error
	// that we could not recover from by simple insert/delete token, so we
	// span the erroneous trees
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause

	returns [JFXForExpressionInClause value]	// Dedicated AST tree node

@init
{
	// Assume no WHERE expression
	//
	JFXExpression weVal = null;
	
	// Start postion
	//
	int sPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: formalParameter 	{ errNodes.append($formalParameter.var); 	}
		IN 
		se=expression 	{ errNodes.append($se.value);				}
	
		(
			  WHERE we=expression	{ weVal = $we.value; errNodes.append($we.value); }
			|
		)
		
		{
			$value = F.at(sPos).InClause($formalParameter.var, $se.value, weVal);
			endPos($value); 
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// But we create an Erroneous version of the node
	//
	$value = F.at(sPos).ErroneousInClause(errNodes.elems);
	endPos($value);
}

// -----------------------
// If Then Else expression
//
ifExpression 

	returns [JFXExpression value]	// The expression tree that represents the If expression
	
@init
{
	// Statement or block expression
	//
	JFXExpression sVal = null;
	
	// Else expression (if present)
	//
	JFXExpression eVal = null;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
 	// Used for error reporting
 	//
 	int rPos = pos();

}
	: IF LPAREN 
	
			econd=expression  	{ errNodes.append($econd.value);	}
			
		RPAREN 
	

		THEN?  statement 			{ sVal = $statement.value;	errNodes.append(sVal);	}
			
			(
				(ELSE)=>elseClause	{ eVal = $elseClause.value;	errNodes.append(eVal);	}
			)?
			
		{
			// The IF AST
			//
			$value = F.at(pos($IF)).Conditional($econd.value, sVal, eVal);
			
			// Tree span
			//
			endPos($value);
			
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// But we create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -----------
// Else clause
// Parse the else expression of an if statement
//
elseClause

	returns [JFXExpression value]	// The expression tree that represents the Else expression
@init
{
	// Used for error productiions
	//
	int	rPos = pos();
}
	: ELSE 
		(
			statement			{ $value = $statement.value; 	}
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// We can only get an error here if we had an ELSE clause but
	// the statement was missing or we could not reach it for too much 
	// junk, so nothing to put in the errornode
	//
	$value = F.at(rPos).Erroneous();
	endPos($value);
}	

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: lhs=assignmentOpExpression 
			{
				errNodes.append($lhs.value);	// For error production
			}
		(     
			  (EQ)=> EQ rhs=expression
			  
			  	{
			  		// This is actually an assign
			  		//
			  		$value = F.at(rPos).Assign($lhs.value, $rhs.value);
			  		
			  		// Tree span
			  		//
			  		endPos($value);
			  	}
			  	
			|	// Just an expression without an assignment
				//
				{
					$value = $lhs.value;
				}
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

assignmentOpExpression

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	: lhs=andExpression			{ errNodes.append($lhs.value); }		
	  
		(     assignOp rhs=expression
		
				{
					// AST for assignement
					//
					$value = F.at(rPos).Assignop($assignOp.op, $lhs.value, $rhs.value);
				}
				
           	| SUCHTHAT 
           		such=andExpression { errNodes.append($such.value); }
           	
           			(
           				TWEEN i=andExpression
           			)?
           	
           		{
           			// AST FOR Interpolation
           			//
           			$value = F.at(rPos).InterpolateValue($lhs.value, $such.value, $i.value);
           		}
           	
	   		|	{ 
	   				// AST for expressions
	   				//
	   				$value = $lhs.value; 
	   			}	
	   )
	   
	   {
	   		// AST Span
	   		//
	   		endPos($value);
	   }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
}

// -----------------
// Assign operators
// All the operators that involve assignments.
//	
assignOp

	returns	[JavafxTag op]	// Returns the operation token that we find
	
	: PLUSEQ		{ $op = JavafxTag.PLUS_ASG; 			}
	| SUBEQ			{ $op = JavafxTag.MINUS_ASG;			}
	| STAREQ		{ $op = JavafxTag.MUL_ASG;              }
	| SLASHEQ		{ $op = JavafxTag.DIV_ASG;				}
	| PERCENTEQ
		{ 
			$op = JavafxTag.MOD_ASG;
			log.warning(pos($PERCENTEQ), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The operator \%= will not be supported in the JavaFX 1.0 release" );
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// -------------
// AND opertator
// LL(k) AND precedence
//
andExpression

	returns [JFXExpression value] 	// Expression tree for AND
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}

	:	e1=orExpression
			
			{
				$value = $e1.value;
				errNodes.append($e1.value);
			}
	  		( 
	  			AND e2=orExpression
	  			
	  			{
	  				$value = F.at(rPos).Binary(JavafxTag.AND, $value, $e2.value);
	  				endPos($value);
	  			}
	  		)*
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -----------
// OR operator
// LL(k) OR precedence
//
orExpression

	returns [JFXExpression value] 	// Expression tree for OR
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: e1=typeExpression

		{
			$value = $e1.value;
			errNodes.append($e1.value);
		}
	  	( 
	  		OR e2=typeExpression 
	  		
	  		{
	  			$value = F.at(rPos).Binary(JavafxTag.OR, $value, $e2.value);
	  			endPos($value);
	  		}
	  	)*
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: relationalExpression		{ errNodes.append($relationalExpression.value); }

		(
			  INSTANCEOF itn=type
			
				{
					$value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
					endPos($value);
				}
				
			| AS atn=type
			
				{
					$value = F.at($relationalExpression.value.pos).TypeCast($atn.rtype, $relationalExpression.value);
					endPos($value);
				}
			
			| 	{
					$value = $relationalExpression.value;
				}
	   )
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// -----------
// Relationals
// LL(k) precedence
//	
relationalExpression  

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: a1=additiveExpression	{ $value = $a1.value; errNodes.append($a1.value); }
		(
			
			relOps   a2=additiveExpression
			  	
			  	{
			  		$value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
			  		endPos($value);
			  	}
		)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

	returns [JavafxTag relOp]	// Returns the JFX operator type
	
	: LTGT
		{ 
			$relOp = JavafxTag.NE;
			log.warning(pos($LTGT), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The not-equal operator <> will be replaced by !=" );
		}	
			  		
	| NOTEQ  { $relOp = JavafxTag.NE;	}
	| EQEQ   { $relOp = JavafxTag.EQ;	}
	| LTEQ   { $relOp = JavafxTag.LE;	}
	| GTEQ   { $relOp = JavafxTag.GE;	}
	| LT     { $relOp = JavafxTag.LT;	}
	| GT     { $relOp = JavafxTag.GT;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//	
additiveExpression 

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
	: m1=multiplicativeExpression	
		{ 
			$value = $m1.value; 
			errNodes.append($m1.value);
		}
		(
		    (arithOps)=>
		    	
		    	arithOps   m2=multiplicativeExpression

			{
				$value = F.at(rPos).Binary($arithOps.arithOp , $value, $m2.value);
				endPos($value);
			}
		)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// --------------------
// Arithmetic operators
//
arithOps

	returns [JavafxTag arithOp]	// Returns the JFX operator type
	
	: PLUS		{ $arithOp = JavafxTag.PLUS; 	}
	| SUB		{ $arithOp = JavafxTag.MINUS;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
}

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//	
multiplicativeExpression

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
	: u1=unaryExpression	{ $value = $u1.value; errNodes.append($u1.value); }
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			multOps u2=unaryExpression
				
				{
					$value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
					endPos($value);
				}
	   )* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

	returns [JavafxTag multOp]	// Returns the JFX operator type
	
	: STAR    	{ $multOp = JavafxTag.MUL;	}
	| SLASH   	{ $multOp = JavafxTag.DIV;	}
	| PERCENT 	
			
		{
			$multOp = JavafxTag.MOD;
			log.warning(pos($PERCENT), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The remainder operator \% will be replaced by mod" );
		}	
             
	| MOD		{ $multOp = JavafxTag.MOD;	}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

}

// -----------------	
// Unary expressions
// LL(k) Precedence
//
unaryExpression

	returns [JFXExpression value] 	// Expression tree for unary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: se=suffixedExpression

		{
			errNodes.append($se.value);
			$value = $se.value;
		}
		
	| INDEXOF		id=identifier
	
		{ 	
			$value = F.at(rPos).Indexof($id.value);
			endPos($value);
		}
		
	| unaryOps     	e=unaryExpression

		{
			$value = F.at(rPos).Unary($unaryOps.unOp, $e.value);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps

	returns [JavafxTag unOp]	// Returns the JFX operator type
	
	: SUB			{ $unOp = JavafxTag.NEG; }
	| NOT			{ $unOp = JavafxTag.NOT; }
	| SIZEOF		{ $unOp = JavafxTag.SIZEOF; }
	| PLUSPLUS		{ $unOp = JavafxTag.PREINC; }
	| SUBSUB		{ $unOp = JavafxTag.PREDEC; }
	| REVERSE		{ $unOp = JavafxTag.REVERSE; }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: pe=postfixExpression	{ errNodes.append($pe.value); }
		( 
			  { input.LT(-1).getType() != RBRACE }?=> PLUSPLUS
			  
			  	{
			  		$value = F.at(rPos).Unary(JavafxTag.POSTINC, $pe.value);
			  		endPos($value);
			  	}
			  	
			| { input.LT(-1).getType() != RBRACE }?=> SUBSUB
			
				{
					$value = F.at(rPos).Unary(JavafxTag.POSTDEC, $pe.value);
					endPos($value);
				}
				
			| { $value = $pe.value; }
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ------------------------
// Postfix-able expressions
// LL(k) precedence
//
postfixExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	int	sPos = rPos;

	// Position for pipe epxression
	//
	int pPos;
	
	// Indicates if we had the LT token
	//
	int clusiveType = SequenceSliceTree.END_INCLUSIVE;
	
	// Last element of sequence (if present)
	//
	JFXExpression	lastExpr = null;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: pe=primaryExpression	{ $value = $pe.value; errNodes.append($pe.value); }
	
		( 
			  DOT 
				( 
					  n1=name	// This does not seem right - wrong precedence for x.func().y ?
					  
					  {
							$value = F.at(pos($DOT)).Select($value, $n1.value);
							endPos($value);
							errNodes.append($value);
					  }
					  
					//TODO:		 | CLASS 
	         	)

			| (LPAREN)=>LPAREN 

					expressionList 
			
				{
					$value = F.at(sPos).Apply(null, $value, $expressionList.args.toList());
					errNodes.append($value);
					
				}
				RPAREN
				{
					endPos($value);
				}
				
			| (LBRACKET)=>l1=LBRACKET
			
				{
					// INit our flags
					//
					clusiveType = SequenceSliceTree.END_INCLUSIVE;
					lastExpr 	= null;
				}
	
				(
					  n2=name 
					  	{
					  		// Build up new node in case of error
							//
							JFXExpression part = F.at($n2.pos).Ident($n2.value);
							errNodes.append(part);
							endPos(part);
						}
					  
					  PIPE 
					  
					  { rPos = pos(); }	// Use expression as position for AST
					  
					  e1=expression r3=RBRACKET
					  
					  {
					  	errNodes.append($e1.value);
					  	
					  	// Build a list of clauses as AST builder expects this
					  	//
					  	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();
                  		
                  		// Build a var reference
                  		//
                  		JFXVar var = F.at($n2.pos).Param($n2.value, F.TypeUnknown());
                  		
                  		// Set up the in clause
                  		//
	          			clauses.append(F.at(pos($l1)).InClause(var, $value, $e1.value));
	          			
	          			// Predicate needs identifier AST
	          			//
                  		$value = F.at(sPos).Predicate(clauses.toList(), F.at($n2.pos).Ident($n2.value));
                  		
                  		// Tree span
                  		//
                  		endPos($value, pos($r3));
					  }
					  
					| first=expression	{ errNodes.append($first.value); }
                            
						(
							  r1=RBRACKET
							  
							  	{
							  		// Use left bracket as AST start pos
							  		//
							  		$value = F.at(sPos).SequenceIndexed($value, $first.value);
							  		
							  		// Use right bracket as AST end pos
							  		//
							  		endPos($value);
							  	}
							  	
	                    	| DOTDOT 
	                    		(
									  (LT { clusiveType = SequenceSliceTree.END_EXCLUSIVE; } )? 
									  	(
									  		last=expression
									  		{
									  			errNodes.append($last.value);
									  			lastExpr = $last.value;
									  		}
									  	)?
									  	
								)
								
	                      	  r2=RBRACKET
	                      	  
	                      	  {
	                      	  	// If we have LT, then this is an exclusive slice
	                      	  	//
	                      	  	$value = F.at(sPos).SequenceSlice
	                      	  									(
	                      	  										$value,
	                      	  										$first.value,
	                      	  										lastExpr,
	                                                            	clusiveType
	                                                            );
								endPos($value);
	                      	  }
                    	)
             	)
	   	)* 
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//	
primaryExpression  

	returns [JFXExpression value] 	// Expression tree for primary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Use to build a list of objectLiteral parts.
	//
	ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb();

    // Used to construct time literal expression
    //
    JFXExpression sVal = null;

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();	
}
	: qualname
		{
			$value = $qualname.value;
			errNodes.append($value);
		}
		(
			(LBRACE)=>LBRACE  
			  	
					o1=objectLiteral
						{
							// Accumulate in case of error
							//
							for (JFXTree t : $o1.parts) {
								errNodes.append(t);
							}
						}
						
			RBRACE
	              
				{
					// AST
					//
					$value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
					
					// Tree span
					//
					endPos($value);
				}
			|
		)

	| THIS

		{
			$value = F.at(pos($THIS)).Ident(names._this);
			endPos($value);
		}
		
	| SUPER
	
		{
			$value = F.at(pos($SUPER)).Ident(names._super);
			endPos($value);
		}
		
	| se=stringExpression

		{
			$value = $se.value;
		}
		
	| be=bracketExpression
	
		{
			$value = $be.value;
		}
		
	| block
	
		{
			$value = $block.value;
		}
		
	| literal
	
		{
			$value = $literal.value;
		}
		
	| fe=functionExpression
	
		{
			$value = $fe.value;
		}
	
	| LPAREN e=expression RPAREN
	
		{
			$value = $e.value;
		}
		
	| AT 
		LPAREN 
			tv=timeValue
            {
                sVal = $tv.valNode;
                errNodes.append($tv.valNode);
            }
		RPAREN 
		LBRACE 
			k=keyFrameLiteralPart
			
				{
					// Accumulate in case of error
					//
					for ( JFXTree t : $k.exprs) {					
						errNodes.append(t);
					}
					
				} 
		RBRACE
		
		{
			$value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an Erroneous version of the node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ------------
// Frame values
//  
keyFrameLiteralPart

	returns [ListBuffer<JFXExpression> exprs = new ListBuffer<JFXExpression>(); ]	// Gathers a list of expressions representing frame values
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
}
	: k1=expression 			{ exprs.append($k1.value);	}
	
		(SEMI SEMI* // This is a trick to force error recovery, otherwise SEMI+ forces an early exit exception
		
			k2=expression		{ exprs.append($k2.value);	}
		)* SEMI*
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an Erroneous version of the node
	//
	JFXErroneous errNode = F.at(rPos).Erroneous(exprs.elems);
	endPos(errNode);	
	exprs = new ListBuffer<JFXExpression>();
	exprs.append(errNode);
}

// -------------------
// Anonymous functions
//
functionExpression

	returns [JFXExpression value] 	// Expression tree for anonymous function
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
	
}
	: FUNCTION 
	
		formalParameters 	
			{ 
				// Accumulate in case of error
				//
				for	( JFXTree t : $formalParameters.params) {
					errNodes.append(t);
				}
			}
			
		typeReference 	{ errNodes.append($typeReference.rtype); }
		block			{ errNodes.append($block.value); }
	
		{
			// JFX AST
			//
			$value = F.at(pos($FUNCTION)).FunctionValue
								(
									$typeReference.rtype, 
									$formalParameters.params.toList(),
									$block.value
								);
								
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS vode
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
}

// ---
// NEW
//
newExpression

	returns [JFXExpression value] 	// Expression tree for new expression

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
}
	: NEW 
		typeName 				{ errNodes.append($typeName.value); }
		expressionListOpt
	
		{
			// If we got ehre, there wil lbe no errors for expressionListOpt, and if 
			// did not, then the expressionListOpt will not be built, so we do not accumulate
			// its nodes for error.
			//
			$value = F.at(pos($NEW)).InstanciateNew($typeName.value, $expressionListOpt.args.toList());
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an ERRONEOUS vode
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ---------------
// Object literals
//
objectLiteral

	returns [ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb()]	// Gather a list of all the object literal insitalizations

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
}
	:   (COMMA|SEMI)*	// Separators are optional and just syntactic sugar
	
		(		
			(
				oli=objectLiteralPart 
			
				{
					parts.append($oli.value);
					errNodes.append($oli.value);	// Accumulte in case of error
				}
			)
			
			(COMMA|SEMI)*	// Separators are optional and just syntactic sugar
			
			
		)*		// May be no elements in the object literal, just {}
	
				
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS vode
	//
	JFXErroneous errNode = F.at(rPos).Erroneous(errNodes.elems);
	endPos(errNode);
	
	// Reset the return list
	//
	$parts = ListBuffer.<JFXTree>lb();
	
	// Add the error node
	//
	$parts.append(errNode);
	
}

// Individual components of an object literal
//
objectLiteralPart

	returns [JFXTree value] 	// Expression tree for object literal elements

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Rule pos in case of error
	//
	int	rPos = pos();
	
}
	: modifiers
		(
			  variableDeclaration    [$modifiers.mods, $modifiers.pos]
			  
			  	{
			  		$value = $variableDeclaration.value;
			  		errNodes.append($value);
			  	}
			  	
			| functionDefinition	 [$modifiers.mods, $modifiers.pos]
			
				{
					$value = $functionDefinition.value;
					errNodes.append($value);
				}
		)
		
	| oli=objectLiteralInit
		
		{
			$value = $oli.value;
			errNodes.append($oli.value);
		}
    ;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// --------------------------     	
// Object literal initializer
//	
objectLiteralInit

	returns [JFXTree value]		// Construct the AST for a name value pair
	
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Indicates that something went wrong with the parse
	//
	boolean	inError = false;
}
	: n1=name
		{
			if	($n1.inError) {
				
				// The rule caused an identifier to be made up
				//
				inError = true;
			}
							
			// Build up new node in case of error
			//
			JFXExpression part = F.at($n1.pos).Ident($n1.value);
			errNodes.append(part);
			endPos(part);
		} 
		COLON  
		boundExpression
	
		{
			if	(inError) {
			
				// Missing name, so throw this into error state
				//
				errNodes.append($boundExpression.value);
				
				// Create an ERRONEOUS node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				
			} else {
			
				// AST
				//
				$value = F.at($n1.pos).ObjectLiteralPart
										(
											$n1.value,
									 		$boundExpression.value, 
									 		$boundExpression.status
									 	);
			}
							 	
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	

}

// -------	
// Strings
// JavaFX string expresoins are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time
//    over which the script author then has unambiguous control over
//    leading spaces, can explictly insert new lines, and can comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leades to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Individual compound parts cannot be translated individually;
//
stringExpression 

	returns [JFXExpression value] 	// Expression tree for stringExpressions

scope {
	// Indicates that the expression went into a parse error state
	// somehere and we should not try to resolve it
	//
	boolean inError;
}

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> strexp = new ListBuffer<JFXExpression>();
	
	// Translation key, if any, for the literal string
	//
    String translationKey = null;
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start in non error state
	//
	$stringExpression::inError = false;
	
}

	: (
		  (
			// Translation key is optional
		  	//
		  	TRANSLATION_KEY	{ translationKey = $TRANSLATION_KEY.text; } 
		  )?
	
			// We must find at least one compund element to the string
			//
			strCompoundElement [ strexp ]
			
			(
				// After the first element, there may be any number of additional
				// elements, including zero. We must force the parser to take
				// the righteous path for syntactically correct constructs, then
				// error out semantically on anything else.
				//
				   (STRING_LITERAL|QUOTE_LBRACE_STRING_LITERAL) =>strCompoundElement [ strexp ]
			
			)*
	  )
	  
		{
			if	($stringExpression::inError) {
			
				// Some part of this parse caused an error, so the whole lot just
				// accumulates into an error node.
				//
			
				// Accumulate whatever pieces we discovered
				//
				for	(JFXTree t : strexp) {
	
					errNodes.append(t);
				}
	
				// Create an ERRONEOUS node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				endPos($value);	
	
			} else {
			
	  			// AST for string expression
	  			// If we accumulated just a single entry then by definition
	  			// we accumulated just a simple string literal, but if there
	  			// is more than one entry, or there is a translation key,
	  			// then we have a string expression
	  			//
	  			if	(strexp.size() > 1 || translationKey != null)
				{
					// Complex expression
					//
		  			$value = F.at(rPos).StringExpression(strexp.toList(), translationKey);
	
					// Tree span
	  				//
	  				endPos($value);
	
	  			}
		  		else
		  		{
		  			// This is an individual string literal, and is already endPos'ed
		  			//
		  			$value  = strexp.toList().get(0);
				}
			}  			
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Accumulate whatever pieces we discovered
	//
	for	(JFXTree t : strexp) {
	
		errNodes.append(t);
	}
	
	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
	
}

// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<JFXExpression> strexp ]
	
	: stringLiteral	[ strexp ]	  		
	| qlsl 			[ strexp ]
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// ---------------
// String literals
// We may have multiple string literals following each
// other, which we auto concatentate here at compile time
//
//
stringLiteral [ ListBuffer<JFXExpression> strexp ]


@init
{
	// Record position of invalid expression used in compile time
	// string compounding.
	//
	int ePos;
	
	// Used to accumulate multiple string literals
	//
	StringBuffer sbLit = new StringBuffer();
	
	// The string litereal we will created
	//
	JFXExpression sVal = null;

}
	: s1=STRING_LITERAL 
	
		{
			// Accumulate the literal
			//
			sbLit.append($s1.text);
		}
	
		(
			(STRING_LITERAL)=> s2=STRING_LITERAL
			
			{
				// Accumulate the literal
				//
				sbLit.append($s2.text);
			}
		)*
		
		{

			// Here, one of the following conditions prevails
			//
			//  i)  We have as yet encountered no components of the compound
			//      string and so we can assume for the moment that the literal
			//      string elements we have accumulated so far will remain as
			//	    a simple string literal, and so just add the literal we
			//	    make as one element.
			// ii)  There has already been some sort of compound expression
			//      in which case there will be more than 0 elements currently in
			//      the compound element list. The list will always be left with
			//      the trailing part of the expression string as the last element
			//      of the list as it is built of "leading{\%format expr}trailing".
			//      So, we can remove the last entry, append this newly accumulated
			//      string literal to it, and move on.
			//
			if	( $stringExpression::inError || strexp.size() == 0)
			{
			
				// Now we create the actual string literal
				//
				sVal = F.at(pos($s1)).Literal(TypeTags.CLASS, sbLit.toString());
			
				// Add to list
				//
				strexp.append(sVal);

				// Tree span
				//
				endPos(sVal);
			
			}
			else
			{
				// Already had the first expression, replace the traling part of the
				// last expression with a concatenation of it and this newly found
				// string.
				//
				JFXLiteral trailer = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
				
				// Now, append the string we have to the prior trailing part
				// 
				sbLit.insert(0, (String)(trailer.getValue()));
				
				// Replace the original value
				//
				trailer.value = sbLit.toString();
				
			}

		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;
	
}
	
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<JFXExpression> strexp]

	: 	ql=QUOTE_LBRACE_STRING_LITERAL	
	
			{
				if	($stringExpression::inError) {
				
					// Add the leadin string
					//
					JFXLiteral leader = F.at(pos($ql)).Literal
											(	TypeTags.CLASS,
											 	$ql.text
											);
					endPos(leader);
	
					// Add it in to the list
					//
					strexp.append(leader);
							
				} else {
					// Add in the discovered literal value
					//
					// Here, one of the following conditions apply:
					//
					//   i) There are currently no entries in the buffer. The size of strexp
					//      will be 0 in that case and we can process the expression without 
					//      regard to prior values.
					//  ii) There was one or leading string literals (non expressions),
					//      in which case the list buffer size will be 1, representing
					//      the accumulated string literal. In that case we must append
					//	    the leadin string ($ql above) to the existing string and make
					//      it the leadin for this expression.
					// iii) There were prior expressions in the list, in which case, as per
					//      ii) we must merge the last literal in the buffer with ($ql) from
					//      above and make it the leadin string for this expression.
					//      NB: THis can aonly arise from "{expr}" ("STRING")* "{expr}"
					//
					switch	(strexp.size())
					{
						case 0:
				
							// Add the leadin string
							//
							JFXLiteral leader = F.at(pos($ql)).Literal
												(	TypeTags.CLASS,
												 	$ql.text
												);
							endPos(leader);
	
							// Add it in to the list
							//
							strexp.append(leader);
							
							break;	
	
					default:
						
							// Already had a single first literal, or a trailer for an 
							// expression - make it belong to this leader.
							//
							leader = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
					
							// Now, append the string we have to the prior trailing part
							// and replace the original value
							//
							leader.value = (String)(leader.getValue()) + $ql.text;
							break;
					}
				}
			}
			
		// Optional string format
		//
	    stringFormat	[strexp]
	    
	    // An expression to evaluate at runtime
	    // 
	  	e2=expression 					{ strexp.append($e2.value);	}
	  
	  	// Any number of inner elements
	  	//
	  	( stringExpressionInner [strexp]  )*   
	  
	  	// The last component of the {} enclosing string literal
	  	//
	  	qr=RBRACE_QUOTE_STRING_LITERAL
	  
	  		{
	  			// Add in the discovered literal
	  			//
	  			JFXLiteral trailer = F.at(pos($qr)).Literal
											(	TypeTags.CLASS,
											 	$qr.text
											);
				endPos(trailer);
				
				// Add to the list
				//
				strexp.append(trailer);	
			}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<JFXExpression> strexp]

	: rlsl=RBRACE_LBRACE_STRING_LITERAL 
	
		{
			// Construct a new literal for the leading literal
			//
			JFXExpression rb = F.at(pos($rlsl)).Literal(TypeTags.CLASS, $rlsl.text);
			
			// Record the span
			//
			endPos(rb);
			
			// Add the literal to the list
			//
			strexp.append(rb);
			
		}
		
		// Deal with the string format
		//
		stringFormat[strexp] 
		
		// Expression to evaluate at runtime
		//
		expression
		
		{
			strexp.append($expression.value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}

// --------------------
// Format specification
// Optional format specifier in standard Java form
//
stringFormat [ ListBuffer<JFXExpression> strexp]

@init
{
	// The value to add in to the mix
	//
	JFXExpression value;
	
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: fs=FORMAT_STRING_LITERAL
	
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, $fs.text);
			endPos(value);
			strexp.append(value);
		}
		
	| // no format
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, "");
			endPos(value);
			strexp.append(value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Flag we are in the error state
	//
	$stringExpression::inError = true;	
}
	
// ---------------------------
// Sequence
// Which is a [] enclosed expression list
//
bracketExpression

	returns [JFXExpression value] 	// Expression tree for stringExpressions

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> seqexp = new ListBuffer<JFXExpression>();
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Optional step expression
	//
	JFXExpression	stepEx = null;
	
	// Optional LT qualifier
	//
	boolean 	haveLT	= false;
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: LBRACKET   
	
		( 	e1=expression
				{
					seqexp.append($e1.value);
					errNodes.append($e1.value);
				}
		     	(
		     		COMMA*
		     		  (
		     			
		     				(
		     					e2=expression
		     						{
		     							seqexp.append($e2.value);
		     							errNodes.append($e2.value);
		     						}
		     				)
		     				COMMA*
		     		  )*
	                    
	                    {
	                    	// Explicit sequence detected
	                    	//
	                    	$value = F.at(rPos).ExplicitSequence(seqexp.toList());
	                    }
	                    
		     		| DOTDOT
		     			(LT { haveLT = true; })? 
		     			
		     			dd=expression	{ errNodes.append($dd.value); }
		     			
		     	    	( 
		     	    		STEP st=expression 
		     	    				{ 
		     	    					stepEx = $st.value; 
		     	    					errNodes.append($st.value); 
		     	    				} 
		     	    	)?
		     	    	
		     	    	{
		     	    		$value = F.at(rPos).RangeSequence($e1.value, $dd.value, stepEx, haveLT);
		     	    	}
		     	)
		     	
		     |  // Empty sequence 
		     	{
		     		 $value = F.at(rPos).EmptySequence();
		     	}
	    )
	  RBRACKET
	  {
	  	endPos($value);
	  }
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);

	// Create an ERRONEOUS node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);	
}

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList

	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: e1=expression
		
		{
			args.append		($e1.value);
			errNodes.append	($e1.value);
		}
		
		(
			COMMA 	(
						e2=expression
						
						{
							args.append		($e2.value);
							errNodes.append	($e2.value);
						}
					)?
		)*
	|
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create an ERRONEOUS node
	//
	JFXErroneous errNode = F.at(rPos).Erroneous(args.elems);
	endPos(errNode);
	args = new ListBuffer<JFXExpression>();
	args.append(errNode);
	
}

// ------------------------
// Optional expression list
// For the moment this is only used by New....
//
expressionListOpt
	
	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up

	: (LPAREN)=>LPAREN expressionList
		{
			$args = $expressionList.args;
		}
	   RPAREN

	|	// Was not present
	;

// -----
// Types
//
type

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: typeName cardinality
	
		{
			$rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
			endPos($rtype);
		}
		
	| typeFunction	{ $rtype = $typeFunction.rtype; }
	| typeStar		{ $rtype = $typeStar.rtype;		}
	;

// Catch an error when looking for a type. The only error we can
// have is that there was nothing that predict any of the alts, 
// so we create an error node for placing in the AST
//
catch [RecognitionException re] {
  
  	// First, lets report the error as the user needs to know about it
  	//
    reportError(re);

	// Perform custom resync operation
	//
	rtype =     resyncType(rPos, re);

 }

typeFunction

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();

	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: FUNCTION 
 		LPAREN 
 			typeArgList
		RPAREN 
		
			ret=typeReference 
          	cardinality	//TODO: this introduces an ambiguity: return cardinality vs type cardinality
          	
		{
			$rtype = F.at(rPos).TypeFunctional($typeArgList.ptypes.toList(), $ret.rtype, $cardinality.ary);
			endPos($rtype);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

typeStar

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();

}
 	: STAR cardinality
 	
 		{
 			$rtype = F.at(rPos).TypeAny($cardinality.ary);
 			endPos($rtype);
 		}
 	;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ----------------------------
// A list of types as arguments
//
typeArgList
 	
 returns [ListBuffer<JFXType> ptypes = ListBuffer.<JFXType>lb(); ]
 
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
 	: t1=typeArg
 	
 		{
 			ptypes.append($t1.rtype);
 		}
 		 
 		(
 			COMMA 
 			(
 				t2=typeArg
 				
 				{
 					ptypes.append($t2.rtype);
 				}
 			)?
 		)*
 	|
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// -------------------------
// Individual typed argument
//
typeArg 

	returns [JFXType rtype]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
 	: (
 		(
 			name	// TODO: Check this, it is currently ignored for AST and does not
 					//       look quite right.
 		)? 
 			COLON
 	  )?
 	  
 	  type
 	
 		{
 			$rtype = $type.rtype;
 		}
 	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeReference

	returns	[JFXType rtype]
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
 	: COLON type
 			  
 		{
 			$rtype = $type.rtype;
 		}
 		
 	| // Untyped element, the AST needs to reflect that
 	
 		{ 
 			$rtype = F.at(rPos).TypeUnknown(); 
 			endPos($rtype);
 		}

 	;
 // Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// To avoid the complications of what to create class wise if
	// we get an error here, we create a dummy unknown type. Because
	// we log the error, we won't perform codegen, but the IDE will
	// have something to work with.
	//
	$rtype = F.at(rPos).TypeUnknown();
	endPos($rtype);
}

// -------------------------
// Array indicator for types
//
cardinality

	returns [TypeTree.Cardinality ary]

@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}
	: (LBRACKET)=>LBRACKET RBRACKET
	
		{
			$ary = TypeTree.Cardinality.ANY;
		}
		
	|	{
			$ary = TypeTree.Cardinality.SINGLETON;
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// ----------
// Named type
// Possibly a generic
//
typeName

	returns [JFXExpression value]

@init
{
	// Accumulate any generic arguments
	//
	ListBuffer<JFXExpression> exprbuff = ListBuffer.<JFXExpression>lb();
	
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
}

	: qualname 		
		(
			  LT ga1=genericArgument 	{ exprbuff.append($ga1.value); }
			  	
			  		(
			  			COMMA
			  				(
			  					ga2=genericArgument
			  				
			  							{ exprbuff.append($ga2.value); }
			  				)?
			  		)* 
			  GT
			  
			  {
			  	// AST for generic
			  	//
			  	// TODO: Implement this?
			  	//
			  	log.error(pos($LT), "javafx.generalerror", "Java generic type declarations are not currently supported");
			  }
			  
			|	// Non generic
				{
					$value = $qualname.value;
				}
		)
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

genericArgument

	returns [JFXExpression value]

@init 
{
	BoundKind 		bk 		= BoundKind.UNBOUND;
	JFXExpression 	texpr 	= null; 
}

	: typeName	{ $value = $typeName.value; }
	
	| QUES 
		(  
			( 
				  EXTENDS 		{ bk = BoundKind.EXTENDS; 	}
		  		| SUPER			{ bk = BoundKind.SUPER; 	}
		  	) 
		 	typeName			{ texpr = $typeName.value; }
		)?
		
		{
			// TODO: NYI - Remove or implement?
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal

	returns [JFXExpression value]
	
@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: 
		(
			 DECIMAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($DECIMAL_LITERAL.text, 10));
				}
				
			| OCTAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($OCTAL_LITERAL.text, 8));
				}
			
			| HEX_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($HEX_LITERAL.text, 16));
				}
				
		    | timeValue
		    
		    	{
		    		$value = $timeValue.valNode;
		    	}
		    	
			| FLOATING_POINT_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.DOUBLE, Double.valueOf($FLOATING_POINT_LITERAL.text));
				}
				
			| TRUE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 1);
				}
				
			| FALSE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 0);
				}
				
			| NULL
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOT, null);
				}
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
}

// -------------------------	
// Qualified (possibly) name
//
qualname

	returns [JFXExpression value, boolean inError]
	
@init
{
	// Used to accumulate a list of anything that we manage to build up in the parse
	// in case of error.
	//
	ListBuffer<JFXTree> errNodes = new ListBuffer<JFXTree>();
	
	// Start of this rule
	//
	int rPos = pos();
	
	// Indicates that despite parsing correctly, we discovered an error here
	// and so this shoudl be erroneous.
	//
	$inError = false;
}
	: (
			n1=name
			{
				if	($n1.inError) {
				
					// The rule caused an identifier to be made up
					//
					$inError = true;
				}
				
				$value = F.at($n1.pos).Ident($n1.value);
				endPos($value);
			
				// Accumulate in case of error
				//
				errNodes.append($value);
			}
			( 
				(DOT)=> DOT 
				
				(
						(IDENTIFIER)=>n2=name
						{
							
							if	($n2.inError) {
				
								// The rule caused an identifier to be made up
								//
								$inError = true;
							}
							
							$value = F.at(pos($DOT)).Select($value, $n2.value);
							endPos($value); 
							
							// Build up new node in case of error
							//
							JFXExpression part = F.at($n2.pos).Ident($n2.value);
							errNodes.append(part);
							endPos(part);
						}
						
					|	{
							$inError = true;		// Signal that this is malformed
							log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_INCOMPLETE_QUAL);
						}
				)
			)*  
		)
		
		// If the rule actually discovered some error, then we do
		// not return the $value as a good qualified name, but as an erroneous node
		//
		{
			if	($inError)	{
			
				// Create the error node
				//
				$value = F.at(rPos).Erroneous(errNodes.elems);
				endPos($value);
			}
		}
	;
// Catch an error. We create an erroneous node for anything that was at the start 
// up to wherever we made sense of the input.
//
catch [RecognitionException re] {
  
  	// First, let's report the error as the user needs to know about it
  	//
    reportError(re);

	// Now we perform standard ANTLR recovery here
	//
	recover(input, re);
	
	// Create the error node
	//
	$value = F.at(rPos).Erroneous(errNodes.elems);
	endPos($value);
	
	$inError = true;
	
}

// ----------
// Time value
// Invoked to pick up a specialized time token and created a special node
// that indicates it was missing, if the parser created it etc.
//
timeValue

	returns [JFXTimeLiteral valNode]
	
	: TIME_LITERAL
	
		{
			// Check to see if error recovery made up this value for us
			//
			if	($TIME_LITERAL instanceof MissingCommonToken) {
			
				$valNode = F.at(pos($TIME_LITERAL)).ErroneousTimeLiteral();
				
			} else {
			
				// Create a real node
				//
				$valNode = F.at(pos($TIME_LITERAL)).TimeLiteral($TIME_LITERAL.text);
			}
            endPos($valNode);
        }
	;
// -----------------------
// ID
// Basic identifier parse
//
identifier

	returns [JFXIdent value, boolean inError]

@init
{
	// Assume the input will be there
	//
	$inError = false;	
}
	: IDENTIFIER
		{
			// The recovery mechanisms will auto generate the IDENTIFIER
			// token, in the case that it can predict that it was just a single
			// token that the programmer forgot to use. Hence we must
			// pick up on that and generate a different node for a Missing
			// identifier.
			//
			if ($IDENTIFIER instanceof MissingCommonToken) {
			
			    $value = F.at(pos($IDENTIFIER)).ErroneousIdent();
			    endPos($value, pos());
			    $inError = true;
			    
			} else {
			
			    Name name = Name.fromString(names, $IDENTIFIER.text);
			    $value = F.at(pos($IDENTIFIER)).Ident(name);
			    endPos($value, pos($IDENTIFIER) + name.length());
			}
		}
	;

// Catch an error when looking for an identifier. The only error we can
// have is that it is not there, so we create an error node for
// placing in the AST
//
catch [RecognitionException re] {
  
  	// First, lets report the error as the user needs to know about it
  	//
    reportError(re);

	// Now create an AST node that represents a missing identifier.
	//
	$value = F.at(pos()).ErroneousIdent();
	
	// The AST has no span as the identifier isn't really there
	//
	endPos($value, pos());
	$inError = true;

 }
 
// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
name 

	returns [Name value, int pos, boolean inError]
	
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = pos($IDENTIFIER); 
			
			if	($IDENTIFIER instanceof MissingCommonToken) {
			
				$inError = true;		// Recognizer manufactured this for us
			
			} else {
			
				$inError = false;		// It was genuinely there
			}
		}				
	;

// Catch an error when looking for a name. The only error we can
// have is that it is not there, so we create an error node for
// placing in the AST
//
catch [RecognitionException re] {
  
  	// First, lets report the error as the user needs to know about it
  	//
    reportError(re);

	// Now create an AST node that represents a missing name, The required entry
	// is of type Name so we use an identifier name that cannot exist in
	// JavaFX, so that IDEs can detect it, but flag it as being a manufactured
	// token to the caller.
	//
	$value 		= Name.fromString(names, "<missing IDENTIFIER>");
	$pos   		= semiPos();
	$inError	= true;
 }
 
// -----------------------
// Process a SEMI colon that is always required, regardless of
// where the contruct is in the script. There are not too many
// of these.
//
requiredSemi 
	: { input.LA(1) != SEMI}?=>
	
	  // If there was no semi colon here, then we need to issue an error
	  // though we don't worry about it syntactically.
	  //
	  {
		  log.error(semiPos(), MsgSym.MESSAGE_JAVAFX_SEMI_REQUIRED);
	  }
	
	| (SEMI)=>SEMI		// This is what we want	
	;

// -------------------------
// Decides whether a SEMI is required at this point in the parse (and issues
// an error if it is and is not present), or is optional (in which case it eats it) or
// we have just consumed one, which means we can not worry about it as the
// previous rule obviously decided that it wasn't optional and consumed it.
// This rule could result in doubly reporting the absent semi colon if there
// is a construct that consumes one, but does not find one, then a higher
// rule calls this rule, which also decideds one is necessary as it did not see one.
// However, the grammar is carefully soncstrcuted such that this does not happen
//
possiblyOptSemi
	: 	
			{
				// Call super class function to decide whether to look for
				// the SEMI or not and whether to log an error if one is 
				// missing.
				//
				checkForSemi();
			}
	;

