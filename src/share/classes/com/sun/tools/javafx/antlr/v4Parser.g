/*
 * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 */

/////////////////////////////////////////////////////////////////////////////////
// Version 4 of the JavaFX parser grammar.
//
// @author Jim Idle
//
// Version 4 of the grammar reverts to a spearate lexer and parser grammar without a separate
// ANTLR based AST walker. This is because this is the easiest way (at the time of writing)
// to confine error recovery to the smallest possible set of side effects on the resulting
// JavafxTree. This is important for down stream tools such as code completion, which require
// as much of the AST as is possible to produce if they are to be effective.
//
// Derived from prior versions by:
//
// @author Robert Field
// @author Zhiqun Chen
//
parser grammar v4Parser;

options { 

	// Rather than embed parser oriented Java code in this grammar, just to override
	// methods in the ANTLR base recognizer and derviative classes, we
	// instruct ANTLR to generate a class which is dervied from our own
	// super class. The super class is where we embody any code that does
	// not require direct access to the methods generated 
	// to implement the parser. Hence for instance this is where the 
	// JavafxTreeMaker lives.
	//
	superClass 	= AbstractGeneratedParserV4; 

	// Import the token vocabulary, generated by the
	// lexer grammar analysis.
	//
	tokenVocab	= v4Lexer;
}

// -----------------------------------------------------------------
// This section provides package and other information
// to the parser. It is inserted at the start of the generated parser
// code
//
@parser::header {

// Package specification for the generated parser class
//
package com.sun.tools.javafx.antlr;

// Parser specific inports.
//

import java.util.HashMap;
import java.util.Map;
import java.io.OutputStreamWriter;

import com.sun.tools.javac.tree.*;
import com.sun.tools.javafx.tree.*;
import com.sun.javafx.api.tree.*;

import com.sun.tools.javac.util.*;
import com.sun.tools.javafx.util.MsgSym;

import com.sun.tools.javac.code.*;
import com.sun.tools.javafx.code.JavafxFlags;
import static com.sun.tools.javac.util.ListBuffer.lb;
import com.sun.javafx.api.JavafxBindStatus;

import static com.sun.javafx.api.JavafxBindStatus.*;

}

@members {


	/***
	 * Given a specific starting token, locate the first non-whitespace token
	 * that preceeds it, returning it if it is a comment.
	 *
	 * A number of syntactical constructs can be preceded by a documentatin COMMENT which 
	 * is assocaitaed with the construct and should be placed in the AST. Such comments
	 * must begin with the introduceer '/**'.
	 * This method scans backwards from the supplied token until it finds a token that is 
	 * not considered to be WHITESPACE. If the token is a qualifying COMMENT then it is
	 * deemed to belong to the construct that asked to locate the comment and is
	 * returned to the caller.
	 *
	 * @param start The token from whence to search backwards in the token stream.
	 * @return null if there is no associated comment, the token that contains the
	 *         comment, if there is.
	 */
    CommonToken getDocComment(Token start) {
    
    	// Locate the position of the token before this one in the input stream
    	//
		int index = start.getTokenIndex() - 1;
		
		// Loop backwards through the token stream until
		// we find a token that is not considered to be whitespace
		// or we reach the start of the token stream.
		//
		while (index >= 0) { 
			Token tok = input.get(index);
			int type;
			
			// Because modifiers are dealt with uniformly now, we must ignore
			// them when running backwards looking for comments. Perhaps I will
			// review this and record the pre-modifer position or make modifiers
			// find the documentation comment.
			//
			type = tok.getType();
			if (   type == WS 
				|| type == ABSTRACT			|| type == BOUND
				|| type == OVERRIDE			|| type == PACKAGE
				|| type == PROTECTED		|| type == PUBLIC
				|| type == PUBLIC_READ		|| type == PUBLIC_INIT
				//TODO: deprecated -- remove this at some point
				//
				|| type == STATIC
						
			   ) {
              --index;
            } else {
              break;
			}
		}

		// Assuming that we have found a valid token (not reached the
		// the token stream start, check to see if that token is a COMMENT
		// and return null if it is not.
		//
		if (index < 0 || input.get(index).getType() != COMMENT) {
		
           return null;
		}
		
		// We have a valid token, see if it is a documentation
		// comment, rather than just a normal comment.
		//
		CommonToken token = (CommonToken)(input.get(index));
       	if (token.getText().startsWith("/**")) {
       	
       		// It was a documentation comment so change its type
       		// to reflect this, then return it.
       		//
       		// TODO: JI - Move this type changing into the lexer 
       		//
			token.setType(DOC_COMMENT);
			return token;
		}
		
		// The token was either not a comment or was not a documentation
		// comment.
		//
		return null;
    }
}
 
// ------------------------------------------------------------------    	
// ------------------------------------------------------------------
// PARSER RULES
//
// The parser consumes the token stream created by calling the lexer until
// we see EOF. When the parser starts, the entire token stream is created.
// We cannot do syntax directed parsing as it means you cannot use LL(*)
// algorithms for grammar analysis and code generation.
//
// The parsers job is to produce the JavaFX specialized AST, which
// is the basis for all the rest of the tool chain, including symbol table and code 
// generation as well as code completion for editors and so on.
// ------------------------------------------------------------------

/**
 * The usual entry point for the JavaFX parser, this will parse a complete
 * script body and manufacture the JavaFX AST.
 *
 * A script, like many other syntactical elements, can have an associated
 * comment. When the parse is complete, we scan the tokens that are normally
 * hidden from the parser looking for comments and associate them with
 * AST node for the script.
 */
script

	returns	[JFXScript result]
	
@init
{
	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

	// AST start position
	//
	int	rPos = pos();
	
	// Initialize the tree map if we are creating the AST end position
	// map.
	//
	endPositions = genEndPos ? new HashMap<JCTree,Integer>() : null;
	
	// Initialize document comment collection
	//
	docComments	= null;
	
}

	:  pd=packageDecl si=scriptItems 
	
		{
			// Construct the JavFX AST
			//
			$result = F.Script($packageDecl.value, $si.items.toList());
            setDocComment($result, docComment);	// Add any detected documentation comment
            
   			// Set tree span and endpoint map (if required).
        	//
        	$result.pos = rPos;
        	endPos($result); 
        	
        	// Pass on the documentation comments and the endpos map
        	//
        	$result.docComments 	= docComments;
        	$result.endPositions	= endPositions;
		}

		EOF 	// Forces parser to consume entire token stream or error out
    ;
    

// ----------------------    
// Package specification.
// The package declaration is optional. It qualifes the namespace/location
// of all subsequent delcarations in the script.
//
packageDecl

	returns [JFXExpression value] 	// Package declaration builds a JFXExpression tree

    : PACKAGE qualname SEMI
    
    		{ $value = $qualname.value; }
    		
    | // No package specified
    
    		{ $value = null; }
	;
	
// ----------------
// Script elements.
// Zero or more script elements belong to a script. Script elements
// are allowed to be completely empty, or effectively empty by
// existing as a SEMI (semi colon only). This structure allows
// class definitions and function definitions to appear to be
// only optionally terminated with a SEMI. The language spec allows
// ONLY class definitions and function definitions to be optionally
// terminated in this way, other constructs MUST be terminated
// with a SEMI.
//
scriptItems

	
	returns [ListBuffer<JFXTree> items = new ListBuffer<JFXTree>()] // This rule builds a list of JFXTree, which is used 
																	// by the caller to build the actual AST.
																	//
	:
		(
			  // Certain script members may be prefixed with modifiers
			  // such as 'public'. We allow the parser to first consume 
			  // all modifier keywords, regardless of whether this is a 
			  // valid modifier for the upcoming declaration. Whether it is
			  // valid or not is a matter for semantic checks to decide.
			  //
			  // Script level variable declarations can conflict with
			  // local variable declarations (which do not allow modifiers
			  // and are encapsulated in the expression rule, which is called
			  // by the statement rule. Hence we must special case it here
			  // unless we want to pass around status to all our rules.
			  // The predicate is a small one and passes or fails quickly.
			  //
			  (modifiers (VAR|DEF|ATTRIBUTE|CLASS|FUNCTION))=>
			  	m1=modifiers
				(
					  c=classDefinition			[$m1.mods]
					  
					 		{ 
								$items.append($c.value); 
							}
							
					| v=variableDeclaration 	[$m1.mods] 
					
							{ 
								$items.append($v.value); 
							}
							
					| f=functionDefinition    	[$m1.mods]
					

					 		{ 
								$items.append($f.value); 
							}
				)
				
			| i=importDecl
			
				{ 
					$items.append($i.value); 
				}
			
			| s=statement
			
				{ 
					$items.append($s.value); 
				}
			
			| SEMI
		)*
	;

// ----------
// Modifiers.
// Collects the modifier flags for all known modifiers, regardless
// of their validity with the declaration they will be associated with.
// Attributing will verify the smeantics of the modifiers.
//
modifiers

	returns [JFXModifiers mods]	// Constructs and returns a specialized modifer node

@init {

	// The flags we build up for the AST
	//
	long	flags 	= 0;
	
	// The start character position for this AST
	//
	int   	cPos		= pos();
}

	: 	(	
			mf=modifierFlag
			
			{
				// Or in the newly discovered modifier
				//
				flags	|= $mf.flag;
			}
	
		)*
		
		{
			// Build the modifier flags (just as empty if we did not pick any up)
			//
			$mods = F.at(cPos).Modifiers(flags);
			
			// Tree span
			//
			endPos($mods);
		}
	;

// ---------------
// Modifier flags.
// All the possible modifier keywords that can be applied to 
// constructs such as var, class and so on,
//
modifierFlag

	returns [long flag]
	
	: ABSTRACT			{ $flag = Flags.ABSTRACT;				}
	| BOUND				{ $flag = JavafxFlags.BOUND;			}
	| OVERRIDE			{ $flag = JavafxFlags.OVERRIDE;			}
	| PACKAGE			{ $flag = JavafxFlags.PACKAGE_ACCESS;	}
	| PROTECTED			{ $flag = Flags.PROTECTED;				}
	| PUBLIC			{ $flag = Flags.PUBLIC;					}
	| PUBLIC_READ   	{ $flag = JavafxFlags.PUBLIC_READ;		}
	| PUBLIC_INIT		{ $flag = JavafxFlags.PUBLIC_INIT;		}
        
	
	//TODO: deprecated -- remove these at some point
	//                    For now, warn about their deprecation
	//
	| PRIVATE			{ log.warning(pos($PRIVATE), "javafx.not.supported.private"); }
	| STATIC			{ $flag = Flags.STATIC;      			}
	;

// -----------------	
// Import statement.
// Include definitions from an external source
//
importDecl

	returns [JFXTree value] // The import declaration is built as a generic JFXTree

 	: IMPORT importId
 	
 		{
 			// AST construction
 			$value = F.at(pos($IMPORT)).Import($importId.pid);
 			
 			// AST span
 			//
			endPos($value);
 		}
	;
	
// ------------
// Import spec.
// Parses the (possibly) qualifed name space that the script must import,
//
importId

	returns [JFXExpression pid]	// Qualified names are built as expression trees

 	: i1=identifier
 		{
 			$pid = $i1.value;
 		}
		( 
			d1=DOT n2=name
		
				{
					$pid = F.at($n2.pos).Select($pid, $n2.value);
                    endPos($pid);
				}
		)* 
        ( 
        	DOT STAR
        	
        		{
					$pid = F.at($n2.pos).Select($pid, names.asterisk);
                    endPos($pid);
				}
        )?  
	;
	
// Class definition.
// Parses a complete class definition and builds up the JFX AST
// that represents this.
//
// param mods The previously built modifier flags
//
classDefinition [ JFXModifiers mods ]

	returns [JFXClassDeclaration value]	// The class definition has its own JFXTree type
	
@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

}

	: CLASS name supers 
		LBRACE 
			classMembers 
		RBRACE
		
		{ 
			$value = F.at(pos($CLASS)).ClassDeclaration
			
				(
	  						  
					$mods,	
					$name.value,
					$supers.ids.toList(),
					$classMembers.mems.toList()
				);
				setDocComment($value, docComment);	// Add any detected documentation comment
				endPos($value, pos($RBRACE)); 
		}
	;
	
// -----------------
// Super class spec.
// Parses a list of super classes for a class definition and builds the
// associated JFX AST.
//
supers 

	returns [ListBuffer<JFXExpression> ids = new ListBuffer<JFXExpression>()]	// The return is a list of JFX expressions representing one
																				// or more super class type name.

	: EXTENDS t1=typeName
			{
				$ids.append($t1.value);	// First type name in list
			}
           ( 
           	COMMA t2=typeName 
           	
           		{ 
           			$ids.append($t2.value); 
           		}
           )*
           
	| // Upsilon - this class inherits no other types so the list will be empty
	;
		  					
// --------------
// Class members.
// Parses all the possible elements of a class definition and produces the
// Java FX AST nodes that represent them
//
classMembers 

	returns [ListBuffer<JFXTree> mems = new ListBuffer<JFXTree>()]		// Returns a list of the class members, ready for the caller to produce the
																		// class defintion AST.
	: (
		classMember 
	
			{ 
				$mems.append($classMember.member); 
			}
		| SEMI
	  )*
	;
	
// --------------
// Class members.
// Parses all constructs that can be a member of a class and returns
// the JAva FX AST that represents it.
//
classMember

 	returns [JFXTree member]		// A class member has a specialized JFX tree node, which is what
									// we return from this rule.

 
	: initDefinition				{ $member = $initDefinition.value; 		}
	| postInitDefinition			{ $member = $postInitDefinition.value; 	}
	| (OVERRIDE variableLabel)=>
			overrideDeclaration		{ $member = $overrideDeclaration.value;	}
	| m=modifiers
		(
			  variableDeclaration		[$m.mods] 		{ $member = $variableDeclaration.value; }
			| functionDefinition		[$m.mods]		{ $member = $functionDefinition.value; 	}
		)
	
	;


// ----------
// Functions.
// While funcitnos can be declared at any level, their syntax is the same.
// As always, the semantic pass of the JFX tree must verify that the
// supplied modifers are valid in this context.
//
functionDefinition [ JFXModifiers mods ]

	returns [JFXFunctionDefinition value]		// A function defintion has a specialized node in the JavaFX AST

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

}
	: FUNCTION name formalParameters typeReference 
	
		// The function block is optional as is the terminating semi colon
		// if it is absent.
		//
		((LBRACE)=>block | (SEMI)=>SEMI)?
	
		{
			// Create the function defintion AST
			//
			$value = F.at(pos($FUNCTION)).FunctionDefinition
							(
								$mods,
								$name.value, 
								$typeReference.rtype,
								$formalParameters.params.toList(), 
								$block.value
							);
							
			// Documentation comment (if any)
			//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// ---------
// Override.
// Specifes that the local class overrides something that it has
// inherited - parse this and produce the JavaFX tree that reflects it.
//
overrideDeclaration

	returns [JFXOverrideClassVar value]

	: OVERRIDE variableLabel  i=identifier (EQ boundExpression)? onReplaceClause?
	
		{
			// Build the AST
			//
			$value = F.at(pos($OVERRIDE)).OverrideClassVar
						(
							$i.value,
							$boundExpression.value,
							$boundExpression.status,
							$onReplaceClause.value
						);
			
			// Tree span
			//
			endPos($value);
		}
	;

// ------------
// Init block.
// Parse the initialization block for a class definition.
// Note that we allow more than one of these syntactically.
//
initDefinition

	returns [JFXInitDefinition value]	// The initialisation block has a specialized JFX tree node
	
	: INIT block
	
		{
			// Build the AST
			//
			$value = F.at(pos($INIT)).InitDefinition($block.value);
			
			// Tree span
			//
			endPos($value); 
		}
	;

// Post initialization.
// Parse the post initialization block and produce the AST
//
postInitDefinition

	returns [JFXPostInitDefinition value]	// Post initialization has its own specialized JFX tree node

	: POSTINIT block
		{ 
			// Build the AST
			//
			$value = F.at(pos($POSTINIT)).PostInitDefinition($block.value);

			// Tree span
			//
			endPos($value); 
		}
	;
	
//triggerDefinition
//	: WITH name onReplaceClause		-> ^(WITH name onReplaceClause)
//	;


// Variables.
// While they can be defined at different levels (script, member, local) the syntax
// for declaring variables, and the modifiers and so on are all exactly
// the same (syntactically) at all levels.
// Parser a variable declaration and return the resultant JFX expression tree.
//
variableDeclaration [ JFXModifiers mods ]

	returns [JFXExpression value]

@init { 

	// Search for the document comment token. At this point LT(1)
	// returns the first on channel token, so we can scan back from
	// there to see if there was a document comment.
	//
	CommonToken  docComment = getDocComment(input.LT(1));

    // Bind status if present
    //
    JavafxBindStatus bStatus = null;

    // Bind value expression, if present
    //
    JFXExpression bValue = null;

    // ONReplace clause if present
    //
    JFXOnReplace  oValue = null;
}
	: variableLabel  name  typeReference 

        (
            (EQ)=>EQ boundExpression
                {
                    bValue  = $boundExpression.value;
                    bStatus = $boundExpression.status;
                }
        )? 
        
        (
            (ON)=>onReplaceClause
                {
                    oValue = $onReplaceClause.value;
                }
        )?
	
		{
			// Add in the modifier flags accumulated by the label type
			// Note that syntactiaclly, we allow all label types at all levels and must throw
			// out any invalid ones at the semantic checking phase
			//
			$mods.flags |= $variableLabel.modifiers;
	    	
	    	// Construct the varaible JFXTree
	    	//
	    	$value = F.at($variableLabel.pos).Var
	    				(
	    					$name.value,
	    					$typeReference.rtype,
	    					$mods,
	    					bValue,
	    					bStatus,
	    					oValue
	    				);
	    	
	    	// Documentation comment (if any)
	    	//
			setDocComment($value, docComment);
			
			// Tree span
			//
			endPos($value); 
		}
	;
	

// ----------------
// Parameter lists.
// Parse the formal parameters of a function declaration and produce the
// corresponding AST. 
//
formalParameters

	returns [ListBuffer<JFXVar> params = new ListBuffer<JFXVar>()]		// Return type is a list of all the AST nodes that represent a 
																		// formal parameter, this is used to generate the AST for the
																		// funciton definition itself.
 
	: LPAREN 
	
		(
			fp1=formalParameter 
	
			{
				// Capture the first parameter
				//
				params.append($fp1.var); 
			}
			(
				COMMA fp2=formalParameter
				
					{ 
						// Second and subsequent parameter ASTs
						//
						params.append($fp2.var); 
					} 
			)*  
		)?
			
	  RPAREN
	;
	
// -----------------
// Formal parameter.
// Parse the specification of an individual function parameter and
// produce the AST. Note that a parameter may be left empty
//
formalParameter

	returns [JFXVar var]	// Formal parameters are contained in a JFX tree var node.

	: name typeReference
	
		{ 
			$var = F.at($name.pos).Param($name.value, $typeReference.rtype);
			endPos($var); 
		}
	;

// ------
// block.
// A block component is actually a unit that returns a value, it is an expression.
// In certain contexts the braces are more lexigraphically significant, such as the
// boundaires of if blocks. Hence those contexts specify the block directly rather than
// leaving the expression statement to pick it up.
//
// This means that a statement such as:
//
// if (x) { y} -z
//
// Does not consume the { y } -z as a complete expression but does
// what a programmer intuitively expects and uses only {y } as the
// subject of the if, with -z being a separate expression statement.
//
// A programmer can treat the above construct as a single expression
// by enclosing it in braces:
//
// if (x) { { y } -z }
//
// Which is then obvious. This also improves error recovery possibilities,
// which is a requirement for code completion utilities and so forth.
//
block 

	returns [JFXBlock value]	// The block expression has a specialized node inthe JFX tree

@init { 

	// A list of all the statement ASTs that make up the block expression
	//
	ListBuffer<JFXExpression> stats = new ListBuffer<JFXExpression>(); 
	
	// For building invidual statements
	//
	JFXExpression val = null;
}
	
	: LBRACE 
	
		(
			statement
	
				{
					// If the current statement is not the first one
					// then append it to the list. This logic leaves us with 
					// the AST for the last statement in the block
					// in our val variable, which we need to build the
					// AST for the block.
					//
					if	(val != null)
					{
						stats.append(val);
					}
					
					// Pick up the AST for the staemetn we just parsed.
					//
					val = $statement.value;
				}
				
			| SEMI
	   )*
	
	  RBRACE
	  
	  	{
		  	$value = F.at(pos($LBRACE)).Block(0L, stats.toList(), val);
	  		endPos($value);
	  	}
	;

// -----------
// statements.
// Parse the set of elments that are viewed as programmig statements. Note
// that this includes expressions which are considered statements.
// Note that each individual statement specifies whether it requires a
// terminating SEMI, whether this is optional, or whether this is just
// not required (such as if () {} ).
//
statement 

	returns [JFXExpression value] // All statements return an expression tree

	: insertStatement		{ $value = $insertStatement.value; 								}
	| deleteStatement		{ $value = $deleteStatement.value; 								}
 	| whileStatement		{ $value = $whileStatement.value; 								}
	| BREAK    				{ $value = F.at(pos($BREAK)).Break(null); 		endPos($value); } SEMI
	| CONTINUE  	 	 	{ $value = F.at(pos($CONTINUE)).Continue(null);	endPos($value); } SEMI
    | throwStatement	   	{ $value = $throwStatement.value; 								}
    | returnStatement 		{ $value = $returnStatement.value; 								}
    | tryStatement			{ $value = $tryStatement.value; 								}
    | expression ((SEMI)=>SEMI)?		
    						{ $value = $expression.value;									}
    ;
  
// -----------  
// ON REPLACE.
// Parse an ON REPLACE clause which is an optional element of variable
// declarations and OVERRIDEs.
//
onReplaceClause

	returns [JFXOnReplace value]	// onReplace has its own JFX Tree node type
	
	: ON REPLACE oldv=paramNameOpt 
	
		(
			  (LBRACKET first=paramName DOTDOT last=paramName RBRACKET)?
			 
				 EQ newElements=paramName
		)? 
		
	
		block
		
		{ 
			// Build the appropriate AST
			//
			$value = F.at(pos($ON)).OnReplace($oldv.var, $first.var, $last.var, $newElements.var, $block.value);
			endPos($value); 
		}
	;
	
// ------------------
// Optional parameter
// Parse and construct an AST for optional parameters
//
paramNameOpt

	returns [JFXVar var]	// Returns a JFXVar tree node

    : paramName
    	{
    		{ $var = $paramName.var; }
    	}
    	
    |	{ $var = null; }
    ;

// ---------
// Parameter.
// Parse and construct the AST for a parameter
//
paramName

	returns [JFXVar var]	// Returns a JFXVar tree node

	: name
		{
    		{ 
    			$var = F.at($name.pos).Param($name.value, F.TypeUnknown()); 
    			endPos($var);
    		}
    	}
	;
	
    
// The ways in which a variable can be declared
//
variableLabel 
	
	returns [long modifiers, int pos] // returns the appropriate modifier flags and the position of the token
	
	: VAR			{ $modifiers = 0L; $pos = pos($VAR); }
	| DEF			{ $modifiers = JavafxFlags.IS_DEF; $pos = pos($DEF); }
	| ATTRIBUTE		{ $modifiers = 0L; $pos = pos($ATTRIBUTE); log.warning(pos($ATTRIBUTE), "javafx.not.supported.attribute"); }
	;

// ------	
// Throw.
// Parse the standard exception throwing mechanism.
//
throwStatement

	returns [JFXExpression value]	// Returns the JFX Expression tree representing what we must throw

	: THROW expression ((SEMI)=>SEMI)?
	
		{ 
			// AST for the thrown expression
			//
			$value = F.at(pos($THROW)).Throw($expression.value);
			
			// Tree span
			//
			endPos($value);
		}
	;

// ---------------
// While statement
//
whileStatement
	
	returns [JFXExpression value]	// Returns the JFX Expression tree representing the WHILE
	
	: WHILE LPAREN expression RPAREN 
	
		 loopVal=statement
			
		{
	
			// The AST for the WHILE, using either the block or statement
			//
			$value = F.at(pos($WHILE)).WhileLoop($expression.value, $loopVal.value);
			
			// Tree span
			//
			endPos($value);
		}
	;

// -------
// INSERT.
// Parse the insert statement and produce the relevant AST
//
insertStatement  
	
	returns [JFXExpression value]	// All steatemetns return a JFX expression tree

	: INSERT elem=expression
		(
			  INTO eseq=expression
			  
			  	{
			  		// Form 1, INTO
			  		//
					$value = F.at(pos($INSERT)).SequenceInsert($eseq.value, $elem.value, null, false);
			  	}
			  	
			| BEFORE isfi=indexedSequenceForInsert
			
				{
					// Form 2, BEFORE
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, false);
				}
				
			| AFTER isfi=indexedSequenceForInsert
			
				{
					// Form 3, AFTER
					//
					$value = F.at(pos($INSERT)).SequenceInsert($isfi.seq, $elem.value, $isfi.idx, true);
				}
		)

		{
			// Tree span
			//
			endPos($value);
		}	    
	    
	    ((SEMI)=>SEMI)?
	    
	;
	
// ----------------
// Insert seqeunce.
// Parse the syntax for an insert sequence specified by the 
// INSERT BEFORE and INSERT AFTER variants.
//
indexedSequenceForInsert

	returns [JFXExpression seq, JFXExpression idx]

	: primaryExpression 			
	
		{
			// Sequence expression
			//
			$seq = $primaryExpression.value;
		}
		
	  LBRACKET expression RBRACKET
	  
	  	{
	  		// Index expressions
	  		//
	  		$idx = $expression.value;
	  	}
	  		
 	;
 
// -----------------	
// DELETE statement.
// Parse the DELETE statement forms and return the appropriate AST
//
deleteStatement  

	returns [JFXExpression value]	// Delete returns a JFX Expression tree

	: DELETE e1=expression

	   ( 
	   		  (FROM)=>FROM e2=expression
	   		  	
	   		  	{
	   		  		$value = F.at(pos($DELETE)).SequenceDelete($e2.value,$e1.value);
	   		  	}
	   		  	
	   		| /* indexed and whole cases */
	   		
	   			{
	   				$value = F.at(pos($DELETE)).SequenceDelete($e1.value);
	   			}
	   			
	   )
	   
	   {
	   		// Tree span
	   		//
	   		endPos($value);
	   }
	   ((SEMI)=>SEMI)?
	;

// -----------------
// RETURN statement.
// Parse the return statement forms and produce the relevant AST
//
returnStatement

	returns [JFXExpression value]	// RETURN returns a JFX Expression tree

	: RETURN 
		
		(
			  expression		
			  
			  	{	
			  		$value = F.at(pos($RETURN)).Return($expression.value);	
			  	}
			  	
			  	((SEMI)=>SEMI)?
			  	
			| SEMI			// Can't have a SEMI be optional here as we must eitehr consume
							// the next expression or not.
				{	
					$value = F.at(pos($RETURN)).Return(null);				
				}
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
		
		
	;
	
// -----------------------------
// TRY..CATCH..FINALLY seqeunce.
// Parse and build the AST for the stabdard try sequence
// TODO: Come back and relax the syntax requirements so as to catch malformed structure at semantic level
//       I.E. "Too many finally claues for try at nnn"
tryStatement

	returns [JFXExpression value]	// returns a JFX Expression tree
	
@init
{
	// AST for any catch clauses
	//
	ListBuffer<JFXCatch> caught = ListBuffer.lb();
}
	: TRY block 			
		(
		 	  f1=finallyClause
	   		| (
	   				catchClause
	   				
	   				{
	   					// Accumulate the catch clauses
	   					//
	   					caught.append($catchClause.value);
	   				}
	   		  )+ 
	   			
	   			( 
	   				f1=finallyClause
	   			)?   
	   	)
	   	
	   	{
	   		// Build the AST
	   		//
	   		$value = F.at(pos($TRY)).Try($block.value, caught.toList(), $f1.value);
	   		
	   		// Tree span
	   		//
	   		endPos($value);
	   	}
	;
	
// -------
// FINALLY
// Parse the finally clause of a trey...catch...finally sequence
//
finallyClause

	returns [JFXBlock value] // returns a JFX Expression tree
	
	: FINALLY block
	
		{
			$value = $block.value;
			endPos($value);
		}
	;
	
// ------
// CATCH.
// Parse a catch clause of a try...catch...finally
//
catchClause

	returns [JFXCatch value]	// Catch has its own JFX tree node type
	
	: CATCH LPAREN formalParameter RPAREN block
	
		{
			$value = F.at(pos($CATCH)).Catch($formalParameter.var, $block.value);
			endPos($value);
		}
	;
	
// ---------------------
// Boundable expression.
// Used to parse expressions that can be bound to a variable.
//
boundExpression 

	returns [JavafxBindStatus status, JFXExpression value] 	// We nede to return a status flag to say how and if the
															// expression is bound, and the AST for the expression itself.

@init 
{ 
	boolean isLazy 			= false; 	// Signals presence of LAZY
	boolean isBidirectional	= false; 	// Signals presence of INVERSE
}

	: BIND e1=expression 
	
			(
				(WITH)=>WITH INVERSE
				
				{
					// Update status
					//
					isBidirectional = true;
				}
			)?
			
			{
				// Set up the bound expression
				//
				$value	= $e1.value;
				
				// Update the status
				//
				$status	= isBidirectional? isLazy? LAZY_BIDIBIND : BIDIBIND
	  									   : isLazy? LAZY_UNIDIBIND :  UNIDIBIND;
			}
	
	| e2=expression
	
		{
			// Unbound expression AST
			//
			$value 	= $e2.value;
			
			// Update the status
			//
			$status	= UNBOUND;
		}
	;
	
// -----------
// expression.
// General expression parse and AST build.
//
expression

	returns [JFXExpression value]	// Expression has its own dedicated JFX tree node type
 
 @init
 {
 	// Used for error reporting
 	//
 	int ePos = 0;
 }
	: ifExpression

		{
			$value = $ifExpression.value;
		}
				
	| forExpression   	

		{
			$value = $forExpression.value;
		}
		
	| newExpression

		{
			$value = $newExpression.value;
		}
		
	| assignmentExpression

		{
			$value = $assignmentExpression.value;
		}
		
	| // Expressions can only declare local variables, hence we
	  // we parse any we find, but throw them out as a semantic
	  // error
	  {
	  	ePos = pos();
	  }
	  m=modifiers 
	  
	  	{
	  		if	($m.mods.flags != 0)
	  		{
	  			// Ignore the modifiers
	  			//
	  			$m.mods.flags = 0;
	  			
	  			// Issue the error
	  			//
	  			log.error(ePos, "javafx.cannot.modify.localvar");
	  			
	  		}
	  	}
	  	
	  	variableDeclaration [$m.mods]
	
		{
			$value = $variableDeclaration.value;
		}
	;

// ------------------------
// FOR statement/expression
//
forExpression

	returns [JFXExpression value]	// All statements are expressions

@init
{
	// In clause accumulator
	//
	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();
}
	: FOR 
		LPAREN 
		
			i1=inClause			{  clauses.append($i1.value); }
			(COMMA i2=inClause	{  clauses.append($i2.value); } )* 
			
		RPAREN 
		
		statement
				
			{
		 		$value = F.at(pos($FOR)).ForExpression(clauses.toList(), $statement.value);
			}
		
		{
			// Tree span
			//
			endPos($value);
		}
	;

// ----------
// IN clause.
// Parse an individual IN clause of a FOR statement.
//
inClause

	returns [JFXForExpressionInClause value]	// Dedicated AST tree node

@init
{
	// Assume no WHERE expression
	//
	JFXExpression weVal = null;
}

	: formalParameter IN se=expression 
	
		(
			  WHERE we=expression	{ weVal = $we.value; }
			|
		)
		
		{
			$value = F.at(pos($IN)).InClause($formalParameter.var, $se.value, weVal);
			endPos($value); 
		}
	;
	
// -----------------------
// If Then Else expression
//
ifExpression 

	returns [JFXExpression value]	// The expression tree that represents the If expression
	
@init
{
	// Statement or block expression
	//
	JFXExpression sVal = null;
	
	// Else expression (if present)
	//
	JFXExpression eVal = null;
}
	: IF LPAREN econd=expression  RPAREN 
	
		THEN?  statement 			{ sVal = $statement.value;		}
			
			(
				(ELSE)=>elseClause	{ eVal = $elseClause.value;	}
			)?
			
		{
			// The IF AST
			//
			$value = F.at(pos($IF)).Conditional($econd.value, sVal, eVal);
			
			// Tree span
			//
			endPos($value);
		}
	;
	
// -----------
// Else clause
// Parse the else expression of an if statement
//
elseClause

	returns [JFXExpression value]	// The expression tree that represents the Else expression
	
	: ELSE  
		(
			statement			{ $value = $statement.value; 	}
		)
	;
	

// -----------
// Assignment.
// Parse and produce teh AST for an assignement expression. Note
// that name of this rule is a slight misnomer. It might encapsulate
// an assignment, but it might be just a straight expression.
//
assignmentExpression  

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}
	: lhs=assignmentOpExpression 
		(     
			  (EQ)=> EQ rhs=expression
			  
			  	{
			  		// This is actually an assign
			  		//
			  		$value = F.at(rPos).Assign($lhs.value, $rhs.value);
			  		
			  		// Tree span
			  		//
			  		endPos($value);
			  	}
			  	
			|	// Just an expression without an assignment
				//
				{
					$value = $lhs.value;
				}
		)
	;
	
assignmentOpExpression

	returns [JFXExpression value]	// The expression tree that represents the assignment expression

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: lhs=andExpression					
	  
		(     assignOp rhs=expression
		
				{
					// AST for assignement
					//
					$value = F.at(rPos).Assignop($assignOp.op, $lhs.value, $rhs.value);
				}
				
           	| SUCHTHAT such=andExpression (TWEEN i=andExpression)?
           	
           		{
           			// AST FOR Interpolation
           			//
           			$value = F.at(rPos).InterpolateValue($lhs.value, $such.value, $i.value);
           		}
           	
	   		|	{ 
	   				// AST for expressions
	   				//
	   				$value = $lhs.value; 
	   			}	
	   )
	   
	   {
	   		// AST Span
	   		//
	   		endPos($value);
	   }
	;

// -----------------
// Assign operators
// All the operators that involve assignments.
//	
assignOp

	returns	[JavafxTag op]	// Returns the operation token that we find
	
	: PLUSEQ		{ $op = JavafxTag.PLUS_ASG; 			}
	| SUBEQ			{ $op = JavafxTag.MINUS_ASG;			}
	| STAREQ		{ $op = JavafxTag.MUL_ASG;              }
	| SLASHEQ		{ $op = JavafxTag.DIV_ASG;				}
	| PERCENTEQ
		{ 
			$op = JavafxTag.MOD_ASG;
			log.warning(pos($PERCENTEQ), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The operator \%= will not be supported in the JavaFX 1.0 release" );
		}
	;
	
// -------------
// AND opertator
// LL(k) AND precedence
//
andExpression

	returns [JFXExpression value] 	// Expression tree for AND
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	:	e1=orExpression
			
			{
				$value = $e1.value;
			}
	  		( 
	  			AND e2=orExpression
	  			
	  			{
	  				$value = F.at(rPos).Binary(JavafxTag.AND, $value, $e2.value);
	  				endPos($value);
	  			}
	  		)*
	;
	
// -----------
// OR operator
// LL(k) OR precedence
//
orExpression

	returns [JFXExpression value] 	// Expression tree for OR
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: e1=typeExpression

		{
			$value = $e1.value;
		}
	  	( 
	  		OR e2=typeExpression 
	  		
	  		{
	  			$value = F.at(rPos).Binary(JavafxTag.OR, $value, $e2.value);
	  			endPos($value);
	  		}
	  	)*
	;
	
// ----------------
// Typed expression
// LL(k) precedence
//
typeExpression 

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: relationalExpression		

		(
			  INSTANCEOF itn=type
			
				{
					$value = F.at(pos($INSTANCEOF)).TypeTest($relationalExpression.value, $itn.rtype);
					endPos($value);
				}
				
			| AS atn=type
			
				{
					$value = F.at(pos($AS)).TypeCast($atn.rtype, $relationalExpression.value);
					endPos($value);
				}
			
			| 	{
					$value = $relationalExpression.value;
				}
	   )
	;

// -----------
// Relationals
// LL(k) precedence
//	
relationalExpression  

	returns [JFXExpression value] 	// Expression tree for typed expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: a1=additiveExpression	{ $value = $a1.value;	}
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			relOps   a2=additiveExpression
			  	
			  	{
			  		$value = F.at(rPos).Binary($relOps.relOp, $value, $a2.value);
			  		endPos($value);
			  	}
		)* 
	;
	
// ---------------------
// Relational operators.
// LL(k) precedence, all operators are same precedence
//
relOps

	returns [JavafxTag relOp]	// Returns the JFX operator type
	
	: LTGT
		{ 
			$relOp = JavafxTag.NE;
			log.warning(pos($LTGT), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The not-equal operator <> will be replaced by !=" );
		}	
			  		
	| NOTEQ  { $relOp = JavafxTag.NE;	}
	| EQEQ   { $relOp = JavafxTag.EQ;	}
	| LTEQ   { $relOp = JavafxTag.LE;	}
	| GTEQ   { $relOp = JavafxTag.GE;	}
	| LT     { $relOp = JavafxTag.LT;	}
	| GT     { $relOp = JavafxTag.GT;	}
	;

// ---------------------
// Arithmetic operations
// LL(k) precedence.
//	
additiveExpression 

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}
	: m1=multiplicativeExpression	
		{ 
			$value = $m1.value; 
		}
		(
			
			
		    (arithOps)=>
		    
		    	{ rPos = pos(); }	// Use operator as position for AST
		    	
		    	arithOps   m2=multiplicativeExpression

			{
				$value = F.at(rPos).Binary($arithOps.arithOp , $value, $m2.value);
				endPos($value);
			}
		)* 
	;

// --------------------
// Arithmetic operators
//
arithOps

	returns [JavafxTag arithOp]	// Returns the JFX operator type
	
	: PLUS		{ $arithOp = JavafxTag.PLUS; 	}
	| SUB		{ $arithOp = JavafxTag.MINUS;	}
	;

// --------------------------
// Multiplicative expressions
// LL(k) precedence emboides all operators at the same precednce as MUL
//	
multiplicativeExpression

	returns [JFXExpression value] 	// Expression tree for additive expressions
		
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}
	: u1=unaryExpression	{ $value = $u1.value; }
		(
			{ rPos = pos(); }	// Use operator as position for AST
			
			multOps u2=unaryExpression
				
				{
					$value = F.at(rPos).Binary($multOps.multOp, $value, $u2.value);
					endPos($value);
				}
	   )* 
	;

// -------------------------
// Multiplicative operators.
// LL(k) precedence - incorporates any other operators at this precedence
//
multOps

	returns [JavafxTag multOp]	// Returns the JFX operator type
	
	: STAR    	{ $multOp = JavafxTag.MUL;	}
	| SLASH   	{ $multOp = JavafxTag.DIV;	}
	| PERCENT 	
			
		{
			$multOp = JavafxTag.MOD;
			log.warning(pos($PERCENT), MsgSym.MESSAGE_JAVAFX_GENERALWARNING, "The remainder operator \% will be replaced by mod" );
		}	
             
	| MOD		{ $multOp = JavafxTag.MOD;	}
	;
	
// -----------------	
// Unary expressions
// LL(k) Precedence
//
unaryExpression

	returns [JFXExpression value] 	// Expression tree for unary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: se=suffixedExpression

		{
			$value = $se.value;
		}
		
	| INDEXOF		id=identifier
	
		{ 	
			$value = F.at(rPos).Indexof($id.value);
			endPos($value);
		}
		
	| unaryOps     	e=unaryExpression

		{
			$value = F.at(rPos).Unary($unaryOps.unOp, $e.value);
			endPos($value);
		}
	;
	
// -------------------------
// Unary operators.
// LL(k) precedence
//
unaryOps

	returns [JavafxTag unOp]	// Returns the JFX operator type
	
	: SUB			{ $unOp = JavafxTag.NEG; }
	| NOT			{ $unOp = JavafxTag.NOT; }
	| SIZEOF		{ $unOp = JavafxTag.SIZEOF; }
	| PLUSPLUS		{ $unOp = JavafxTag.PREINC; }
	| SUBSUB		{ $unOp = JavafxTag.PREDEC; }
	| REVERSE		{ $unOp = JavafxTag.REVERSE; }
	;

// ------------------
// Postfix operations
// LL(k) precedence
//
suffixedExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
}

	: pe=postfixExpression
		( 
			  { input.LT(-1).getType() != RBRACE }?=> PLUSPLUS
			  
			  	{
			  		$value = F.at(rPos).Unary(JavafxTag.POSTINC, $pe.value);
			  		endPos($value);
			  	}
			  	
			| { input.LT(-1).getType() != RBRACE }?=> SUBSUB
			
				{
					$value = F.at(rPos).Unary(JavafxTag.POSTDEC, $pe.value);
					endPos($value);
				}
				
			| { $value = $pe.value; }
		)
	;
	
// ------------------------
// Postfix-able expressions
// LL(k) precedence
//
postfixExpression 

	returns [JFXExpression value] 	// Expression tree for suffix expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	int	sPos = rPos;

	// Position for pipe epxression
	//
	int pPos;
	
	// Indicates if we had the LT token
	//
	int clusiveType = SequenceSliceTree.END_INCLUSIVE;
	
	// Last element of sequence (if present)
	//
	JFXExpression	lastExpr = null;
}

	: pe=primaryExpression	{ $value = $pe.value; }
	
		( 
			  DOT 
				( 
					  n1=name
					  
					  {
							$value = F.at(pos($DOT)).Select($value, $n1.value);
							endPos($value);
					  }
					  
					//TODO:		 | CLASS 
	         	)

			| (LPAREN)=>LPAREN 

					expressionList RPAREN
			
				{
					$value = F.at(pos($LPAREN)).Apply(null, $value, $expressionList.args.toList());
					endPos($value);
				}
				
			| (LBRACKET)=>l1=LBRACKET
			
				{
					// INit our flags
					//
					clusiveType = SequenceSliceTree.END_INCLUSIVE;
					lastExpr 	= null;
				}
	
				(
					  n2=name PIPE 
					  
					  { rPos = pos(); }	// Use expression as position for AST
					  
					  e1=expression r3=RBRACKET
					  
					  {
					  	// Build a list of clauses as AST builder expects this
					  	//
					  	ListBuffer<JFXForExpressionInClause> clauses = ListBuffer.lb();
                  		
                  		// Build a var reference
                  		//
                  		JFXVar var = F.at($n2.pos).Param($n2.value, F.TypeUnknown());
                  		
                  		// Set up the in clause
                  		//
	          			clauses.append(F.at(pos($l1)).InClause(var, $value, $e1.value));
	          			
	          			// Predicate needs identifier AST
	          			//
                  		$value = F.at(pos($PIPE)).Predicate(clauses.toList(), F.at($n2.pos).Ident($n2.value));
                  		
                  		// Tree span
                  		//
                  		endPos($value, pos($r3));
					  }
					  
					| first=expression
                            
						(
							  r1=RBRACKET
							  
							  	{
							  		// Use left bracket as AST start pos
							  		//
							  		$value = F.at(sPos).SequenceIndexed($value, $first.value);
							  		
							  		// Use right bracket as AST end pos
							  		//
							  		endPos($value);
							  	}
							  	
	                    	| DOTDOT 
	                    		(
									  (LT { clusiveType = SequenceSliceTree.END_EXCLUSIVE; } )? 
									  	(
									  		last=expression
									  		{
									  			lastExpr = $last.value;
									  		}
									  	)?
									  	
								)
								
	                      	  r2=RBRACKET
	                      	  
	                      	  {
	                      	  	// If we have LT, then this is an exclusive slice
	                      	  	//
	                      	  	$value = F.at(sPos).SequenceSlice
	                      	  									(
	                      	  										$value,
	                      	  										$first.value,
	                      	  										lastExpr,
	                                                            	clusiveType
	                                                            );
								endPos($value);
	                      	  }
                    	)
             	)
	   	)* 
	;

// -------------------
// Primary expressions
// LL(k) precedence - primitives which cannot be reduced other
// than to atoms.
//	
primaryExpression  

	returns [JFXExpression value] 	// Expression tree for primary expressions

@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Use to build a list of objectLiteral parts.
	//
	ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb();

    // Used to construct time literal expression
    //
    JFXExpression sVal = null;
	
}
	: qualname
		{
			$value = $qualname.value;
		}
		(
			(LBRACE)=>LBRACE  
			  	
					o1=objectLiteral
						
			RBRACE
	              
				{
					// AST
					//
					$value = F.at(rPos).ObjectLiteral($value, $o1.parts.toList());
					
					// Tree span
					//
					endPos($value);
				}
			|
		)

	| THIS

		{
			$value = F.at(pos($THIS)).Ident(names._this);
			endPos($value);
		}
		
	| SUPER
	
		{
			$value = F.at(pos($SUPER)).Ident(names._super);
			endPos($value);
		}
		
	| se=stringExpression

		{
			$value = $se.value;
		}
		
	| be=bracketExpression
	
		{
			$value = $be.value;
		}
		
	| block
	
		{
			$value = $block.value;
		}
		
	| literal
	
		{
			$value = $literal.value;
		}
		
	| fe=functionExpression
	
		{
			$value = $fe.value;
		}
	
	| LPAREN e=expression RPAREN
	
		{
			$value = $e.value;
		}
		
	| AT 
		LPAREN 
			TIME_LITERAL
            {
                sVal = F.at(pos($TIME_LITERAL)).TimeLiteral($TIME_LITERAL.text);
                endPos(sVal);
            }
		RPAREN 
		LBRACE 
			k=keyFrameLiteralPart 
		RBRACE
		
		{
			$value = F.at(rPos).KeyFrameLiteral(sVal, $k.exprs.toList(), null);
			endPos($value);
		}
	;
	
// ------------
// Frame values
//  
keyFrameLiteralPart

	returns [ListBuffer<JFXExpression> exprs = new ListBuffer<JFXExpression>(); ]	// Gathers a list of expressions representing frame values

	: k1=expression 			{ exprs.append($k1.value);	}
	
		(SEMI+
		
			k2=expression		{ exprs.append($k2.value);	}
		)* SEMI*
    ;

// -------------------
// Anonymous functions
//
functionExpression

	returns [JFXExpression value] 	// Expression tree for anonymous function

	: FUNCTION formalParameters typeReference block
	
		{
			// JFX AST
			//
			$value = F.at(pos($FUNCTION)).FunctionValue
								(
									$typeReference.rtype, 
									$formalParameters.params.toList(),
									$block.value
								);
								
			// Tree span
			//
			endPos($value);
		}
	;
	
// ---
// NEW
//
newExpression

	returns [JFXExpression value] 	// Expression tree for new expression
	
	: NEW typeName expressionListOpt
	
		{
			$value = F.at(pos($NEW)).InstanciateNew($typeName.value, $expressionListOpt.args.toList());
			endPos($value);
		}
	;

// ---------------
// Object literals
//
objectLiteral

	returns [ListBuffer<JFXTree> parts = ListBuffer.<JFXTree>lb()]	// Gather a list of all the object literal insitalizations
	
	:   (COMMA|SEMI)*	// Separators are optional and just syntactic sugar
	
		(		
			(
				oli=objectLiteralPart 
			
				{
					parts.append($oli.value);
				}
			)
			
			(COMMA|SEMI)*	// Separators are optional and just syntactic sugar
			
			
		)*		// May be no elements in the object literal, just {}
	
				
	;

// Individual components of an object literal
//
objectLiteralPart

	returns [JFXTree value] 	// Expression tree for object literal elements

	: (OVERRIDE variableLabel)=>
		overrideDeclaration
	
		{
			$value = $overrideDeclaration.value;
		}
		
	| modifiers
		(
			  variableDeclaration    [$modifiers.mods]
			  
			  	{
			  		$value = $variableDeclaration.value;
			  	}
			  	
			| functionDefinition	 [$modifiers.mods]
			
				{
					$value = $functionDefinition.value;
				}
		)
		
	| oli=objectLiteralInit
		
		{
			$value = $oli.value;
		}
    ;
  
// --------------------------     	
// Object literal initializer
//	
objectLiteralInit

	returns [JFXTree value]		// Construct the AST for a name value pair
	
@init
{
	// Work out current position in the input stream
	//
	int	rPos = pos();
	
}
	: name COLON  boundExpression
	
		{
			// AST
			//
			$value = F.at($name.pos).ObjectLiteralPart
									(
										$name.value,
								 		$boundExpression.value, 
								 		$boundExpression.status
								 	);
								 	
			// Tree span
			//
			endPos($value);
		}
	;

// -------	
// Strings
// JavaFX string expresoins are more richly expressive than the more usual
// quoted strings.
//
// 1) A translation key may prefix string literals;
// 2) The string literal itself may consist of multiple parts, which are
//    concatenated at compile time, rather than run time.
//    I.E. ##"MyTransKey" "String part 1" "String part 2\n"
//    This allows for multi line string literals, built at compile time
//    over which the script author then has unambiguous control over
//    leading spaces, can explictly insert new lines, and can comment
//    individual components.
//    I.E. 
//      var myString =
//          "<header>"       // This is the header
//          "some stuff\n"   // Some stuff now, with a trailing newline
//          "  level 1\n"    // More stuff, with leading spaces and a traliing newline
//
// Overall this leades to better error recovery for the parser, while leaving
// the language syntax obvious to and clearly controlled by, the script author;
//
// Notes: 
//
// 1) Only string literals can be compounded in this way - expressions are
//    parsed here, but are thrown out with a semantic error explaining
//    that this is a compile time concept, not a runtime concept;
// 2) A single translation key prefix applys to the entire compound string.
//    Individual compound parts cannot be translated individually;
//
stringExpression 

	returns [JFXExpression value] 	// Expression tree for stringExpressions

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> strexp = new ListBuffer<JFXExpression>();
	
	// Translation key, if any, for the literal string
	//
    String translationKey = null;
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
}

	: (
		  (
			// Translation key is optional
		  	//
		  	TRANSLATION_KEY	{ translationKey = $TRANSLATION_KEY.text; } 
		  )?
	
			// We must find at least one compund element to the string
			//
			strCompoundElement [ strexp ]
			
			(
				// After the first element, there may be any number of additional
				// elements, including zero. We must force the parser to take
				// the righteous path for syntactically correct constructs, then
				// error out semantically on anything else.
				//
				   (STRING_LITERAL|QUOTE_LBRACE_STRING_LITERAL) =>strCompoundElement [ strexp ]
			
					// Expressions are not allowed as compound elements but this will be
					// a common thing to happen while editing and probably a common mistake
					// so we parse it and then falg a semantic error rather than issue
					// a syntax error which would be difficult to recover from.
					// TODO: See if we can resolve the left recurssion problems
					// taht this causes
				//| 	{
						// Record where we are for the error message
						//
				//		ePos = pos();
				//	}
				
				//	expression
			
				//	{
						// Issue semantic error
						// TODO: perhaps this should be added tot the AST
						//
				//		log.error(ePos, "javafx.bad.str.compound");
				//	}

			)*
	  )
	  
		{
  			// AST for string expression
  			// If we accumulated just a single entry then by definition
  			// we accumulated just a simple string literal, but if there
  			// is more than one entry, or there is a translation key,
  			// then we have a string expression
  			//
  			if	(strexp.size() > 1 || translationKey != null)
			{
				// Complex expression
				//
	  			$value = F.at(rPos).StringExpression(strexp.toList(), translationKey);

				// Tree span
  				//
  				endPos($value);

	  		}
	  		else
	  		{
	  			// This is an individual string literal, and is already endPos'ed
	  			//
	  			$value  = strexp.toList().get(0);
			}  			
		}
	;
	
// --------------------------------------------
// An individual component of a compound string
//
// When considering the elements accumulated by the 
// list buffer, assume this:
//
// 1) The list will either be a single element, in 
//    which case it is a single string literal, or
//    contain (3n)+1 elements where n is the number
//    expressions in the string {expr}. This is
//    because an expression consists of the leadin,
//    a format string and the expression, but there is
//    always one final element for the trailing part of
//    the string expression: "leading{\%format expr }trailing"
// 2) A straight literal string can then either be merged with
//    the leadin of the next expression or the trailing of
//    the prior expression, or it stands alone.
//
strCompoundElement [ ListBuffer<JFXExpression> strexp ]
	
	: stringLiteral	[ strexp ]	  		
	| qlsl 			[ strexp ]
	;
	
// ---------------
// String literals
// We may have multiple string literals following each
// other, which we auto concatentate here at compile time
//
//
stringLiteral [ ListBuffer<JFXExpression> strexp ]


@init
{
	// Record position of invalid expression used in compile time
	// string compounding.
	//
	int ePos;
	
	// Used to accumulate multiple string literals
	//
	StringBuffer sbLit = new StringBuffer();
	
	// The string litereal we will created
	//
	JFXExpression sVal = null;
	
}
	: s1=STRING_LITERAL 
	
		{
			// Accumulate the literal
			//
			sbLit.append($s1.text);
		}
	
		(
			(STRING_LITERAL)=> s2=STRING_LITERAL
			
			{
				// Accumulate the literal
				//
				sbLit.append($s2.text);
			}
		)*
		
		{


			// Here, one of the following conditions prevails
			//
			//  i)  We have as yet encountered no components of the compound
			//      string and so we can assume for the moment that the literal
			//      string elements we have accumulated so far will remain as
			//	    a simple string literal, and so just add the literal we
			//	    make as one element.
			// ii)  There has already been some sort of compound expression
			//      in which case there will be more than 0 elements currently in
			//      the compound element list. The list will always be left with
			//      the trailing part of the expression string as the last element
			//      of the list as it is built of "leading{\%format expr}trailing".
			//      So, we can remove the last entry, append this newly accumulated
			//      string literal to it, and move on.
			//
			if	(strexp.size() == 0)
			{
			
				// Now we create the actual string literal
				//
				sVal = F.at(pos($s1)).Literal(TypeTags.CLASS, sbLit.toString());
			
				// Add to list
				//
				strexp.append(sVal);

				// Tree span
				//
				endPos(sVal);
			
			}
			else
			{
				// Already had the first expression, replace the traling part of the
				// last expression with a concatenation of it and this newly found
				// string.
				//
				JFXLiteral trailer = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
				
				// Now, append the string we have to the prior trailing part
				// 
				sbLit.insert(0, (String)(trailer.getValue()));
				
				// Replace the original value
				//
				trailer.value = sbLit.toString();
				
			}
			

		}
	;
	
// --------------------
// String lit component
// String literals with embedded formats/expressions
//
qlsl [ ListBuffer<JFXExpression> strexp]

	: 	ql=QUOTE_LBRACE_STRING_LITERAL	
	
			{
				// Add in the discovered literal value
				//
				// Here, one of the following conditions apply:
				//
				//   i) There are currently no entries in the buffer. The size of strexp
				//      will be 0 in that case and we can process the expression without 
				//      regard to prior values.
				//  ii) There was one or leading string literals (non expressions),
				//      in which case the list buffer size will be 1, representing
				//      the accumulated string literal. In that case we must append
				//	    the leadin string ($ql above) to the existing string and make
				//      it the leadin for this expression.
				// iii) There were prior expressions in the list, in which case, as per
				//      ii) we must merge the last literal in the buffer with ($ql) from
				//      above and make it the leadin string for this expression.
				//      NB: THis can aonly arise from "{expr}" ("STRING")* "{expr}"
				//
				switch	(strexp.size())
				{
					case 0:
			
						// Add the leadin string
						//
						JFXLiteral leader = F.at(pos($ql)).Literal
											(	TypeTags.CLASS,
											 	$ql.text
											);
						endPos(leader);

						// Add it in to the list
						//
						strexp.append(leader);
						
						break;	

					default:
					
						// Already had a single first literal, or a trailer for an 
						// expression - make it belong to this leader.
						//
						leader = (JFXLiteral)(strexp.elems.get(strexp.size()-1));
				
						// Now, append the string we have to the prior trailing part
						// and replace the original value
						//
						leader.value = (String)(leader.getValue()) + $ql.text;
						break;
				}
			}
			
		// Optional string format
		//
	    stringFormat	[strexp]
	    
	    // An expression to evaluate at runtime
	    // 
	  	e2=expression 					{ strexp.append($e2.value);	}
	  
	  	// Any number of inner elements
	  	//
	  	( stringExpressionInner [strexp]  )*   
	  
	  	// The last component of the {} enclosing string literal
	  	//
	  	qr=RBRACE_QUOTE_STRING_LITERAL
	  
	  		{
	  			// Add in the discovered literal
	  			//
	  			JFXLiteral trailer = F.at(pos($qr)).Literal
											(	TypeTags.CLASS,
											 	$qr.text
											);
				endPos(trailer);
				
				// Add to the list
				//
				strexp.append(trailer);	
			}
	;
	
// ----------------------
// String element with optional format expression
//
stringExpressionInner [ ListBuffer<JFXExpression> strexp]

	: rlsl=RBRACE_LBRACE_STRING_LITERAL 
	
		{
			// Construct a new literal for the leading literal
			//
			JFXExpression rb = F.at(pos($rlsl)).Literal(TypeTags.CLASS, $rlsl.text);
			
			// Record the span
			//
			endPos(rb);
			
			// Add the literal to the list
			//
			strexp.append(rb);
			
		}
		
		// Deal with the string format
		//
		stringFormat[strexp] 
		
		// Expression to evaluate at runtime
		//
		expression
		
		{
			strexp.append($expression.value);
		}
	;
	
// --------------------
// Format specification
// Optional format specifier in standard Java form
//
stringFormat [ ListBuffer<JFXExpression> strexp]

@init
{
	// The value to add in to the mix
	//
	JFXExpression value;
	
	// Work out current position in the input stream
	//
	int	rPos = pos();
}
	: fs=FORMAT_STRING_LITERAL
	
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, $fs.text);
			endPos(value);
			strexp.append(value);
		}
		
	| // no format
		{
			value = F.at(rPos).Literal(TypeTags.CLASS, "");
			endPos(value);
			strexp.append(value);
		}
	;
	
// ---------------------------
// Sequence
// Which is a [] enclosed expression list
//
bracketExpression

	returns [JFXExpression value] 	// Expression tree for stringExpressions

@init
{
	// Buffer in which to accumulate all string elements
	//
	ListBuffer<JFXExpression> seqexp = new ListBuffer<JFXExpression>();
    
    // Work out current position in the input stream
	//
	int	rPos = pos();
	
	// Optional step expression
	//
	JFXExpression	stepEx = null;
	
	// Optional LT qualifier
	//
	boolean 	haveLT	= false;
}

	: LBRACKET   
	
		( 	e1=expression
				{
					seqexp.append($e1.value);
				}
		     	(
		     		COMMA*
		     		  (
		     			
		     				(
		     					e2=expression
		     						{
		     							seqexp.append($e2.value);
		     						}
		     				)
		     				COMMA*
		     		  )*
	                    
	                    {
	                    	// Explicit sequence detected
	                    	//
	                    	$value = F.at(rPos).ExplicitSequence(seqexp.toList());
	                    	endPos($value);
	                    }
	                    
		     		| DOTDOT
		     			(LT { haveLT = true; })? 
		     			dd=expression
		     	    	( STEP st=expression { stepEx = $st.value; } )?
		     	    	
		     	    	{
		     	    		$value = F.at(pos($DOTDOT)).RangeSequence($e1.value, $dd.value, stepEx, haveLT);
		     	    		endPos($value);
		     	    	}
		     	)
		     	
		     |  // Empty sequence 
		     	{
		     		 $value = F.at(rPos).EmptySequence();
		     		 endPos($value);
		     	}
	    )
	  RBRACKET
	;

// ----------------
// Expression list.
// Comma separated list of expressions.
//
expressionList

	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up

	: e1=expression
		
		{
			args.append($e1.value);
		}
		
		(
			COMMA 	(
						e2=expression
						
						{
							args.append($e2.value);
						}
					)?
		)*
	|
	;

// ------------------------
// Optional expression list
// For the moment this is only used by New....
//
expressionListOpt
	
	returns [ListBuffer<JFXExpression> args = new ListBuffer<JFXExpression>()]	// List of expressions we pcik up

	: (LPAREN)=>LPAREN expressionList RPAREN
		{
			$args = $expressionList.args;
		}
		
	|	// Was not present
	;


// -----
// Types
//
type

	returns [JFXType rtype]

@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: typeName cardinality
	
		{
			$rtype = F.at(rPos).TypeClass($typeName.value, $cardinality.ary);
			endPos($rtype);
		}
		
 	| FUNCTION 
 		LPAREN 
 			typeArgList
		RPAREN 
		
			ret=typeReference 
          	cardinality	//TODO: this introduces an ambiguity: return cardinality vs type cardinality
          	
		{
			$rtype = F.at(rPos).TypeFunctional($typeArgList.ptypes.toList(), $ret.rtype, $cardinality.ary);
			endPos($rtype);
		}

 	| STAR cardinality
 	
 		{
 			$rtype = F.at(rPos).TypeAny($cardinality.ary);
 			endPos($rtype);
 		}
 	;

// ----------------------------
// A list of types as arguments
//
typeArgList
 	
 returns [ListBuffer<JFXType> ptypes = ListBuffer.<JFXType>lb(); ]
 
 	: t1=typeArg
 	
 		{
 			ptypes.append($t1.rtype);
 		}
 		 
 		(
 			COMMA 
 			(
 				t2=typeArg
 				
 				{
 					ptypes.append($t2.rtype);
 				}
 			)?
 		)*
 	|
	;

// -------------------------
// Individual typed argument
//
typeArg 

	returns [JFXType rtype]

 	: (
 		(
 			name	// TODO: Check this, it is currently ignored for AST and does not
 					//       look quite right.
 		)? 
 			COLON
 	  )?
 	  
 	  type
 	
 		{
 			$rtype = $type.rtype;
 		}
 	;
 	
 // --------------
 // Type reference
 // Used to build parameter lists for functions etc
typeReference

	returns	[JFXType rtype]
	
 	: COLON type
 	
 		{
 			$rtype = $type.rtype;
 		}
 		
 	| // Untyped element, the AST needs to reflect that
 	
 		{ 
 			$rtype = F.TypeUnknown(); 
 		}

 	;
 	
// -------------------------
// Array indicator for types
//
cardinality

	returns [TypeTree.Cardinality ary]
	
	: (LBRACKET)=>LBRACKET RBRACKET
	
		{
			$ary = TypeTree.Cardinality.ANY;
		}
		
	|	{
			$ary = TypeTree.Cardinality.SINGLETON;
		}
	;

// ----------
// Named type
// Possibly a generic
//
typeName

	returns [JFXExpression value]

@init
{
	// Accumulate any generic arguments
	//
	ListBuffer<JFXExpression> exprbuff = ListBuffer.<JFXExpression>lb();
}

	: qualname 		
		(
			  LT ga1=genericArgument 	{ exprbuff.append($ga1.value); }
			  	
			  		(
			  			COMMA
			  				(
			  					ga2=genericArgument
			  				
			  							{ exprbuff.append($ga2.value); }
			  				)?
			  		)* 
			  GT
			  
			  {
			  	// AST for generic
			  	//
			  	// TODO: Implement this?
			  	//
			  	log.error(pos($LT), "javafx.generalerror", "Java generic type declarations are not currently supported");
			  }
			  
			|	// Non generic
				{
					$value = $qualname.value;
				}
		)
	;
	
genericArgument

	returns [JFXExpression value]

@init 
{
	BoundKind 		bk 		= BoundKind.UNBOUND;
	JFXExpression 	texpr 	= null; 
}

	: typeName	{ $value = $typeName.value; }
	
	| QUES 
		(  
			( 
				  EXTENDS 		{ bk = BoundKind.EXTENDS; 	}
		  		| SUPER			{ bk = BoundKind.SUPER; 	}
		  	) 
		 	typeName			{ texpr = $typeName.value; }
		)?
		
		{
			// TODO: NYI - Remove or implement?
		}
	;

// --------
// Literals.
// Incorporates all literals except STRING_LITERAL which is dealt with
// in the stringExpression rule
//
literal

	returns [JFXExpression value]
	
@init
{
    // Work out current position in the input stream
	//
	int	rPos = pos();
}
	: 
		(
			 DECIMAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($DECIMAL_LITERAL.text, 10));
				}
				
			| OCTAL_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($OCTAL_LITERAL.text, 8));
				}
			
			| HEX_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.INT, (int)Convert.string2long($HEX_LITERAL.text, 16));
				}
				
		    | TIME_LITERAL
		    
		    	{
		    		$value = F.at(rPos).TimeLiteral($TIME_LITERAL.text);
		    	}
		    	
			| FLOATING_POINT_LITERAL
			
				{
					$value = F.at(rPos).Literal(TypeTags.DOUBLE, Double.valueOf($FLOATING_POINT_LITERAL.text));
				}
				
			| TRUE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 1);
				}
				
			| FALSE
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOOLEAN, 0);
				}
				
			| NULL
			
				{
					$value = F.at(rPos).Literal(TypeTags.BOT, null);
				}
		)
		
		{
			// Tree span
			//
			endPos($value);
		}
	;

// -------------------------	
// Qualified (possibly) name
//
qualname

	returns [JFXExpression value]
	
	: n1=name
		{
			$value = F.at($n1.pos).Ident($n1.value);
			endPos($value, $n1.pos + $n1.value.length());
		}
		( 
			(DOT)=> DOT n2=name
			
				{
					$value = F.at(pos($DOT)).Select($value, $n2.value);
					endPos($value); 
				}
			
		)*  
	;

// -----------------------
// ID
// Basic identifier parse
//
identifier

	returns [JFXIdent value]

	: n1=name
		{
			$value = F.at($n1.pos).Ident($n1.value);
						endPos($value, $n1.pos + $n1.value.length());
		}
	;

// ------------------------
// ID
// Parse and identifier token that isn't necessarilly an Identifier,
// it could just be a tag or function name etc.
//
name 

	returns [Name value, int pos]
	
	: IDENTIFIER
	
		{ 
			$value = Name.fromString(names, $IDENTIFIER.text); 
			$pos = pos($IDENTIFIER); 
		}
						
	;
